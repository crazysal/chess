//File-----------------------IRincludes.h----------------------------- 
 
#ifndef __IR_INCLUDES_H__ 
#define __IR_INCLUDES_H__ 
 
/** File "IRmain.cpp" or "IRall1file.cpp"  CREDITS:
- 500-line original by Venkateswaran Yamachandran, Spring 2008
- First full working version by Kenneth W. Regan, August 2008
- Maintained through August 2008 by KWR
- Extended to read Analysis Interchange Format by Tamal Biswas, Fall 2012.
  AIF itself programmed by Biswas
- Extended by Biswas and KWR to implement depth=of-calculation parameter(s).
Copyright (c) Kenneth W. Regan.  Not yet licensed under GPL.

Usage: Compile //with highest optimization//, no makefile needed.   
       Run a.out and follow menus and prompts. 
 
REQUIRES: Data file "RefTurns.aif" in same directory as executable.
Data files of readable analysis have extension .aif and this format:
 
[Event "7th Mikhail Tal Memorial"] 
[Site "Moscow RUS"] 
[Date "2012.06.08"] 
[Round "1"] 
[White "Radjabov,T"] 
[Black "Tomashevsky,E"] 
[Result "1-0"] 
[ECO "C45"] 
[WhiteElo "2784"] 
[BlackElo "2738"] 
[PlyCount "??"] 
[EventDate "2012.06.08"] 
[Source "??"] 
[SourceDate "??"] 
[ply "??"] 
[PlyDepth "13"] 
[EngineID "Rybka 3 1-cpu"] 
 
1. e4 e5 2. Nf3 Nc6 3. d4 exd4 4. Nxd4 Bc5 5. Nb3 Bb6 6. Nc3 d6 7. Qe2 Nge7 8. Be3 O-O 9. O-O-O f5 10. exf5 Bxf5 11. h3 Bd7 12. Qd2 Bxe3 13. Qxe3 Kh8 14. Bd3 Qe8 15. f4 Qf7 16. Rhf1 Rae8 17. Qd2 Nb4 18. Be4 Bc6 19. Rde1 Bxe4 20. Nxe4 Qc4 21. a3 Nbc6 22. Qc3 Qd5 23. Nbd2 Nf5 24. g4 Nfd4 25. Qd3 b5 26. Kb1 b4 27. a4 h6 28. Nb3 Re7 29. Ned2 Rxe1+ 30. Rxe1 g5 31. f5 1-0 
 
[GameID "Radjabov;Tomashevsky;2012.06.08;7th;1"] 
[MoveNo "9-w"] 
[MovePlayed "O-O-O"] 
[EngineMove "O-O-O"] 
[FEN  "r1bq1rk1/ppp1nppp/1bnp4/8/4P3/1NN1B3/PPP1QPPP/R3KB1R w KQ - 4 9"] 
[RepCount "0"] 
[Eval " n.a."] 
[PrevEval " n.a."] 
[NextEval " +004"] 
[LegalMoves "Ra1-b1, Ra1-c1, Ra1-d1, a2-a3, a2-a4, Nb3-a5, Nb3-c5, Nb3-d4, Nb3-d2, Nb3-c1, Nc3-b1, Nc3-a4, Nc3-b5, Nc3-d5, Nc3-d1, Ke1-d2, Ke1-d1, Qe2-d2, Qe2-d1, Qe2-f3, Qe2-g4, Qe2-h5, Qe2-d3, Qe2-c4, Qe2-b5, Qe2-a6, Be3-c1, Be3-d2, Be3-f4, Be3-g5, Be3-h6, Be3-d4, Be3-c5, Be3xb6, e4-e5, f2-f3, f2-f4, g2-g3, g2-g4, Rh1-g1, h2-h3, h2-h4, 0-0-0"] 
[LegalMovesSAN "Rb1, Rc1, Rd1, a3, a4, Na5, Nc5, Nd4, Nd2, Nc1, Nb1, Na4, Nb5, Nd5, Nd1, Kd2, Kd1, Qd2, Qd1, Qf3, Qg4, Qh5, Qd3, Qc4, Qb5, Qa6, Bc1, Bd2, Bf4, Bg5, Bh6, Bd4, Bc5, Bxb6, e5, f3, f4, g3, g4, Rg1, h3, h4, 0-0-0"] 
[NumLegalMoves "43"] 
[FiftyMR "4"] 
[RepLine1 ""] 
[RepLine2 ""] 
 
------------------------------------------------------------------------ 
         1    2    3    4    5    6    7    8    9   10   11   12   13 
------------------------------------------------------------------------ 
0-0-0  n.a. +008 +009 -003 +006 +004 +009 +001 +006 +011 +010 +009 +005 
a3     n.a. -026 -008 -004 -001 -016 -008 -009 -018 -018 -008 -005  000 
f4     n.a. -043 -052 -040 -054 -010 -010 -005 -009 -015 -009 -005  000 
h3     n.a. -006 -001 -013 -013 -004 -008 -008 -009 -009 -009 -004 -005 
h4     n.a. -029 -005 -004 -002 -001 -004 -004 -004 -007 -004 -007 -007 
Qd2    n.a. -032 -020 -005 -005 -005  000 -014 -008 -005 -003 -014 -014 
Rg1    n.a. -040 -011 -034 -031 -031 -033 -029 -018 -021 -021 -016 -016 
f3     n.a. -013 -008 -010 -009 -014 -024 -021 -017 -024 -020 -020 -016 
Bxb6   n.a. -058 -053 -053 -046 -047 -047 -037 -033 -026 -018 -017 -017 
g3     n.a. -064 -039 -029 -019 -029 -028 -029 -029 -021 -026 -026 -022 
Qd3    n.a. -096 -070 -068 -060 -057 -054 -030 -036 -031 -024 -024 -026 
Qh5    n.a. -075 -069 -076 -042 -038 -028 -029 -043 -032 -032 -030 -027 
Qf3    n.a. -065 -052 -047 -030 -037 -033 -028 -025 -027 -048 -032 -032 
Nd2    n.a. -037 -028 -048 -032 -036 -044 -028 -048 -058 -041 -041 -038 
Bg5    n.a. -062 -048 -053 -023 -031 -024 -033 -033 -042 -037 -037 -039 
a4     n.a. -044 -032 -037 -031 -037 -052 -051 -048 -045 -045 -043 -046 
Nb5    n.a. -051 -041 -060 -031 -050 -061 -045 -045 -056 -056 -056 -047 
Bd2    n.a. -042 -047 -051 -038 -036 -037 -038 -042 -044 -045 -044 -048 
Qd1    n.a. -090 -087 -058 -096 -041 -041 -067 -056 -056 -056 -051 -051 
Rd1    n.a. -051 -055 -060 -052 -060 -060 -060 -055 -056 -056 -055 -053 
Na4    n.a. -055 -054 -042 -041 -053 -075 -049 -049 -056 -056 -056 -054 
Nd1    n.a. -089 -091 -096 -082 -077 -070 -052 -067 -063 -068 -055 -055 
Bf4    n.a. -073 -044 -056 -053 -054 -056 -058 -057 -057 -058 -054 -063 
Nb1    n.a. -094 -087 -096 -082 -077 -075 -061 -067 -067 -084 -061 -064 
Bc1    n.a. -086 -078 -070 -067 -071 -056 -063 -067 -076 -072 -064 -064 
g4     n.a. -093 -073 -067 -053 -052 -049 -066 -063 -059 -059 -059 -065 
Qb5    n.a. -095 -080 -090 -084 -073 -070 -088 -077 -062 -062 -062 -066 
Nc1    n.a. -072 -079 -071 -098 -089 -092 -082 -075 -067 -069 -064 -069 
Rc1    n.a. -061 -071 -066 -070 -077 -078 -078 -072 -064 -075 -084 -070 
Rb1    n.a. -061 -071 -078 -082 -082 -076 -076 -073 -090 -079 -079 -073 
Nd5    n.a. -060 -080 -075 -065 -080 -080 -097 -089 -084 -084 -095 -075 
Qc4    n.a. -105 -121 -108 -112 -111 -108 -105 -090 -089 -089 -094 -082 
Kd2    n.a. -087 -092 -116 -111 -332 -340 -343 -343 -341 -342 -342 -342 
e5     n.a. -128 -146 -138 -143 -152 -139 -140 -139 -138 -140 -140 -132 
Kd1    n.a. -087 -127 -118 -121 -139 -133 -131 -144 -143 -121 -121 -135 
Bh6    n.a. -238 -241 -241 -248 -253 -252 -231 -252 -252 -248 -245 -245 
Nd4    n.a. -294 -303 -298 -294 -295 -284 -296 -288 -299 -294 -288 -283 
Nc5    n.a. -286 -291 -283 -288 -294 -280 -275 -282 -284 -298 -298 -288 
Na5    n.a. -290 -288 -298 -297 -286 -293 -304 -312 -320 -319 -310 -308 
Bd4    n.a. -349 -343 -348 -351 -341 -344 -330 -340 -329 -327 -328 -325 
Bc5    n.a. -330 -339 -332 -339 -345 -349 -349 -349 -355 -357 -345 -349 
Qe2    n.a. n.a. n.a. n.a. n.a. n.a. -340 -340 -320 -338 -338 -325 -325 
Ba6    n.a. n.a. n.a. n.a. n.a. -317 PRUN PRUN PRUN PRUN PRUN PRUN PRUN 
Qg4    n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. 
Qa6    n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. n.a. 
 
======================================================================== 
 
[GameID "Radjabov;Tomashevsky;2012.06.08;7th;1"] 
[MoveNo "9-b"] 
[MovePlayed "f7-f5"] 
[EngineMove "f7-f5"] 
[FEN  "r1bq1rk1/ppp1nppp/1bnp4/8/4P3/1NN1B3/PPP1QPPP/2KR1B1R b - - 5 9"] 
[RepCount "0"] 
[Eval " +004"] 
[PrevEval " n.a."] 
[NextEval " +004"] 
[LegalMoves "a7-a6, a7-a5, Ra8-b8, Bb6-a5, Bb6xe3, Bb6-d4, Bb6-c5, Nc6-b4, Nc6-a5, Nc6-b8, Nc6-e5, Nc6-d4, Bc8-h3, Bc8-g4, Bc8-f5, Bc8-e6, Bc8-d7, d6-d5, Qd8-e8, Qd8-d7, Ne7-d5, Ne7-g6, Ne7-f5, f7-f6, f7-f5, Rf8-e8, g7-g6, g7-g5, Kg8-h8, h7-h6, h7-h5"] 
[LegalMovesSAN "a6, a5, Rb8, Ba5, Bxe3, Bd4, Bc5, Nb4, Na5, Nb8, Ne5, Nd4, Bh3, Bg4, Bf5, Be6, Bd7, d5, Qe8, Qd7, Nd5, Ng6, Nf5, f6, f5, Re8, g6, g5, Kh8, h6, h5"] 
[NumLegalMoves "31"] 
[FiftyMR "5"] 
[RepLine1 ""] 
[RepLine2 ""] 
 
------------------------------------------------------------------------ 
         1    2    3    4    5    6    7    8    9   10   11   12   13 
------------------------------------------------------------------------ 
f5     n.a. n.a. n.a. +005 +005 +005 +005 +005 +005 +005 +005 +005 +004 
Be6    n.a. n.a. n.a. +013 +013 +013 +013 +013 +013 +013 +013 +007 +010 
Ng6    n.a. +010 +010 +010 +010 +010 +010 +013 +013 +013 +013 +015 +016 
Re8    n.a. +013 +013 +012 +013 +013 +013 +007 +015 +015 +011 +017 +016 
h6     n.a. +012 +013 +012 +012 +012 +013 +013 +020 +013 +015 +015 +019 
Kh8    n.a. +033 +030 +026 +020 +036 +029 +028 +037 +031 +031 +021 +021 
Bd7    n.a. +020 +016 +023 +017 +025 +024 +024 +023 +021 +017 +021 +022 
Bxe3   n.a. n.a. n.a. +010 +010 +010 +010 +013 +017 +016 +018 +018 +023 
Na5    n.a. +041 +036 +043 +036 +033 +033 +027 +022 +025 +029 +025 +024 
Ne5    n.a. n.a. n.a. +024 +024 +024 +024 +020 +022 +023 +024 +025 +025 
Rb8    n.a. +022 +026 +028 +016 +020 +017 +019 +018 +020 +020 +016 +028 
Qd7    n.a. +029 +015 +013 +016 +028 +026 +020 +026 +016 +024 +026 +028 
Qe8    n.a. +024 +012 +026 +020 +026 +024 +022 +015 +022 +027 +029 +028 
Nb8    n.a. +056 +043 +041 +040 +040 +047 +049 +045 +049 +040 +037 +038 
Nb4    n.a. +042 +042 +035 +036 +038 +031 +038 +036 +039 +038 +034 +040 
f6     n.a. +024 +026 +026 +023 +025 +020 +018 +039 +031 +033 +037 +040 
a6     n.a. +027 +073 +070 +074 +060 +060 +055 +065 +066 +066 +063 +069 
Ba5    n.a. +100 +091 +088 +090 +080 +080 +077 +073 +080 +074 +075 +075 
a5     n.a. +034 +034 +045 +040 +040 +057 +057 +055 +054 +056 +055 +077 
g6     n.a. +041 +037 +047 +035 +045 +036 +080 +088 +082 +094 +084 +086 
d5     n.a. +087 +085 +092 +095 +108 +135 +139 +122 +122 +094 +086 +086 
h5     n.a. +077 +085 +089 +093 +098 +096 +091 +085 +096 +096 +090 +091 
g5     n.a. +135 +130 +136 +141 +150 +160 +153 +173 +180 +184 +184 +191 
Nf5    n.a. +179 +184 +171 +171 +177 +178 +178 +177 +183 +193 +190 +200 
Bf5    n.a. +169 +170 +159 +172 +186 +200 +203 +203 +206 +207 +212 +208 
Nd5    n.a. +281 +288 +288 +279 +277 +272 +273 +275 +269 +266 +274 +270 
Bg4    n.a. +240 +256 +262 +275 +277 +272 +270 +263 +270 +284 +280 +280 
Nd4    n.a. +290 +289 +291 +279 +277 +284 +295 +295 +294 +298 +300 +300 
Bh3    n.a. +293 +284 +297 +293 +294 +295 +299 +302 +301 +296 +302 +303 
Bd4    n.a. +300 +309 +304 +305 +309 +316 +314 +313 +315 +322 +313 +316 
Bc5    n.a. +312 +328 +326 +320 +322 +332 +330 +327 +326 +324 +321 +329 
 
======================================================================== 
 
 
OBJECTS: The Ensemble holds a list of TurnInfo records for each game turn in 
the data, which is further filtered into a list of DecisionInfo giving 
processed data for statistical analysis.  The Ensemble holds Catalogs of: 
 
() user-buildable TurnFilters for selecting subsets of the data; 
() user-definable TrialSpecs each specifying a curve, "s" and "c" 
   parameters, and a statistical weighting method; and 
() user-definable Trials, each linked to a mutable TrialSpec and specifying 
   information for statistical fitting routines. 
 
Statistical regression is done with temporary Minimizer objects, currently 
outfitted only with primitive binary-search minimization ("veeFinder" etc.) 
#Going to use GSL library for that.. 
of various least-squares distances and maximum-likelihood quantities. 
Fit results are stored into PerfData, which can export and import fullReports. 
One Trial and its TrialSpec have "focus" at any one time, and TurnFilters 
are attachable to and detachable from each trial separately.  Users can  
"hide" TrialSpecs (e.g. dummies used before fitting) and TurnFilters to 
keep screen lists tidy.  Demos hide (most) filters and specs they create. 
 
User interaction is governed by a menuing system (classes EnumMenu and 
DynamicMenu, which are composed into Catalogs) that logs all user commands 
by callback to the Ensemble via the Logging interface, to "IRcommandLog.txt". 
Users may select options by name or conveniently by number, while the command 
names are logged to make all sessions *replayable* from the main menu. 
Several suppied Demos illustrate the "mini programming language" of commands. 
Data is writen to screen and to "IRsessionData.txt", with the user able to 
specify other output files and/or close these streams.  Demos can use 
"IRdemos.txt" or another user-designated file, for output then input. 
Constants, limits, and math functions are defined in the IRutil namespace. 
 
 
USAGE:  The text-based menus try to be explanatory.  No help system (as yet). 
Users are automatically set up with one trial and a handful of filters. 
 
 
CODE NOTES:  Near-term to-do list: 
() Fully decide on and implement how to control/mute output to the screen. 
() Resolve whether to keep, improve, or discard "parsePerfData" from files. 
() Revisit public/private, especially for Ensemble and Minimizer classes. 
() Rearrange the Ensemble implementation code and clean up for consistency. 
 
Longer-term: 
() Implement better minimization routines (e.g. "gosset" [NJS] for C++?). 
() Add routines to do automated cheating-testing of specific sets of games. 
() Add more curves and weights and statistical methods and demos! 
() Collect and compile more chess-game data!! 
() Implement the full model with earlier ply depths and "swing"!!! 
 
The code follows Java and C# conventions where it is convenient to do so. 
Objects from classes with virtual functions or that embed arrays are held via 
explciit pointers, rather than references.  Code is (mostly) "const"-correct; 
indeed, modifications are done below (const) pointers by "const" methods. 
Distinctive features of C++ (as oppposed to MatLab, say): 
 
() Standard Template Library containers list and map (and of course vector). 
() Function objects used for TurnFilter and DeltaScale, factoring common code. 
() Extensive use of C++ streams, especially reading from stringstreams. 
() Numerical code needs to be *fast*, with many Newton iterations performed. 
() Inheritance and composition used extensively for menu/catalog system. 
 
*/ 
 
#include <iostream> 
#include <iomanip> 
#include <istream> 
#include <fstream> 
#include <sstream> 
#include <stdio.h> 
#include <stdlib.h> 
#include <string> 
#include <cstring>
#include <cmath> 
#include <vector> 
#include <list> 
#include <set>
//#include <unordered_set>
#include <deque>
#include <map> 
#include <algorithm>  //for sort and max
#include <iterator>
#include <limits> 
#include <ctime> 
#include <glob.h>
#include <sys/param.h>
#include <unistd.h>

#define OS_UNIX 


#ifdef OS_UNIX 
#include <gsl/gsl_multimin.h>    //not redundant, loaded by multimin.c anyway
//#include "multimin.h" 
//#include "multiminBak.c"    //wrapper to nicer interface
//#include "gsl_multimin.c"

//#ifndef IR_MULTIMIN_C__
//#include "multimin.c"
//#endif 

#include <gsl/gsl_siman.h>

//#ifdef __cplusplus
//extern "C" {
//#endif

//#include <cminpack.h>
#include <minpack.h>  // loads cminpack.h anyway

//#ifdef __cplusplus
//}
//#endif

#endif 
 
 
using namespace std; 
 
#endif    //end of #ifndef __IR_INCLUDES_H__ 
 
 
 
//File-------------------------IRutil.h-------------------------------------- 
 
#ifndef __IR_UTIL_H__ 
#define __IR_UTIL_H__ 
 
namespace IRutil {    
 
   const string DASHLINE = 
   "------------------------------------------------------------------------"; 
   const string DASHES = "----------";
   const size_t MAXDEPTH = 99;   //exact value almost immaterial, used for only 1 object
   const size_t MAXNUMLEGALMOVES = 100;  //ditto
   //const int NCUTOFF = 64;               //ditto
   const int NCUTOFF = 50;
   const int MATEVALCP = 100000;
   const double MATEVAL = 1000.0;
   const int NAVAL = 100001;          //indicates analysis value not available
   const int PRUNVAL = 100002;
   const int NRECVAL = 100003;
   const int DEFAULTDEPTH = 17;       //prefer 19 or 20 or *; 13 was for Rybka

   static int turnsMade = 0;
   static int turnsDeleted = 0;
   static int decsMade = 0;
   static int decsDeleted = 0;
   static int tuplesMade = 0;
   static int tuplesDeleted = 0;
   static int perfDataMade = 0;
   static int perfDataDeleted = 0;
   const int TUPLEMODULUS = 50000000;
   const int LINESMODULUS = 100000;
   const int TURNSMODULUS = 50000;

   
   const int playedMoveNotInTopN = NCUTOFF;    //should be unused?
   const double DELTACAP = 10.00;     //Perl script's default is 10.00, but prefer 7.00 or 9.00?
   const double PRUNCAP = 9.00;      //use 4.00 for Rybka
   //const double EVALMEMOCAP = 5.00;   //!!! change to 5.0 after debugging curves
                                      //would use 10.0 or higher with unscaled deltas
   //const double MEMO_DENSITY = 100.0;   //allows extra precision place on scaled deltas
   //const size_t MEMO_SIZE = size_t(MEMO_DENSITY * IRutil::EVALMEMOCAP) + 1;

   const double MINGTZERO = 0.00000001; //any smaller number is considered zero 
   const double MINPROB = MINGTZERO;   
   const double P0TOLERANCE = min(0.999999, 1.0 - MINPROB); 
   const double INVVARP0CAP = 100.0; 
     //maximum value for probs[0]---IMPT: = initial Newton point for vectorRoot 
   const double SUMPROBSTOLERANCE = (1 - P0TOLERANCE) + MINPROB*MAXNUMLEGALMOVES/5; //divide latter by 10? 
   const double SHOUTTOLERANCE = 1.005;
   const double TOPMOVETOLERANCE = 0.00001;  //allows for after scaling, less than it means 0.00 
   const double LINESCALEEPSILON= 0.005;

   const double CVTOLERANCE = 0.001;  //lower coeffs of variation treated as 0
   const double VRPREC = MINPROB;  //for VectorRoot 
   const double MAXINV = 1/MINPROB; 
   const int VRDEPTH = 32;       //for debugging Newton's method. 
    
   const int AIFoffset = 1;      //AIF begins indexing depths at 1
   static ios::fmtflags URFORMAT = cout.flags(); 
   const string IRCOMMENT = "//IR "; 
   const string LOGFILENAME = "IRcommandLog.txt"; 
   const string SESSIONFILENAME = "IRsessionData.txt"; 
   const string DEMOFILENAME = "IRdemos.txt"; 

   const double CENTRALPATCHPOWER = 0.58;  //was 0.5806
    
   //--------------------------String Utilities-------------------------------- 

   static set<string> PROBLEM_FENS;
   static set<string> PROBLEM_GAMES;

   inline int ord(char c) { return (unsigned char)c; }
   inline char chr(int n) {
      return (unsigned char)n;
   }
    
   inline void finishLine(istream& IN) { 
     //after www.daniweb.com/forums/thread90228.html 
     IN.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); 
   } 
    
   inline string trim(const string& st) { 
      int left = 0; 
      int right = st.size() - 1; 
      while (left <= right && isspace(st[left])) { 
         left++; 
      } 
      while (right >= left && isspace(st[right])) { 
         right--; 
      } 
      return st.substr(left,right-left+1); 
   } 
   inline char makeUpper(char c) {
      return ('a' <= c && c <= 'z' ? chr(ord(c) - 32) : c);
   }
   inline char makeLower(char c) {
      return ('A' <= c && c <= 'Z' ? chr(ord(c) + 32) : c);
   }

   inline string fetchField(const string& line) {  //finds first str in "str"
      size_t qstart = line.find('\"');
      size_t qend = line.find('\"',qstart+1);
      return ((qstart != string::npos && qend != string::npos) ?
               IRutil::trim(line.substr(qstart+1,qend-qstart-1)) : "");
   }

 
   inline string getBetweenDelm(const string& st, char begDel, char endDel) { 
      int delmStart = st.find(begDel); 
 
      int delmEnd = st.find(endDel,delmStart+1); 
 
      if ((delmStart == -1) || (delmEnd == -1)) 
         return ""; 
 
      return IRutil::trim(st.substr(delmStart+1, delmEnd-delmStart-1)); 
   } 
    
 
   inline bool isIRComment(const string& st) { return trim(st) == trim(IRCOMMENT); } 
    
   /** Must be called on strings of length2 only. 
    */ 
   inline bool isInNumber(char c, char prevChar) { 
      return isdigit(c)  
          || (c == '.' && isdigit(prevChar)) 
          || (c == 'e' && isdigit(prevChar)) 
          || ((c == '+' || c == '-') && (prevChar == 'e' || prevChar == 'E')); 
   } 
    
   /** Finds legal doubles embedded in lines.   
       TRICK: must regard e.g. "3--4" as 3 and 4, not 3 and -4. 
    */ 
   inline vector<double> extractDoubles(const string& line) { 
      vector<double> nums(0); 
      bool inNumFlag = false; 
      int i = 0; 
      while (i < line.size()) { 
         if (isdigit(line[i]) && !inNumFlag) { 
            int j = i; 
            if (i > 0 && (line[i-1] == '-' || line[i-1] == '+') 
                      && (i == 1 || (line[i-2] != '-' && line[i-2] != '+'))) { 
               j = i - 1;  //number begins with - sign, or with extra + sign. 
            } 
            istringstream istr(line.substr(j)); 
            double x; 
            istr >> x; 
            inNumFlag = true; 
            nums.push_back(x); 
            i++; 
         } else if (inNumFlag) { 
            if (!isInNumber(line[i], line[i-1])) {  //NB: Always i > 0 here. 
               inNumFlag = false; 
            } 
            i++; 
         } else {   //not a digit and not flagged, so look for next number 
            i++; 
         } 
      } 
      return nums; 
   } 
    
   inline string ftoa(const double x, const int places = -1) { 
      ostringstream o; 
      if (places >= 0) {  
         o << fixed << setprecision(max(places,1)) << showpoint;  
      } 
      o << x; 
      return o.str(); 
   } 
    
   inline string itoa(const int x) { 
      ostringstream o; 
      o << x; 
      return o.str(); 
   } 

   inline string itoa(const int x, const int places) {
      ostringstream o;
      o << x;
      string st = o.str();
      for (int i = st.size(); i < places; i++) {
         st = " " + st;
      }
      return st;
   }

    
   inline bool isYes(const string& ans, bool deflt = true) { 
      return (ans.size() == 0 && deflt) 
                || ans.size() > 0 && (ans[0] == 'y' || ans[0] == 'Y'); 
   } 

   inline bool isFilled(const string& ans, bool deflt = true) {
      return (ans.size() == 0 && deflt)
                || ans.size() > 0 && (ans[0] != '?');
   }
    
   /** Match if arg occurs in st surrounded by ends or non-alpha chars. 
       Intent is e.g. for "Karp" to match "Karp, R" but not "Karpov". 
       Works even if arg itself has non-alpha characters. 
    */ 
   inline bool delimitedMatch(const string& arg, const string& st) { 
      int fromPos = st.find(arg); 
      while (fromPos != string::npos) { 
         bool leftOK = (fromPos == 0 || !isalpha(st[fromPos-1])); 
         int rightEdge = fromPos + arg.size(); 
         bool rightOK = (rightEdge == st.size() || !isalpha(st[rightEdge])); 
         if (rightOK && leftOK) { 
            return true; 
         } else { 
            fromPos = st.find(arg,fromPos+1); 
         } 
      } 
      return false; 
   } 

   inline map<string,double> parseStarredPairs(string pairs) {
      map<string,double> ret;
      size_t pos = pairs.find("(*");
      while (pos != string::npos) {
         size_t pos2 = pairs.find("*,");
         string key = pairs.substr(pos+2,pos2-pos-2);
         size_t pos3 = pairs.find(")");
         double value = atof(pairs.substr(pos2+2,pos3-pos2-2).c_str());
         ret[key] = value;
         pairs = pairs.substr(pos3+1);
         pos = pairs.find("(*");
      }
      return ret;
   }
    
   //----------------Calendar and Time Utilities--------------------- 
    
   enum DATE_FORMAT {  
      ARENA_FORMAT,      //format of the Arena 1.99b5 GUI, yyyy.mm.dd 
      NUM_FORMATS 
   }; 
    
   class SimpleDate { 
      int year; 
      int month; 
      int day; 
    public:  
      SimpleDate(int yr, int mo, int dy) : year(yr), month(mo), day(dy) { } 
      SimpleDate(const string& st, DATE_FORMAT format) { 
         string st1 = trim(st); 
         switch(format) { 
          case ARENA_FORMAT: 
            { 
               int firstDotPos = st1.find('.'); 
               int secondDotPos = st1.find_last_of('.'); 
               year = atoi((st1.substr(0, firstDotPos)).c_str()); 
               month = atoi((st1.substr(firstDotPos + 1,  
                                secondDotPos - firstDotPos - 1)).c_str()); 
               day = atoi((st1.substr(secondDotPos + 1)).c_str()); 
            } 
            break; 
          default: 
            cerr << "Unparsable date!" << endl; 
         } 
      } 
    
      int mangledDate() const { 
         return 10000*year + 100*month + day; 
      } 
      int getYear() const { 
         return year; 
      } 
      operator string() const { 
         return itoa(year) + '.' + itoa(month) + '.' + itoa(day); 
      } 
   }; 
    
   inline string getTime() { 
      time_t currentTime = time(NULL); 
      string timeOut = ctime(&currentTime); 
      return trim(timeOut); 
   } 
    
   inline string getRawTime() { 
      ostringstream o; 
      o << time(NULL); 
      return o.str(); 
   } 
    
   /** Hack found on Net to kill "cout" when instream is not "cin". 
       Took out "std::ios(&m_sbuf)," from constructor. 
    */ 
   struct nullstream: std::ostream { 
      struct nullbuf: std::streambuf { 
         int overflow(int c) { return traits_type::not_eof(c); } 
      } m_sbuf; 
      nullstream(): std::ostream(&m_sbuf) {} 
   }; 

   /** Get current working directory, by user Erroneous at 
       http://stackoverflow.com/questions/2203159/is-there-a-c-equivalent-to-getcwd
    */
   static string getmycwd() {
      char *buffer = new char[MAXPATHLEN];
      getcwd(buffer,MAXPATHLEN);
      if (buffer != NULL) {
         string ret(buffer);
         delete[] buffer;
         return ret;
      } else {
         return string();
      }
   }
    
    
   //---------------Numerical Utilities--------------------------------- 

   inline int sgn(int x) { return (x > 0) - (x < 0); }
    
   inline double sqr(const double x) { return x*x; } 
 
   inline double cube(const double x) { return x*x*x; } 
 
   inline double divifgt0(const double x, const double y) {
      return (y > 0.0 ? x/y : (fabs(x) < MINPROB ? 0.0 : 1.0/MINPROB));
   }

   inline double divifne0(const double x, const double y) {
      return (y != 0.0 ? x/y : (fabs(x) < MINPROB ? 0.0 : 1.0/MINPROB));
   }

   inline double log2(double x) { 
      return log(x)/log(2.0); 
   } 

   inline double arcsinh(double x) {
      return log(x + sqrt(1.0 + x*x));
   }
 
   inline double round(const double x, int place = 0) { 
      double by = 1.0; 
      int i = 0; 
      while (i < place) { by *= 10; i++; } 
      int rounded = (int)(by*x + 0.5); 
      return rounded / by; 
   } 
 
   /** Given y = x*ln(x), compute x to high precision.  Code from the book 
       W.H Press et al., "Numerical Recipes, The Art of Scientific Computing 
       (3rd ed.)", C.U.P. 2007, section 6.11. 
    */ 
   inline double invxlnx(const double y) { 
      double t0 = 0; 
      double t; 
      const double ie = 0.367879441171442322; 
      if (y >= 0 || y <= -ie) { 
         cerr << "Invalid argument for primary branch of invxlnx." << endl; 
         return -100000000; 
      } 
      double u = (y < -0.2) ? log(ie - sqrt(2*ie*(y + ie))) : -10.0; 
      do { 
         t = (log(y/u) - u)*(u/1.0 + u); 
         u += t; 
         if (t < 1.0e-8 && fabs(t + t0) < 0.01*fabs(t)) { 
            break;  //exits do-while loop 
         } 
         t0 = t; 
      } while (fabs(t/u) > 1.0e-15); 
      return exp(u); 
   } 

 
   /** Random number between a and b-1, using built-in rand() but avoiding 
       low-order pitfalls, see http://members.cox.net/srice1/random/crandom.html 
    */ 
   inline const int myRand(const int a, const int b) { 
      const int m = b - a;  //now generate random in 0...m-1 
      const int y = int((double(rand())/(double(RAND_MAX) + 1.0)) * m); 
      return y + a; 
   } 
 
   /** Randomly shuffle indices a .. b-1 of the array arr 
       Based on http://www.algoblog.com/2007/06/04/permutation/ via myRand 
       Preferred to STL's "shuffle" to make reproducibility more transparent; 
    */ 
   template<class E> 
   inline void randShuffle(vector<E>* arr, const int a, const int b) { 
      for (int i = a + 1; i < b; i++) { 
         int j = myRand(a, i+1);  //random index in a .. i 
         E temp = arr->at(i); 
         arr->at(i) = arr->at(j); 
         arr->at(j) = temp; 
      } 
   } 
    

//-----------------------Vector utilities---------------------------

   /** Return argv[left .. right], REQ left <= right <= argv.size().
    */
   inline double fracsum(const vector<double>& argv, double left, double right) {
      size_t li = size_t(left);
      size_t ri = size_t(right);
      if (li == ri) {   //arguments within same cell
         return argv[li]*(right - left);
      } //else
      double lfp = 1.0 - (left - li);
      double rfp = right - ri;
      double sum = lfp*argv[li];
      //The "gotcha": adding rfp*argv[ri] might blow when right == argv.size()
      if (right < argv.size()) {   //note: compares double to size_t/int
         sum += rfp*argv[ri];
      }
      for (size_t i = li+1; i < ri; i++) {  //INV: li < i < ri
         sum += argv[i];
      }
      return sum;
   }


   inline vector<double> redist(const vector<double>& argv, size_t newSize) {
      double r = double(newSize)/argv.size();
      vector<double> result(newSize);
      for (size_t i = 0; i < newSize; i++) {
         result[i] = fracsum(argv,r*i,r*i + r);
      }
      return result;
   }

   inline void normalize(vector<double>& argv) {
      double sum = 0.0;
      for (size_t i = 0; i < argv.size(); i++) { sum += argv[i]; }
      for (size_t j = 0; j < argv.size(); j++) { argv[j] /= sum; }
   }

   inline void normalizeP(vector<double>* argv) {
      double sum = 0.0;
      for (size_t i = 0; i < argv->size(); i++) { sum += argv->at(i); }
      for (size_t j = 0; j < argv->size(); j++) { argv->at(j) /= sum; }
   }




   /** Inverts positive values in a vector, capping inverses at MAXINV to 
       ensure numerical stability of routines using these values as powers. 
    */ 
   inline vector<double> anvert(vector<double> args, const double a = 0.0) { 
      for (int i = 0; i < args.size(); i++) { 
         args[i] = args[i] > 1.0/MAXINV ? (a + 1.0 + a*args[i])/args[i] : MAXINV ; 
      } 
      return args; 
   } 
    
   /** Sum over i of x^{powers[i]}.  Not used outside this namespace 
    */ 
   inline double powSum(const double x, const vector<double>& powers) { 
      double sum = 0.0; 
      for (int i = 0; i < powers.size(); i++) { 
         sum += pow(x,powers[i]); 
      } 
      return sum; 
   } 
    
   inline double derive(const double x, const vector<double>& powers) { 
      double sum = 0.0; 
      for (int i = 0; i < powers.size(); i++) { 
         double summand = powers[i]*pow(x, powers[i] - 1); 
    
   // if (isnan(summand)) { 
   //    cerr << "Trouble x = " << x << ", powers[" << i << "] = " << powers[i] 
   //         << endl; 
   // } 
         sum += summand; 
      } 
      return sum; 
   } 
    
   static int superMaxNewtons = 0;  //over entire session 
   static int maxNewtons = 0;       //over one fit run 
   static int superNumNewtons = 0; 
   static int numNewtons = 0; 
   static int superNumVRCalls = 0;  //over session 
   static int numVRCalls = 0;       //over fit run 
   static double maxRoot = 0.0;     //how close to 1 does the root come? 

   static int DIcount = 0;
   static int numResets = 0;
    
    
   /** Given g > 0 and e_1,...,e_n, find x s.t. x^{e_1} + ... + x^{e_n} = g, 
       to precision prec.  When n=1, b = g^{1/e_1}, hence name "vector root". 
       PRE: 0 < g < n, so that 0 < x < 1, and e_1,...,e_n > 1, so that the 
       second derivative is always positive, making the function f concave. 
       This makes Newton's method particularly easy: All values are > g, so 
       subtracting "prec" from the next point p makes "f(p-prec) <= g" a 
       natural and efficient stopping condition that still achieves precision 
       prec, speeds convergence, & lessens high-derivative trouble near p = 1. 
       Caller guards against numerical extremes. 
    */ 
   inline double vectorRoot(const vector<double>& powers, const double goalVal, 
                            const double prec = VRPREC) { 
      numVRCalls++; superNumVRCalls++; 
      int count = 1; 
      double arg = IRutil::P0TOLERANCE; //max OK value for root, <= 1 - prec. 
      double val, deriv; 
      while ((val = powSum(arg, powers)) > goalVal) { 
         count++; 
         deriv = derive(arg, powers); 
         arg = arg - (val - goalVal)/deriv - prec; 
      } 
      numNewtons += count; superNumNewtons += count; 
      maxNewtons = max(maxNewtons,count); 
      superMaxNewtons = max(superMaxNewtons,count); 
      maxRoot = max(maxRoot,arg); 
      return arg; 
   } 
    
   /** Binary-search version, for comparison 
    */ 
   inline double vectorRootBS(const vector<double>& powers,  
                              const double goalVal, 
                              const double prec = VRPREC) { 
      double hi = IRutil::P0TOLERANCE; 
      double lo = 0.0; 
      double mid; 
      while (hi - lo > prec) { 
         mid = (hi + lo)/2.0; 
         (powSum(mid,powers) < goalVal ? lo : hi) = mid;  //yes, that's cutesy 
      } 
      return (hi + lo)/2.0; 
   } 


    
    
    
   // Alternate way of computing vectorRoot.  Not used because its 
   // numerical instability is even worse...
    
   inline double powSum2(const vector<double>& bases, const double b) { 
      double sum = 0.0; 
      for (int i = 0; i < bases.size(); i++) { 
         sum += pow(bases[i], b); 
      } 
      return sum; 
   } 
    
    
   /** Given g > 0 and e_1,...,e_n, find b such that e_1^b + ... + e_n^b = g, 
       provided lo <= b <= hi, to precision 1/2^d.  When n=1,  
       b = (ln g)/(ln e) = log_e(g), so we can call this the  
       "vector log" b = log_(e_1,...,e_n)(g).  Alg. uses binary search. 
    */ 
   inline double vectorLog(const vector<double>& bases, 
                           const double g, const double prec = VRPREC) { 
      double lo = 0.0, hi = 1.0; 
      while (powSum2(bases,hi) < g) { 
         lo = hi; 
         hi *= 2; 
      } 
      double mid = (lo + hi)/2.0; 
      while (mid - lo > prec) { 
         if (powSum2(bases,mid) > g) { 
            hi = mid; mid = (lo + hi)/2.0; 
         } else { 
            lo = mid; mid = (lo + hi)/2.0; 
         } 
      } 
      return mid; 
   } 
 
   inline int factorial(int x) { 
      return (x <= 1) ? 1 : x * factorial(x - 1); 
   } 

   inline double vectorRoot2(const vector<double>& powers, 
                             const double g, const double prec = VRPREC) { 
      vector<double> bases(powers.size()); 
      for (int i = 0; i < bases.size(); i++) { 
         bases[i] = exp(powers[i]); 
      } 
      return exp(vectorLog(bases,g,prec)); 
   } 

   /** Generate Poisson dist. over integers 0..numWeights-1 with Lambda = dpeak 
       If dpeak == 0.0 then return vector with 1 at last position, 0 elsewhere. 
       When 
    */ 
   //vector<double> poissonWeights (double dpeak, size_t numWeights)  { 
   inline void genPoissonWeights(const double& lambda, const size_t& numWeights,
                                 vector<double>& depthWts) {
      //vector<double> depthWts(numWeights); 

      if (lambda == 0.0) { 
         depthWts.at(0) = 1.0; 
         for (size_t k = 1; k < numWeights; k++) { depthWts.at(k) = 0.0; } 
         return; // depthWts; 
      } //else 
      double cume = 0.0; 
      double pval = exp(-lambda);
      depthWts.at(0) = cume = pval;
      for(size_t i = 1; i < numWeights; i++) { 
         pval = pval*lambda/i;
         //pval = pow(lambda,double(i))*exp(-lambda)/IRutil::factorial(i); 
         cume += pval; 
         depthWts.at(i) = pval; 
      } 
      //Lump remaining Poisson distribution onto highest depth 
      size_t j = numWeights; 
      while (cume < 1.0 - IRutil::SUMPROBSTOLERANCE && j <= IRutil::NCUTOFF) { 
         //pval = pow (lambda,double(j))*exp(-lambda)/IRutil::factorial(j); 
         pval = pval*lambda/j;
         cume += pval; 
         depthWts.at(numWeights - 1) += pval; 
         j++; 
      } 
      if (j == IRutil::NCUTOFF+1) { cerr << "Normalization failure\n"; } 
/*
cerr << "Poisson weights: ";
for (int i = 0; i < depthWts.size(); i++) {
   cerr << i << "-" << IRutil::ftoa(depthWts.at(i), 4) << " ";
}
cerr << endl;
*/
   } 

   /** Modified Poisson distribution with coefficient of variation ~= v.
       v = 0 means all weight on peak; large v means completely flat;
       v = 1 gives ordinary Poisson distribution.  REQ: dpeak < last
       NOT USED---replaced by a simple dilation by v.
    */
/*
   vector<double> poissonWeights(double dpeak, size_t numWeights, double v) {
      if (v > 1.0/IRutil::CVTOLERANCE) {   //return twin peaks near dpeak
         vector<double> depthWts(numWeights, 0.0);
         size_t b = size_t(dpeak);
         if (b >= numWeights) {
            depthWts.at(numWeights-1) = 1.0;
         } else {
            depthWts.at(b-1) = dpeak - double(b);
            depthWts.at(b) = 1.0 - depthWts.at(b-1);
         }
         return depthWts;
      } else if (v > double(numWeights - 1)) {
          vector<double> depthWts(numWeights, 1/double(numWeights));
          return depthWts;
      }
      //else
      //size_t vd = size_t(dpeak/v + 0.5);
      //double ratio = vd/double(last);

      size_t expandTo = size_t(numWeights/v + 0.5);
      vector<double> vr = poissonWeights(dpeak/v, expandTo);
      return redist(vr, numWeights);
   }
*/
 
 
//-----------A useful pair structure for probability endpoints---------------- 
 
   struct Endpt { 
      double val; 
      double partner;   //INV: val != partner 
      double weight; 
      Endpt(double v, double p, double w) : val(v), partner(p), weight(w) { } 
      bool isP() const { return val < partner; } 
   }; 
   inline bool endPtLT(const Endpt& a, const Endpt& b)  {   // comparison function 
      return a.val < b.val; 
   } 
 
 
 
};                          //end of IRutil namespace 
 
#endif                      //end of #ifndef __IR_UTIL_H__ 
 
 
 
//File----------------------IRfunctions.h---------------------------------- 
 
#ifndef __IR_FUNCTIONS_H__ 
#define __IR_FUNCTIONS_H__ 
 
namespace IRfun {          
 
//---------------CURVES AND OTHER FUNCTIONS TO PASS----------------------- 
 
 
   //typedef  
   typedef double (*Curve1) (const double);
   typedef double (*Curve2) (const double, const double);
   typedef double (*Curve3) (const double, const double, const double); 
                           //arg order delta,s,c ,d
   typedef double (*WeightMethod)(const vector<double>&, 
                                  const vector<double>* const); 
   typedef double (*Dist)(const double, const double); 
    
   enum CURVES { 
      INVEXP,  
      INVPOLYA,  
      INVPOLYB,  
      FOLDEDERF,
      FOLDEDLOGISTIC,
      SECHA,  
      SECHB,  
      SECHC, 
      SECHD, 
      INVLOGA,  
      INVLOGB,  
      INVLOGC, 
      INVEXPLIN,
      POWPOW,
      INV2EXPA,  
      INV2EXPB,  
      STUDENTT, 
      IRT, 
      // INV2EXPC,  
      NUM_CURVES 
   }; 
    
   //Curves 
   inline double invExp(const double z) { return exp(-z); }
   inline double invExp(const double y, const double c) {
      return exp(-pow(y,c));
   }
   inline double invExp(const double x, const double s, const double c) { 
      return exp(-pow(x/s, c)); 
   } 
 
   inline double invExpLin(const double z) { return exp(-z)/(1.0 + z); }
   inline double invExpLin(const double y, const double c) {
      const double w = pow(y,c);
      return exp(-w)/(1.0 + w);
   }
   inline double invExpLin(const double x, const double s, const double c) { 
      const double w = pow(x/s, c); 
      //return exp(-w)/(1.0 + x/(10.0*s)); 
      return exp(-w)/(1.0 + w);
   } 
 
   inline double powpow(const double z) { return 1.0/pow(z,z); }
   inline double powpow(const double y, const double c) {
      const double w = pow(y,c);
      return 1.0/pow(w,w);
   }
   inline double powpow(const double x, const double s, const double c) { 
      const double w = pow(x/s, c); 
      return 1.0/pow(x/s, c*w); 
   } 
    
   inline double invPolyA(const double z) { return 1.0/(1.0 + z); }
   inline double invPolyA(const double y, const double c) {
      return 1.0/(1.0 + pow(y,c));
   }
   inline double invPolyA(const double x, const double s, const double c) { 
      return 1.0/(1.0 + pow(x/s,c)); 
   } 
 
   inline double invPolyB(const double z) { return 1.0/(1.0 + z); }  //yes == invPolyA
   inline double invPolyB(const double y, const double c) {
      return 1.0/pow(1.0 + y, c);
   }
   inline double invPolyB(const double x, const double s, const double c) { 
      return 1.0/pow(1.0 + (x/s),c); 
   } 

   inline double ferf(const double z) { return 1.0 + erf(-z); }
   inline double ferf(const double y, const double c) {
      return 1.0 + erf(-pow(y,c));
   }
   inline double ferf(const double x, const double s, const double c) {
      return 1.0 + erf(-pow(x/s,c));
   }

   inline double flogistic(const double z) {
      return 2.0/(1.0 + exp(z));
   }
   inline double flogistic(const double y, const double c) {
      return 2.0/(1.0 + exp(pow(y,c)));
   }
   inline double flogistic(const double x, const double s, const double c) {
      return 2.0/(1.0 + exp(pow(x/s,c)));
   }

    
   inline double sechA(const double z) {
      const double u = exp(z);
      return 2.0/(u + 1.0/u);
   }
   inline double sechA(const double y, const double c) {
      const double u = exp(pow(y,c));
      return 2.0/(u + 1.0/u);
   }
   inline double sechA(const double x, const double s, const double c) { 
      const double u = exp(pow(x/s,c)); 
      return 2.0/(u + 1.0/u); 
   } 

   inline double sechB(const double z) { return sechA(z); }
   inline double sechB(const double y, const double c) {
      const double v = exp(y);
      return pow(2.0/(v + 1.0/v), c);
   }
   inline double sechB(const double x, const double s, const double c) { 
      const double v = exp(x/s); 
      return pow(2.0/(v + 1.0/v), c); 
   } 
   
   inline double sechC(const double z) { return z*sechA(z); }
   inline double sechC(const double y, const double c) {
      const double z = exp(-y);
      return z * pow(2.0/(1.0 + z), c);
   }
   inline double sechC(const double x, const double s, const double c) { 
      const double z = exp(-x/s); 
      return z * pow(2.0/(1.0 + z), c); 
   } 

   //Equivalent to Hubbert curve
   inline double sechD(const double z) { return 4.0 / (z + 2.0 + 1.0/z); }
   inline double sechD(const double y, const double c) {
      const double z = exp(pow(y,c));
      return 4.0 / (z + 2.0 + 1.0/z);
   }
   inline double sechD(const double x, const double s, const double c) { 
      const double z = exp(pow(x/s,c)); 
      return 4.0 / (z + 2.0 + 1.0/z); 
   } 

    
   inline double invLogA(const double z) { return 1.0/(1.0 + log(1.0 + z)); }
   inline double invLogA(const double y, const double c) {
      return 1.0/(1.0 + log(1.0 + pow(y,c)));
   }
   inline double invLogA(const double x, const double s, const double c) { 
      return 1.0/(1.0 + log(1.0 + pow(x/s,c))); 
   } 

   inline double invLogB(const double z) { return invLogA(z); }
   inline double invLogB(const double y, const double c) {
      return 1.0/(1.0 + pow(log(1.0 + y),c));
   }
   inline double invLogB(const double x, const double s, const double c) { 
      return 1.0/(1.0 + pow(log(1.0 + x/s),c)); 
   } 

   inline double invLogC(const double z) { return invLogA(z); }
   inline double invLogC(const double y, const double c) {
      return 1.0/pow(1.0 + log(1.0 + y), c);
   }
   inline double invLogC(const double x, const double s, const double c) { 
      return 1.0/pow(1.0 + log(1.0 + x/s), c); 
   } 
    
   inline double inv2ExpA(const double z) { return 1.0/exp(exp(z) - 1.0); }
   inline double inv2ExpA(const double y, const double c) {
      return 1.0/exp(exp(pow(y, c)) - 1.0);
   }
   inline double inv2ExpA(const double x, const double s, const double c) { 
      return 1.0/exp(exp(pow(x/s, c)) - 1.0); 
   } 

   inline double inv2ExpB(const double z) { return inv2ExpA(z); }
   inline double inv2ExpB(const double y, const double c) {
      return 1.0/exp(pow(exp(y) - 1.0, c));
   }
   inline double inv2ExpB(const double x, const double s, const double c) { 
      return 1.0/exp(pow(exp(x/s) - 1.0, c)); 
   } 

   inline double studentT(const double z) { return (1.0 + z)*exp(-z); }
   inline double studentT(const double y, const double c) {
      return c/pow(c + y*y, (c+1)/2);
   }
   inline double studentT(const double x, const double s, const double c) { 
      return c/pow(c + (x/s)*(x/s), (c+1)/2); 
   } 

   inline double slideIEIPA(const double z) { return (15.0/16.0)*invExp(z) + (1.0/16.0)*invPolyA(z); }
   inline double slideIEIPA(const double y, const double c) { 
      return (15.0/16.0)*invExp(y,c) + (1.0/16.0)*invPolyA(y,c);
    }
   inline double slideIEIPA(const double x, const double s, const double c) { 
      return (15.0/16.0)*invExp(x,s,c) + (1.0/16.0)*invPolyA(x,s,c); 
   } 

   inline double irt(const double z) { return 1.0 - 1.0/(1.0 + exp(-z)); }
   inline double irt(const double y, const double c) {
      return 1.0 - 1.0/(1.0 + exp(-pow(y,c)));
   }
   inline double irt(const double x, const double s, const double c) { 
      return (exp(c*s)/exp(c*(x + s))); 
   } 

   // double inv2ExpC(const double x, const double s, const double c) {
   //    return 1.0/pow(exp(exp(x/s) - 1), c);
   // }

   //Curves commented out cause a "race" between s and c when fitting,
   //with both increasing seemingly unboundedly without fitting well.

       
   inline double evalCurve1(CURVES curve, double z) {
      switch(curve) {
       case INVEXP:
         return invExp(z);
       case INVPOLYA:
         return invPolyA(z);
       case INVPOLYB:
         return invPolyB(z);
       case FOLDEDERF:
         return ferf(z);
       case FOLDEDLOGISTIC:
         return flogistic(z);
       case SECHA:
         return sechA(z);
       case SECHB:
         return sechB(z);
       case SECHC:
         return sechC(z);
       case SECHD:
         return sechD(z);
       case INVLOGA:
         return invLogA(z);
       case INVLOGB:
         return invLogB(z);
       case INVLOGC:
         return invLogC(z);
       case INVEXPLIN:
         return invExpLin(z);
       case POWPOW:
         return powpow(z);
       case INV2EXPA:
         return inv2ExpA(z);
       case INV2EXPB:
         return inv2ExpB(z);
       case STUDENTT:
         return studentT(z);
       case IRT:
         return irt(z);
       default: 
         cerr << "Unknown curve; using InvExp." << endl;
         return invExp(z);
      }
      cerr << "Unknown curve; using InvExp." << endl;
      return invExp(z);
   }
 
   inline double evalCurve2(CURVES curve, double y, double c) {
      switch(curve) {
       case INVEXP:
         return invExp(y,c);
       case INVPOLYA:
         return invPolyA(y,c);
       case INVPOLYB:
         return invPolyB(y,c);
       case FOLDEDERF:
         return ferf(y,c);
       case FOLDEDLOGISTIC:
         return flogistic(y,c);
       case SECHA:
         return sechA(y,c);
       case SECHB:
         return sechB(y,c);
       case SECHC:
         return sechC(y,c);
       case SECHD:
         return sechD(y,c);
       case INVLOGA:
         return invLogA(y,c);
       case INVLOGB:
         return invLogB(y,c);
       case INVLOGC:
         return invLogC(y,c);
       case INVEXPLIN:
         return invExpLin(y,c);
       case POWPOW:
         return powpow(y,c);
       case INV2EXPA:
         return inv2ExpA(y,c);
       case INV2EXPB:
         return inv2ExpB(y,c);
       case STUDENTT:
         return studentT(y,c);
       case IRT:
         return irt(y,c);
       default:
         cerr << "Unknown curve; using InvExp." << endl;
         return invExp(y,c);
      }
      cerr << "Unknown curve; using InvExp." << endl;
      return invExp(y,c);
   }

   inline double evalCurve3(CURVES curve, double x, double s, double c) {
      switch(curve) {
       case INVEXP:
         return invExp(x,s,c);
       case INVPOLYA:
         return invPolyA(x,s,c);
       case INVPOLYB:
         return invPolyB(x,s,c);
       case FOLDEDERF:
         return ferf(x,s,c);
       case FOLDEDLOGISTIC:
         return flogistic(x,s,c);
       case SECHA:
         return sechA(x,s,c);
       case SECHB:
         return sechB(x,s,c);
       case SECHC:
         return sechC(x,s,c);
       case SECHD:
         return sechD(x,s,c);
       case INVLOGA:
         return invLogA(x,s,c);
       case INVLOGB:
         return invLogB(x,s,c);
       case INVLOGC:
         return invLogC(x,s,c);
       case INVEXPLIN:
         return invExpLin(x,s,c);
       case POWPOW:
         return powpow(x,s,c);
       case INV2EXPA:
         return inv2ExpA(x,s,c);
       case INV2EXPB:
         return inv2ExpB(x,s,c);
       case STUDENTT:
         return studentT(x,s,c);
       case IRT:
         return irt(x,s,c);
       default:
         cerr << "Unknown curve; using InvExp." << endl;
         return invExp(x,s,c);
      }
      cerr << "Unknown curve; using InvExp." << endl;
      return invExp(x,s,c);
   }

    
   //Weights 
    
   enum WEIGHTS { 
      UNITWTS, SUMWTS, LOGSUMWTS, ENTROPYWTS, FALLOFFWTS, INVVARP, NUM_WEIGHTS  
   }; 
 
   //Functionsnot inlined since passed as function pointers. 
    
   inline double unitWeights(const vector<double>& probs, 
                             const vector<double>* const unused = NULL) { 
      return 1.0; 
   } 
    
   /** Named because in the "shares" model, 1/p0 is the sum of the shares. 
       Downweights "obvious" move choices. 
    */ 
   inline double sumWeights(const vector<double>& probs, 
                            const vector<double>* const unused = NULL) { 
      return 1.0/probs.at(0); 
   } 
    
   /** Strongly downweights "obvious" move choices. 
    */ 
   inline double logSumWeights(const vector<double>& probs, 
                               const vector<double>* const unused = NULL) { 
      return log(1.0/probs.at(0)); 
   } 
 
   /** Downweights "obvious" move choices. 
    */ 
   inline double entropyWeights(const vector<double>& probs, 
                                const vector<double>* const unused = NULL) { 
      double ent = 0.0; 
      for (vector<double>::const_iterator itr = probs.begin(); 
           itr != probs.end(); ++itr) { 
         ent += (*itr)*log(1.0/(*itr)); 
      } 
      return ent; 
   } 
 
   /** Expected error from a move, given projected probabilities 
    */ 
   inline double falloffWeights(const vector<double>& probs, 
                                const vector<double>* const pScaledDeltas) { 
      double ff = 0.0; 
      vector<double>::const_iterator itr = probs.begin(); 
      vector<double>::const_iterator itr2 = pScaledDeltas->begin(); 
      while (itr != probs.end() && itr2 != pScaledDeltas->end()) { 
         ff += (*itr)*(*itr2); 
         ++itr;  ++itr2; 
      } 
      return ff; 
   } 
 
    
   /** "Inverse-variance" weight on p0 may combat bias in estimating p0 (and 
       hence in predicting first-line matches), but it strongly *upweights* 
       the more-obvious move choices.  Since this is an assignable function 
       pointer, cannot push guard against P0TOLERANCE onto caller (!?). 
       Also needs a cap in cases of clear-choice moves, else an automatic 
       recapture would be weighted thousands more than a normal move choice. 
    */ 
   inline double invVarP0(const vector<double>& probs, 
                          const vector<double>* const unused = NULL) { 
      double p0 = min(probs.at(0), IRutil::P0TOLERANCE); 
      return min(IRutil::INVVARP0CAP, 1.0/(p0*(1.0 - p0))); 
   } 
    
    
   static map<CURVES,string> curveNames;     //could make static
   static map<WEIGHTS,string> weightNames; 
   static map<CURVES,string> curveDescriptions; 
   static map<WEIGHTS,string> weightDescriptions; 
    
   inline void initNames() { 
      curveNames[INVEXP] = "InvExp"; 
      curveNames[INVPOLYA] = "InvPolyA"; 
      curveNames[INVPOLYB] = "InvPolyB"; 
      curveNames[FOLDEDERF] = "FoldedERF";
      curveNames[FOLDEDLOGISTIC] = "FoldedLogistic";
      curveNames[SECHA] = "SechA"; 
      curveNames[SECHB] = "SechB"; 
      curveNames[SECHC] = "SechC"; 
      curveNames[SECHD] = "SechD/Hubbert"; 
      curveNames[INVLOGA] = "InvLogA"; 
      curveNames[INVLOGB] = "InvLogB"; 
      curveNames[INVLOGC] = "InvLogC"; 
      curveNames[INVEXPLIN] = "InvExpLin";
      curveNames[POWPOW] = "PowPow";
      curveNames[INV2EXPA] = "Inv2ExpA"; 
      curveNames[INV2EXPB] = "Inv2ExpB"; 
      curveNames[STUDENTT] = "StudentT"; 
      curveNames[IRT] = "IRT"; 
      // curveNames[INV2EXPC] = "Inv2ExpC";   //causes s-c "race". 
      weightNames[UNITWTS] = "Unit"; 
      weightNames[SUMWTS] = "Sum"; 
      weightNames[LOGSUMWTS] = "Logsum"; 
      weightNames[ENTROPYWTS] = "Entropy"; 
      weightNames[FALLOFFWTS] = "Falloff"; 
      weightNames[INVVARP] = "InvVarP"; 
   curveDescriptions[INVEXP] =   "1/e^{x^c}"; 
   curveDescriptions[INVPOLYA] = "1/(1 + x^c)           (approximates InvExp)"; 
 curveDescriptions[INVPOLYB] = "1/(1 + x)^c           (\"\",~ Fisk for c = 2)"; 
 //outdented since escaped quotes 
   curveDescriptions[FOLDEDERF]="Folded Gaussian error fn";
   curveDescriptions[FOLDEDLOGISTIC]="Folded logistic curve x2";
   curveDescriptions[SECHA] =    "Sech(x^c)               (~ logistic in x^c)"; 
   curveDescriptions[SECHB] =    "Sech(x)^c               ('c-logistic' in x)"; 
   curveDescriptions[SECHC] =    "2^c e^-x/(1+e^-x)^c    (logistic for c = 2)"; 
   curveDescriptions[SECHD] =    "4e^{-x^c}/(1+e^{-x^c})^2  (logistic in x^c)"; 
   curveDescriptions[INVLOGA] =  "1/(1 + ln(1 + x^c))      (approx. InvPolyA)"; 
   curveDescriptions[INVLOGB] =  "1/(1 + ln^c(1 + x))      (approx. InvPolyA)"; 
   curveDescriptions[INVLOGC] =  "1/(1 + ln(1 + x))^c      (approx. InvPolyB)"; 
   curveDescriptions[INVEXPLIN] = "1/e^{x^c}(1+x^c)";
   curveDescriptions[POWPOW] = "(x^c)^(x^c)";
   curveDescriptions[INV2EXPA] = "1/e^{e^{x^c} - 1}"; 
   curveDescriptions[INV2EXPB] = "1/e^{e^x - 1}^c"; 
   curveDescriptions[STUDENTT] = "Student's T with c degrees of freedom"; 
   curveDescriptions[IRT]="e^{cs}/e^{c(delta + s)}"; 
 
   // curveDescriptions[INV2EXPC] = "1/(e^{e^x - 1})^c"; 
   weightDescriptions[UNITWTS] = "all moves treated equally"; 
   weightDescriptions[SUMWTS] = "1/p0,      upweights moves with many choices"; 
   weightDescriptions[LOGSUMWTS] = "log(1/p0), downweights clear-choice moves"; 
   weightDescriptions[ENTROPYWTS] = "sum(p*log(1/p)), downweights clear moves"; 
   weightDescriptions[FALLOFFWTS] = "sum(p(i)*delta(i)), expected falloff"; 
   weightDescriptions[INVVARP] = "1/p0(1-p0), upweights clear-choice moves"; 
   } 
    
   // Dist functions for fitting
   inline double leastSquares(const double a, const double b) { 
      return (a-b)*(a-b); 
   } 
 
   inline double L1(const double a, const double b) { 
      return fabs(a - b); 
   } 
 
   inline double L1a(const double a, const double b) { 
      return (a - b); 
   } 
 
 
   inline double l3(const double a, const double b) { 
      const double c = fabs(a-b); 
      return c*c*c; 
   } 
 
    
   /** Distortion Fix for 167 '05--'07 games, file MasterTurns.txt. 
       Obtained by linear regression (on log scale) from these games. 
       Returns the estimated probability of a 2750-ish player choosing a move 
       that is not among the first 10 lines as judged by Toga II 1.2.1a to 
       depth 15.  As a probability value not a curve value, it applies 
       equally to both the Shares and PowerShares models.  It is used both 
       for turns in which a non-top-10 move was played, and those not. 
       Used only for predictions, not "actual" stats. 
    */ 
   //inline double distortionFix(double deltaTen) { 
   //   double tmp = 5.822*exp(2.89*deltaTen); 
   //   return 1/tmp; 
   //   //return 0;   //was used to de-bug 
   //} 
    
   /** Regressed falloff from cases of played move not in top 10, from 
       MasterTurns.txt.  Used only for prediction and to estimate the 
       mean delta of "Move 11" over all tuples, not just the cases where 
       a non-top-10 move was played.  *And* used for "actual" falloff in 
       only a rare case: when a non-top-10 move is the last move in a game. 
    */ 
   //inline double falloffFix(double deltaTen) { 
   //   return 1.1111*deltaTen + 0.0213; 
   //   //return 1.1115*deltaTen + 0.0382;  //if we kill some goofy outliers 
   //} 
 
 
 
//---------------------------The Big Enchilada!----------------------- 
 

//!!! To be changed.

   inline double ipr(const double ae, const WEIGHTS wmc) { 
      switch(wmc) { 
		  //The current numbers are obtained by linear regression on 2006 to 2009 training data using unit weight and 58-42 split. 
       case UNITWTS: //return (3571.0 - ae*15413.0); 
         return 3474.87 - 13985.7436*ae;
       case SUMWTS:
         return 3603.714 - 16544*ae;
       case LOGSUMWTS:
         return 3646.013  - 17042.486*ae;
       case ENTROPYWTS: //return (3718.7039 - 17120.088*ae);
         return 3605.461 - 15591.517*ae;
       case FALLOFFWTS:
         return 3414 - 11514.1896*ae;
       case INVVARP:
         return 3343.486 - 18739.179*ae;
       default:
         return 3505.917 - 14576.932*ae;
      }
   }

   inline double iprew(const double ae) {
      return 3805.478 - 18210.259*ae;
   }


   inline double iprewall(const double ae) {
      return 3800.8633 - 18137.617*ae;
   }

   inline double ipr2(const double ae) {
      return (3528.0 - ae*14470.7);
   }

   inline double ipr3(const double ae) {
      return (3514.44 - ae*14298.0);
   }

   inline double sOfElo(double elo) {  // Per Aug. 2014 calibration
      return 0.143 - 0.00009*(elo - 2000);
   }

   inline double cOfElo(double elo) {
      return 0.466 + 0.000075*(elo - 2000);
   }

   inline double dOfElo(double elo) {
      return 20;
   }

   inline double vOfElo(double elo) {
      return 0.0;
   }

   inline double aOfElo(double elo) {
      return 0.0;
   }

   inline double hmOfElo(double elo) {
      return 0.0;
   }

   inline double hpOfElo(double elo) {
      return 0.0;
   }

   inline double bOfElo(double elo) {
      return 0.0;
   }


/*
         return 3505.917 - 14576.932*ae; 
       case SUMWTS: 
         return 3603.714 - 16544*ae; 
       case LOGSUMWTS: 
         return 3646.013  - 17042.486*ae; 
       case ENTROPYWTS: //return (3718.7039 - 17120.088*ae); 
         return 3605.461 - 15591.517*ae; 
       case FALLOFFWTS: 
         return 3414 - 11514.1896*ae; 
       case INVVARP: 
         return 3343.486 - 18739.179*ae; 
       default:  
         return 3505.917 - 14576.932*ae; 
      } 
   } 
*/
 
    
};                          //end of IRfun namespace again 
 
#endif                      //end of #ifndef __IR_FUNCTIONS_H__ 
 
 
//File--------------------Position.h---------------------------------------

#ifndef __IR_POSITION_H__
#define __IR_POSITION_H__

#include <vector>
#include <set>
#include <map>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <cmath>



/** "Total Algebraic Notation" (TAN) gives all the information needed
 *  to translate a move into any format (SAN or LAN or UCI) without
 *  needing to refer to the board in order to disambiguate.  Format:
 *
 *     <piece><origin square>[- or x]<dest. square>[optional suffix]
 *
 *  Even for a Pawn move, the piece ('P' for White, 'p' for Black) is
 *  included.  The squares are in algebraic format [a-h][1-8].  Suffixes:
 *
 *  c for castling, e.g. Ke1-g1c for O-O by White.
 *  e for an en-passant capture.
 *  QRBNqrbn for promotion by White or Black
 *  i if the SAN translation needs to give the row (rank), e.g. N5d4
 *  j if SAN needs to give the file, e.g. Nbd7
 *  k if SAN needs to give both.
 *
 *  The advantage is that all information about a move is present and
 *  appears at a fixed place in the string.
 *
 */


const string promStr = "qrbnQRBN";
inline bool isProm(char c) { return promStr.find(c) != string::npos; }

class Move {
   string tanMove;
 public:
   Move(): tanMove(string("")) { }
   Move(const Move& mv): tanMove(mv.tanMove) { }
   explicit Move(const string& smv): tanMove(smv) { }
   Move& operator=(const Move& rhs) {
      tanMove = rhs.tanMove;
      return(*this);
   }
   string getTAN() const { return tanMove; }
   void setTAN(const string& tmv) { tanMove = tmv; }
   //Move(const string& fen, const string& move): tanMove(Position(fen).move2TAN(move))
   //{ }
   string TAN2UCI() const {  //allows "King Takes Rook" style castling
      if (tanMove.length() < 6 || tanMove.length() > 7) {
         cerr << "Bad TAN2UCI " << tanMove << endl; return tanMove; 
      }
      string suff = tanMove.substr(6);
      string prom = ((suff != "" && isProm(suff.at(0))) ? 
            string("")+IRutil::makeLower(suff.at(0)) : "");
      return (tanMove.substr(1,2) + tanMove.substr(4,2) + prom);
   }
   
   string TAN2LAN() const {
      if (tanMove.length() < 6 || tanMove.length() > 7) {
         cerr << "Bad TAN2LAN " << tanMove << endl; return tanMove; 
      }
      string suff = tanMove.substr(6);
      if (suff == "c") {
         return ((IRutil::ord(tanMove.at(1)) < IRutil::ord(tanMove.at(4))) ? "O-O" : "O-O-O");
      }
      string prom = ((suff != "" && isProm(suff.at(0))) ? 
                                          string("")+IRutil::makeUpper(suff.at(0)) : "");
      char piece = (IRutil::ord(tanMove.at(0) < IRutil::ord('a') ? 
                          tanMove.at(0) : IRutil::chr(IRutil::ord(tanMove.at(0)) - 32)));
      string lanPiece = (piece == 'P' ? "" : string("") + piece);
      return (lanPiece + tanMove.substr(1,5) + prom);
   }
   
   string TAN2SAN() const {
      if (tanMove.length() < 6 || tanMove.length() > 7) {
         cerr << "Bad TAN2SAN " << tanMove << endl; return tanMove; 
      }
      string suff = tanMove.substr(6);
      if (suff == "c") {
         return ((IRutil::ord(tanMove[1]) < IRutil::ord(tanMove[4])) ? "O-O" : "O-O-O");
      }
      string prom = ((suff != "" && isProm(suff.at(0))) ? 
            string("")+IRutil::makeUpper(suff.at(0)) : "");
      char piece = (IRutil::ord(tanMove.at(0) < IRutil::ord('a') ? tanMove.at(0) 
            : IRutil::chr(IRutil::ord(tanMove.at(0)) - 32)));
      string disambig = (suff == "" ? "" 
                           : (suff == "j" ? tanMove.substr(1,1)
                                : (suff == "i" ? tanMove.substr(2,1)
                                     : (suff == "k" ? tanMove.substr(1,2) : ""))));
      string bridge = (tanMove[3] == 'x' ? "x" : "");
      string sanPiece = (piece == 'P' ? (bridge == "x" ? ""+tanMove.at(1) : "") : string("") + piece);
      
      return (sanPiece + disambig + bridge + tanMove.substr(4,2) + prom);
   }

   operator string() const { return tanMove; }

   bool operator==(const Move& rhs) const { return tanMove == rhs.tanMove; }
   bool operator<(const Move& rhs) const { return tanMove < rhs.tanMove; }
};

inline ostream& operator<<(ostream& OUT, const Move& rhs) {
   OUT << rhs.getTAN();
   return OUT;
}
   


enum PIECES {
   EM, WK, WQ, WR, WB, WN, WP, BK, BQ, BR, BB, BN, BP
};

const string pieceOf = " KQRBNPkqrbnp";

struct MoveParse {
 public:
   char piece;
   string sourceInfo;
   string dest;  //always known in full
   bool capture;
   string prom;
   MoveParse(char p, const string& si, const string& d, bool cap, const string& suff)
    : piece(p), sourceInfo(si), dest(d), capture(cap), prom(suff)
   { }
   MoveParse() : piece(' '), sourceInfo(""), dest(""), capture(false), prom("") { }
   string toString() const { 
      string bridge = (capture ? "x" : "-");
      return string("") + piece + sourceInfo + bridge + dest + prom;
   }
};

   
/** Partial implementation of a chess position---only enough to
 *  decode FEN input and disambiguate SAN moves presumed legal.
 *  Does not check legality or do move generation.  Hence does not
 *  maintain castling rights and other FEN features.
 */
class Position {
 public:
   vector<PIECES>* hexBoard; // a1=0 .. a2=16 .. a8=112 .. h8=127
   set<int> *WKSQ, *WQSQ, *WRSQ, *WBSQ, *WNSQ, *WPSQ;
   set<int> *BKSQ, *BQSQ, *BRSQ, *BBSQ, *BNSQ, *BPSQ;
   bool wtm;
   bool chess960;
   map<PIECES,set<int>*> sqsOf;

   explicit Position(const string& fen = "", bool c960 = false)
    : hexBoard(new vector<PIECES>(128,EM))
    , WKSQ(new set<int>()), WQSQ(new set<int>()), WRSQ(new set<int>())
    , WBSQ(new set<int>()), WNSQ(new set<int>()), WPSQ(new set<int>())
    , BKSQ(new set<int>()), BQSQ(new set<int>()), BRSQ(new set<int>())
    , BBSQ(new set<int>()), BNSQ(new set<int>()), BPSQ(new set<int>())
    , chess960(c960)
   {
      sqsOf[WK] = WKSQ; sqsOf[WQ] = WQSQ; sqsOf[WR] = WRSQ; 
      sqsOf[WB] = WBSQ; sqsOf[WN] = WNSQ; sqsOf[WP] = WPSQ;
      sqsOf[BK] = BKSQ; sqsOf[BQ] = BQSQ; sqsOf[BR] = BRSQ; 
      sqsOf[BB] = BBSQ; sqsOf[BN] = BNSQ; sqsOf[BP] = BPSQ;
      if (fen == "") {
         string startFEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 "; 
         setFromFEN(startFEN);
      } else {
         setFromFEN(fen);
      }
   }

   Position(const Position& p)
    : hexBoard(new vector<PIECES>(*(p.hexBoard)))
    , WKSQ(new set<int>(*(p.WKSQ))), BKSQ(new set<int>(*(p.BKSQ)))
    , WQSQ(new set<int>(*(p.WQSQ))), WRSQ(new set<int>(*(p.WRSQ)))
    , WBSQ(new set<int>(*(p.WBSQ))), WNSQ(new set<int>(*(p.WNSQ)))
    , WPSQ(new set<int>(*(p.WPSQ))), BQSQ(new set<int>(*(p.BQSQ)))
    , BRSQ(new set<int>(*(p.BRSQ))), BBSQ(new set<int>(*(p.BBSQ)))
    , BNSQ(new set<int>(*(p.BNSQ))), BPSQ(new set<int>(*(p.BPSQ)))
    , wtm(p.wtm), sqsOf(p.sqsOf)
   { }

   Position& operator=(const Position& p) {
      hexBoard = new vector<PIECES>(*(p.hexBoard));
      WKSQ = new set<int>(*(p.WKSQ)); BKSQ = new set<int>(*(p.BKSQ));
      WQSQ = new set<int>(*(p.WQSQ)); WRSQ = new set<int>(*(p.WRSQ));
      WBSQ = new set<int>(*(p.WBSQ)); WNSQ = new set<int>(*(p.WNSQ));
      WPSQ = new set<int>(*(p.WPSQ)); BQSQ = new set<int>(*(p.BQSQ));
      BRSQ = new set<int>(*(p.BRSQ)); BBSQ = new set<int>(*(p.BBSQ));
      BNSQ = new set<int>(*(p.BNSQ)); BPSQ = new set<int>(*(p.BPSQ));
      wtm = p.wtm;
      sqsOf = p.sqsOf;
      return (*this);
   }

   ~Position() {
      delete(hexBoard);
      delete(WKSQ); delete(WQSQ); delete(WRSQ); delete(WBSQ); delete(WNSQ); delete(WPSQ);
      delete(BKSQ); delete(BQSQ); delete(BRSQ); delete(BBSQ); delete(BNSQ); delete(BPSQ);
      //for (map<PIECES,set<int>*>::iterator it = sqsOf.begin(); it != sqsOf.end(); it++) {
         //delete(it->second);
      //}
   }


   void setFromFEN(const string& fen) {
      map<PIECES,set<int>*>::iterator it = sqsOf.begin();
      while (it != sqsOf.end()) {
         (*it++).second->clear();
      }
      for (int i = 0; i < 128; i++) { hexBoard->at(i) = EM; }
      //hexBoard = new vector<PIECES>(128,EM);
      int i = 0;
      int sq = 112;
      char c = fen.at(i);
      //size_t pp = pieceOf.find(string("")+c);
      size_t pp = pieceOf.find(c);
      PIECES piece;
      while (c != ' ') {
         switch(c) {
          case '/':
            sq -= 25;  //will add 1 later
            break;
          case 'k':
          case 'q':
          case 'r':
          case 'b':
          case 'n':
          case 'p':
          case 'K':
          case 'Q':
          case 'R':
          case 'B':
          case 'N':
          case 'P':
            piece = PIECES(pp);
            hexBoard->at(sq) = piece;
            sqsOf[piece]->insert(sq);
            break;
          case '8':
          case '7':
          case '6':
          case '5':
          case '4':
          case '3':
          case '2':
          case '1':
            sq += (IRutil::ord(c) - IRutil::ord('1')); // 1 gets added below
            break;
          default:
            cerr << "Unhandled FEN char " << c << endl;
         }
         i++;
         c = fen.at(i);
         //pp = pieceOf.find(string("")+c);
         pp = pieceOf.find(c);
         sq++;
      }
      i++;  //was on first space, now on side to move char
      wtm = (fen.at(i) == 'w');
   }

   string toBoardDiagram() {   //from Hugh Meyers' Perl version.
      bool whiteSquare = true;  //a8 is white
      ostringstream OUT;
      for (int rank = 7; rank >= 0; rank--) {
   
         // append numbers on left-hand side
         OUT << (rank + 1);
         OUT << "  ";
   
         for (int file = 0; file < 8; file++) {
   
            // append the piece, or a dash if it's a vacant black square
            PIECES piece = (hexBoard->at(16*rank + file));
            if (piece != EM) {
               OUT << pieceOf[piece];
            } else {
               OUT << (whiteSquare ? " " : "-");
            }
            // toggle whitesquare each square
            whiteSquare = !whiteSquare;
         }
         OUT << endl;
   
         // also toggle whitesquare each rank
         whiteSquare = !whiteSquare;
      }
      OUT << "   abcdefgh " << (wtm ? "wtm" : "btm") << endl;
      return OUT.str();
   }

   static bool valid(int hexsq) { 
      return (hexsq >= 0 && hexsq <= 127 && hexsq % 16 <= 7); 
   } 

   static int alg2hex(const string& algsq) {
      return 16*(IRutil::ord(algsq[1]) - IRutil::ord('1'))
                    + IRutil::ord(algsq[0]) - IRutil::ord('a');
   }

   static string hex2alg(int hexsq) {
      int quot = hexsq/16;
      int rem = hexsq % 16;
      string algsq = "00";
      algsq[0] = IRutil::chr(IRutil::ord('a') + rem);
      algsq[1] = IRutil::chr(IRutil::ord('1') + quot);
      return algsq;
   }

   bool canSlideAlong(int hexFrom, int hexTo, int baseDiff) const {
      int ssq = hexFrom + baseDiff;
      while (valid(ssq) && ssq != hexTo) {
         if (hexBoard->at(ssq) != EM) {
            return false;
         } else {
            ssq += baseDiff;
         }
      }
      return (ssq == hexTo);
   }

   //Return nonzero increment if true, else 0.
   int slideDirection(int hexFrom, int hexTo) const {
      int diff = hexTo - hexFrom;  //add to from in order to move
      int sdiff = IRutil::sgn(diff);
      int baseDiff = (fabs(diff) <= 7 ? sdiff
                        : (diff % 15 == 0 ? 15*sdiff
                             : (diff % 16 == 0 ? 16*sdiff
                                  : diff % 17 == 0 ? 17*sdiff : 0)));
      return ((baseDiff != 0 && canSlideAlong(hexFrom, hexTo, baseDiff)) ? baseDiff : 0);
   }
      
   int pinDirection(int hexsq) const {   //toward pinner when adding, 0 if none
      int ksq = (wtm ? (*WKSQ->begin()) : (*BKSQ->begin()));
      int baseDiff = slideDirection(ksq,hexsq);
      if (baseDiff == 0) { return 0; }
      int ssq = hexsq + baseDiff;
      while (valid(ssq) && hexBoard->at(ssq) == EM) {
         ssq += baseDiff;
      }
      if (!valid(ssq)) { return 0; }  //any invalid square could be used
      if ((wtm && hexBoard->at(ssq) == BQ) || ((!wtm) && hexBoard->at(ssq) == WQ)) {
         return baseDiff;   //return ssq; 
      } //else
      if ((wtm && hexBoard->at(ssq) == BR) || ((!wtm) && hexBoard->at(ssq) == WR)) {
         return ((baseDiff == 1 || baseDiff == -1 || baseDiff % 16 == 0) ? baseDiff : 0);
      } //else
      if ((wtm && hexBoard->at(ssq) == BB) || ((!wtm) && hexBoard->at(ssq) == WB)) {
         return ((baseDiff % 15 == 0 || baseDiff % 17 == 0) ? baseDiff : 0);
      } //else
      return 0;
   }
  

   /** REQ: piece on source square is QRBN, returns false if not.
    *  Since we presume given move is legal, we need not check that dest square
    *  is not occupied by a same-colored piece in filtering source squares.
    */
   bool isSemiLegal(int hexFrom, int hexTo) const {
      PIECES piece = hexBoard->at(hexFrom);
      if (piece == WN || piece == BN) {
         int ad = fabs(hexFrom - hexTo);
         return ((ad == 14 || ad == 18 || ad == 31 || ad == 33)
                    && pinDirection(hexFrom) == 0);
      } //else
      int baseDiff = slideDirection(hexFrom,hexTo);
      int pinDiff = pinDirection(hexFrom);
      bool moveOK = (baseDiff != 0 && (piece == WQ || piece == BQ 
         || ((piece == WB || piece == BB) && (baseDiff % 15 == 0 || baseDiff % 17 == 0))
         || ((piece == WR || piece == BR) && 
               (baseDiff == -1 || baseDiff == 1 || baseDiff % 16 == 0))));
      return (moveOK && (pinDiff == 0 || fabs(pinDiff) == fabs(baseDiff)));
   }

   bool blackInCheck() const {
      set<int>::const_iterator itr = BKSQ->begin();
      int bksq = *itr;
      int wksq = *(WKSQ->begin());
      int dir = bksq - wksq;  //direction from source square ssq, = bksq - ssq;
      int ad = fabs(dir);
      if (ad == 1 || ad == 15 || ad == 16 || ad == 17) { return true; }
      for (itr = WPSQ->begin(); itr != WPSQ->end(); itr++) {
         dir = bksq - *itr;
         if (dir == 15 || dir == 17) { return true; }
      }
      for (itr = WNSQ->begin(); itr != WNSQ->end(); itr++) {
         ad = fabs(bksq - *itr);
         if (ad == 14 || ad == 18 || ad == 31 || ad == 33) { return true; }
      }
      for (itr = WBSQ->begin(); itr != WBSQ->end(); itr++) {
         ad = fabs(slideDirection(*itr,bksq));
         if (ad == 15 || ad == 17) { return true; }
      }
      for (itr = WRSQ->begin(); itr != WRSQ->end(); itr++) {
         ad = fabs(slideDirection(*itr,bksq));
         if (ad == 1 || ad == 16) { return true; }
      }
      for (itr = WQSQ->begin(); itr != WQSQ->end(); itr++) {
         ad = fabs(slideDirection(*itr,bksq));
         if (ad == 1 || ad == 15 || ad == 16 || ad == 17) { return true; }
      }
      return false;
   }
      
   bool whiteInCheck() const {
      set<int>::const_iterator itr = BKSQ->begin();
      int bksq = *itr;
      int wksq = *(WKSQ->begin());
      int dir = wksq - bksq;  //direction from source square ssq, = wksq - ssq;
      int ad = fabs(dir);
      if (ad == 1 || ad == 15 || ad == 16 || ad == 17) { return true; }
      for (itr = BPSQ->begin(); itr != BPSQ->end(); itr++) {
         dir = wksq - *itr;
         if (dir == -15 || dir == -17) { return true; }
      }
      for (itr = BNSQ->begin(); itr != BNSQ->end(); itr++) {
         ad = fabs(wksq - *itr);
         if (ad == 14 || ad == 18 || ad == 31 || ad == 33) { return true; }
      }
      for (itr = BBSQ->begin(); itr != BBSQ->end(); itr++) {
         ad = fabs(slideDirection(*itr,wksq));
         if (ad == 15 || ad == 17) { return true; }
      }
      for (itr = BRSQ->begin(); itr != BRSQ->end(); itr++) {
         ad = fabs(slideDirection(*itr,wksq));
         if (ad == 1 || ad == 16) { return true; }
      }
      for (itr = BQSQ->begin(); itr != BQSQ->end(); itr++) {
         ad = fabs(slideDirection(*itr,wksq));
         if (ad == 1 || ad == 15 || ad == 16 || ad == 17) { return true; }
      }
      return false;
   }

   bool inCheck() const { return (wtm ? whiteInCheck() : blackInCheck()); }
         

   /** Parsing strategy: After treating castling separately, we look for the
    *  rightmost match to [a-h][1-8] as destination square, with m indexing a-h.
    *  If m == 0 then it's a simple SAN pawn move like e4.
    *  Else we test for a bridge - x : or source char in [a-h] or [1-8].
    *  If bridge is present then we test previous char for [a-h] or [1-8].  
    *  Let k index this test char.  Cases:
    *  [1-8] is a rank disambiguator---then test prev char again
    *     If prevchar is in [a-h] then we have full source square, which means
    *        move is in UCI or LAN or TAN.  Check board for piece, not first char.
    *     Else it should be a piece and k-1 == 0,
    *  [a-h] is a file disambiguator, as in exd5 or Nfxd4 or Rae8. 
    *     Again prev char should be piece with index k-1 == 0.
    *  MoveParse(char p, string si, string d, bool cap, string suff)
    */
   MoveParse parseMove(const string& move) const {
      //ofstream oflog("out.txt", ios::app);
      //oflog << move << endl;
      //oflog.close();
      MoveParse mp; //construction not just declaration
      size_t n = move.size();
      if (n <= 1) { cerr << "Bad move " << move << endl; return mp; }
      char c = move.at(0);
      if (c == 'O' || c == '0') {  //castles, allows Chess960 "King takes Rook" form
         int ksq = (wtm ? (*WKSQ->begin()) : (*BKSQ->begin()));
         int basediff = ((n >= 4 && move.at(3) == '-') ? -1 : +1); //O-O-O apart from O-O+!
         int rooksq = ksq + basediff;
         while (valid(rooksq) && hexBoard->at(rooksq) == EM) { rooksq += basediff; }
         int kdest = (chess960 ? rooksq : ksq + 2*basediff);
         char k = (wtm ? 'K' : 'k');
         MoveParse mp(k,hex2alg(ksq),hex2alg(kdest),false,"c");
         return mp;
      } //now parse promotion apart from annotations like +, #, !, ?
      int m = n - 1;
      char destRank = move.at(m);
      if (destRank == 'c') { mp.prom = "c"; }  //could be TAN castling
      while (IRutil::ord(destRank) > IRutil::ord('8') 
                || IRutil::ord(destRank) < IRutil::ord('1')) {
         destRank = move.at(--m);
      }
      if (m < n - 1) {
         char e = move.at(m+1);  
         if (e == '=' && m < n - 2) {  //promotion in "=Q" style
            e = move.at(m+2);
         }
         if (e == 'Q' || e == 'q') {   //UCI as well as TAN uses lowercase
            mp.prom = string("") + (wtm ? 'Q' : 'q');
         } else if (e == 'R' || e == 'r') {
            mp.prom = string("") + (wtm ? 'R' : 'r');
         } else if (e == 'B' || e == 'b') {
            mp.prom = string("") + (wtm ? 'B' : 'b');
         } else if (e == 'N' || e == 'n') {
            mp.prom = string("") + (wtm ? 'N' : 'n');
         } // else leave prom == ""
      }
      if (m < 1) { cerr << "Badd move " << move << endl; return mp; }
      char destFile = move.at(--m);
      if (IRutil::ord(destFile) < IRutil::ord('a') 
             || IRutil::ord(destFile) > IRutil::ord('h')) {
         cerr << "Baddd move " << move << endl; return mp;
      }
      mp.dest = string("") + destFile + destRank;
      int hexsq;  //source square we are finding
      mp.capture = (hexBoard->at(alg2hex(mp.dest)) != EM);
      if (m > 0) {  //not a simple Pawn move like e4 
         int k = m - 1;
         char b = move.at(k);
         if (b == 'x' || b == ':') {
            mp.capture = true;
            k--;
         } else if (b == '-') {
            k--;  //leave capture false
         }

         if (k < 0) { cerr << "Badddd move " << move << endl; return mp; }
         b = move.at(k);
         if (IRutil::ord('1') <= IRutil::ord(b) && IRutil::ord(b) <= IRutil::ord('8')) { 
            //source rank given
            mp.sourceInfo = string("") + b;
            if (k == 0) { cerr << "Baddddd move " << move << endl; return mp; }
            char a = move.at(k-1);
            if (IRutil::ord('a') <= IRutil::ord(a) && IRutil::ord(a) <= IRutil::ord('h')) { 
               //whole source square given.  Might be only info in UCI move.
               mp.sourceInfo = string("") + a + mp.sourceInfo;
               hexsq = alg2hex(mp.sourceInfo);
               mp.piece = pieceOf.at(hexBoard->at(hexsq));
               if (mp.piece == ' ') { cerr << "Mislaid move " << move << endl; }
               //now must allow for UCI castling including chess960 variant
               if ((mp.piece == 'K' && (move == "e1g1" || move == "e1c1" 
                                        || hexBoard->at(alg2hex(mp.dest)) == WR) 
                    || (mp.piece == 'k' && (move == "e8g8" || move == "e8c8" 
                                        || hexBoard->at(alg2hex(mp.dest)) == BR)))) {
                  mp.prom = "c";
               } else if ((mp.piece == 'P' || mp.piece == 'p')
                             && mp.dest.at(0) != mp.sourceInfo.at(0)
                             && hexBoard->at(alg2hex(mp.dest)) == EM) {  
                  mp.prom = "e";
               }
               return mp;
            } else {   //it must be a piece---nothing more to do yet.
               k--;
            }
         } else if (IRutil::ord('a') <= IRutil::ord(b) && IRutil::ord(b) <= IRutil::ord('h')) { 
            //source file given
            mp.sourceInfo = string("") + b;
            if (k == 0) {   //move was capture like exd4
               mp.piece = (wtm ? 'P' : 'p');
               k = -1;
            } else {
               k--;
            }
         }
         if (k > 0) {
            cerr << "Parsing mishap on move " << move << endl; return mp; 
         } else if (k == 0 && mp.piece == ' ') {  //piece given in move, need to read
            mp.piece = (wtm ? IRutil::makeUpper(move.at(0)) : IRutil::makeLower(move.at(0)));
         }
      } else {   //simple pawn move case, no help with source square
         mp.piece = (wtm ? 'P' : 'p');
      } //now we have piece and sourceInfo and dest square.  Must complete source square.
      return mp;
   }


   /** TAN extends LAN with info needed to translate to SAN without looking at the board.
    *  If the rank is needed to disambiguate, append "i"; if the file, "j"; if both, "k";
    *  Else the suffix can be "c" for castling, "e" for en-passant, or a promoted piece.
    *  All mentions of Black pieces are lowercased in TAN.
    *  Legality of moves not needing disambiguation, e.g. pinned pawns, is *not* checked.
    */
   string move2TAN(const string& move) const {
      MoveParse mp = parseMove(move);
      string bridge = (mp.capture ? "x" : "-");
      string suff = (mp.capture && hexBoard->at(alg2hex(mp.dest)) == EM ? "e" : mp.prom);
      string source;
      if (mp.piece == 'K') {
         source = hex2alg(*WKSQ->begin());  //good for castling too
         if (hexBoard->at(alg2hex(mp.dest)) == WR) { suff = "c"; } //Chess960 UCI
         return string("K") + source + bridge + mp.dest + suff;
      }  //else
      if (mp.piece == 'k') {
         source = hex2alg(*BKSQ->begin()); //TAN for Black O-O is "ke8-g8c"
         if (hexBoard->at(alg2hex(mp.dest)) == BR) { suff = "c"; } //Chess960 UCI
         return string("k") + source + bridge + mp.dest + suff;
      }  //else
      if (mp.piece == 'P') {
         if (mp.sourceInfo.length() == 2) {
            return string("P") + mp.sourceInfo + bridge + mp.dest + suff;
         } else if (mp.sourceInfo.length() == 1) {  //pawn capture
            char sourceRank = IRutil::chr(-1 + IRutil::ord(mp.dest[1]));
            return string("P") + mp.sourceInfo + sourceRank + bridge + mp.dest + suff;
         } else {   //simple SAN move such as e4, could be double-move
            int prevsq = alg2hex(mp.dest) - 16;
            bool djump = (hexBoard->at(prevsq) == EM);
            source = hex2alg(djump ? prevsq - 16 : prevsq);
            return string("P") + source + bridge + mp.dest + suff;
         }
      }  //else
      if (mp.piece == 'p') {
         if (mp.sourceInfo.length() == 2) {
            return string("p") + mp.sourceInfo + bridge + mp.dest + suff;
         } else if (mp.sourceInfo.length() == 1) {  //pawn capture
            char sourceRank = IRutil::chr(1 + IRutil::ord(mp.dest[1]));
            return string("p") + mp.sourceInfo + sourceRank + bridge + mp.dest + suff;
         } else {   //simple SAN move such as e4, could be double-move
            int prevsq = alg2hex(mp.dest) + 16;
            bool djump = (hexBoard->at(prevsq) == EM);
            source = hex2alg(djump ? prevsq + 16 : prevsq);
            return string("p") + source + bridge + mp.dest + suff;
         }
      }  //else
      size_t pp = pieceOf.find(mp.piece);
      PIECES piece;
      if (pp != string::npos) {
         piece = PIECES(pp);
      } else {
         cerr << "Cannot determine move from " << mp.toString() << endl;
         return "";
      }
      vector<string> hitSquares;
      vector<string> filteredSquares; //not used
      int hitCount = 0;
      int trueCount = 0;
      int hexTo = alg2hex(mp.dest);
   
      set<int>::const_iterator it = ((sqsOf.find(piece))->second)->begin();
      set<int>::const_iterator ed = ((sqsOf.find(piece))->second)->end();
      while (it != ed) {
         int hexFrom = *it++;
         string algsq = hex2alg(hexFrom);
         if (isSemiLegal(hexFrom,hexTo)) {
            hitCount++;
            hitSquares.push_back(algsq);
            if (mp.sourceInfo == "" || mp.sourceInfo == algsq 
                   || mp.sourceInfo == string("") + algsq[0]
                   || mp.sourceInfo == string("") + algsq[1]) {
               trueCount++;
               filteredSquares.push_back(algsq);
               source = algsq;  //optimistic
            }
         }
      }
               
         
      if (hitCount == 1) {   // no disambiguation needed
   
         return string("") + mp.piece + source + bridge + mp.dest + suff;
   
      } else if (trueCount != 1) {
         string flaw = (trueCount == 0 ? "unmakable" : "ambiguous");
         cerr << "Move " << mp.toString() << " is " << flaw << endl;
         return "";
      } //else---trueCount == 1 but hitCount >= 2.  Assume file disambig unless rank needed
   
      bool needFile = false;
      bool needRank = false;
   
      vector<string>::iterator itv = hitSquares.begin();
      while (itv != hitSquares.end()) {
         string algsqr = *itv++;
         if (algsqr != source) { 
            needRank = (needRank || algsqr[0] == source[0]);
            needFile = (needFile || algsqr[1] == source[1]);
         }
      }
      suff = "j";              // file---will we override it?
      if (needRank) {          // two source squares have same file
         suff = (needFile ? "k" : "i");
      }
   
      return (string("") + mp.piece + source + bridge + mp.dest + suff);
   
   }

   string move2UCI(const string& move) const { return Move(move2TAN(move)).TAN2UCI(); }
   string move2LAN(const string& move) const { return Move(move2TAN(move)).TAN2LAN(); }
   string move2SAN(const string& move) const { return Move(move2TAN(move)).TAN2SAN(); }

   void playMove(const Move& move) {
      string tanMove = move.getTAN();
      if (tanMove.length() < 6) { 
         cerr << "Bad TAN " << move << "->" << tanMove << endl << toBoardDiagram(); 
      }
      string algFrom = tanMove.substr(1,2);
      string algTo = tanMove.substr(4,2);
      string suff = tanMove.substr(6); // = "" if tanMove has none
      int hexFrom = alg2hex(algFrom);
      int hexTo = alg2hex(algTo);
      if (suff == "c") { //castling---need to find castled-with Rook (in Chess960)
         int diff = IRutil::sgn(hexTo - hexFrom);
         int hexsq = hexFrom + diff;
         while (hexBoard->at(hexsq) == EM) { hexsq += diff; }
         set<int>* rookSqs = (wtm ? WRSQ : BRSQ);
         set<int>* ksqs = (wtm ? WKSQ : BKSQ);
         hexBoard->at(hexsq) = EM;
         rookSqs->erase(hexsq);
         hexBoard->at(hexFrom) = EM;  //must be king's square
         ksqs->erase(hexFrom);
         int newksq = (wtm ? (diff > 0 ? alg2hex("g1") : alg2hex("c1"))
                           : (diff > 0 ? alg2hex("g8") : alg2hex("c8")));
         int newrsq = (wtm ? (diff > 0 ? alg2hex("f1") : alg2hex("d1"))
                           : (diff > 0 ? alg2hex("f8") : alg2hex("d8")));
         hexBoard->at(newksq) = (wtm ? WK : BK);
         ksqs->insert(newksq);
         hexBoard->at(newrsq) = (wtm ? WR : BR);
         rookSqs->insert(newrsq);
      } else if (suff == "e") {   //en-passant capture
         string capSq = string("") + algTo.at(0) + algFrom.at(1);
         int capHex = alg2hex(capSq);
         set<int>* samePawns = (wtm ? WPSQ : BPSQ);
         set<int>* oppPawns = (wtm ? BPSQ : WPSQ);
         hexBoard->at(hexFrom) = EM;
         samePawns->erase(hexFrom);
         hexBoard->at(capHex) = EM;
         oppPawns->erase(capHex);
         hexBoard->at(hexTo) = (wtm ? WP : BP);
         samePawns->insert(hexTo);
      } else {
         PIECES taken = hexBoard->at(hexTo);
         if (taken != EM) {
            hexBoard->at(hexTo) = EM;
            sqsOf[taken]->erase(hexTo);
         }
         PIECES piece = hexBoard->at(hexFrom);
         hexBoard->at(hexFrom) = EM;
         sqsOf[piece]->erase(hexFrom);
         size_t pp = pieceOf.find(suff);
         if (suff != "" && pp != string::npos) {
            PIECES promPiece = PIECES(pp);
            hexBoard->at(hexTo) = promPiece;
            sqsOf[promPiece]->insert(hexTo);
         } else {
            hexBoard->at(hexTo) = piece;
            sqsOf[piece]->insert(hexTo);
         }
      }
      wtm = !wtm;
   }

   void playMove(const string& move) {
      playMove(Move(move2TAN(move)));
   }
};

inline string playAIFfile(const string& fileName) {
   int count = 0;
   int turn;
   ifstream AIF(fileName.c_str());
   ostringstream OUT;
   string line;
   string movePlayed, engineMove, fen;
   Position p;
   while (getline(AIF,line)) {
      if (line.find("GameID ") != string::npos) {  //begin new game
         OUT << endl << endl << line << endl;
         turn = 9;
         while (getline(AIF,line)) {
            if (line.find("MovePlayed ") != string::npos) {
               movePlayed = IRutil::fetchField(line);
            } 
            if (line.find("EngineMove ") != string::npos) {
               engineMove = IRutil::fetchField(line);
            }
            if (line.find("FEN ") != string::npos) {
               fen = IRutil::fetchField(line);
               p.setFromFEN(fen);
               p.playMove(movePlayed);
               OUT << fen << endl << turn << ". " << movePlayed << " ";
               break;
            }
         }
      } else if (line.find("MovePlayed ") != string::npos) {
         movePlayed = IRutil::fetchField(line);
         count++;
         if (p.wtm) { 
            turn++;
         }
         string tanMove = p.move2TAN(movePlayed);
         string uciMove = Move(tanMove).TAN2UCI();
         string sanMove = Move(tanMove).TAN2SAN();
         string lanMove = Move(tanMove).TAN2LAN();
         string move = (count % 4 == 0 ? movePlayed 
                          : (count % 4 == 1 ? lanMove
                               : (count % 4 == 2 ? tanMove : uciMove)));
         if (p.wtm) { OUT << turn << ". "; }
         string actualTAN = p.move2TAN(move);
         p.playMove(move);
         OUT << lanMove << " ";
      }
   }
   OUT << endl;
   return OUT.str();
}


#endif
 
//File--------------------IRmiscGlobal.h------------------------------------ 
 
#ifndef __IR_MISC_GLOBAL_H__ 
#define __IR_MISC_GLOBAL_H__ 
 
class Catalogable { 
   virtual string getName() const = 0; 
   virtual string getDescription() const = 0; 
 public: 
   virtual ~Catalogable() { } 
}; 
 
#endif   //end of #ifndef __IR_MISC_GLOBAL_H__ 
 
 
 
//File--------------------TrialSpec.h------------------------------------- 
 
#ifndef __IR_TRIAL_SPEC_H__ 
#define __IR_TRIAL_SPEC_H__ 
 
//------------------------SPECIFYING CURVES-------------------------------- 
 
// Whether to make curves and weights Catalogable, and whether to include 
// the line element in a TrialSpec, are tricky questions.  Curves and 
// weights are accessed continually during the regressions, so max performance 
// is needed, while the line element is applied only while filtering 
// TurnInfo lists down to TupleInfo lists.  Hence the current choices. 

 
class TrialSpec : public Catalogable { 
 public: 
   IRfun::CURVES curveChoice;   //maintained as first entry in curvesBook and used when size==1
   map<IRfun::CURVES, double> curveBook;
   size_t size;

   IRfun::WEIGHTS weightMethodChoice;

   
   //string argFormation;  // "out" or "in" or "proxy"
   string name;
   double s;  //settable, as are c and d too
   double c; 
   double d;  //depth peak, can be Poisson lambda---not necessarily integer.
              //assume DecisionInfo class adjusts depth between engines. 
   double v;  //coefficient of variation for d, defaults to 1.0  (Poisson)
              //value of 0 means only depth-d results used.
   double a;  //special power of negative swing.  (Was w: coefficient of swing.)
   double hm; //special coefficient of negative swing (besides s)
   double hp; //special coefficient of positive swing (besides s).
   double b;  //special power of positive swing---as with a, slack power over c.

   bool slides;  //
   IRfun::CURVES slideCurveChoice;
   double slideLo;
   double slideMid;
   double slideHi;
   double slidePower;
   double slideProp;

   double memoStep;
   double memoCap;
   size_t memoSize;
   vector<double> myMemoTable;  //INV: holds values of curveChoice(delta)

 
   TrialSpec(IRfun::CURVES gcc, map<IRfun::CURVES,double> cb, IRfun::WEIGHTS gwc, const string& gname, 
             double gs, double gc, double gd, double gv, double ga, double ghm, double ghp, double gb, 
             bool slide = false, IRfun::CURVES altCurveChoice = IRfun::FOLDEDLOGISTIC, double glo = 0.0, 
             double gmid = 1.5, double ghi = 3.0, double slp = 2.0, double maxp = 1.0,
             double memStep = 0.01, double memCap = 5.00)
      : curveChoice(gcc), curveBook(cb), size(cb.size()), weightMethodChoice(gwc), name(gname), 
        s(gs), c(gc), d(gd), v(gv), a(ga), hm(ghm), hp(ghp), b(gb), slides(slide), 
        slideCurveChoice(altCurveChoice), slideLo(glo), slideMid(gmid), slideHi(ghi), slidePower(slp),
        slideProp(maxp), memoStep(memStep), memoCap(memCap), memoSize(memoCap/memoStep + 1),
        myMemoTable(vector<double>(memoSize)) {

        if (memCap > 0.0) { memoize(); }  //change to passed-in memoTable pointer?
   } 
   TrialSpec() { } //needed to make "map" happy, but shouldn't be used 
   virtual ~TrialSpec() {  
      //delete(myMemoTable); //Don't delete---is shared/not pointer anymore anyway
   } 
 
   inline double evalCurves1(const double z) const {
      if (size <= 1 && (!slides)) {
         return IRfun::evalCurve1(curveChoice,z);
      } //else
      double val = 0.0;
      double denom = 0.0;
      double mul;
      IRfun::CURVES curve;
      map<IRfun::CURVES,double>::const_iterator cbit = curveBook.begin();
      map<IRfun::CURVES,double>::const_iterator cbite = curveBook.end();
      while (cbit != cbite) {
         curve = cbit->first;
         mul = cbit->second;
         denom += mul;
         val += mul*IRfun::evalCurve1(curve,z);
         ++cbit;
      }
      val = IRutil::divifgt0(val,denom);
      if (!slides) { return val; }
      //else
      double val2 = IRfun::evalCurve1(slideCurveChoice,z);
      double w = (z < slideLo ? 0 : (z < slideMid ? (z - slideLo)/(slideMid - slideLo)
                    : (z < slideHi ? (slideHi + z - 2.0*slideMid)/(slideHi - slideMid) : 2.0)))/2.0;
      double wa = pow(w,slidePower);
      double slider = slideProp*wa/(wa + pow(1.0 - w, slidePower));
      return ((1.0 - slider)*val + slider*val2);
   }

   inline double mevalCurves1(const double z) const {
      if (z < memoCap) {
         double dind = z/memoStep;
         size_t left = size_t(dind);
         return ((left+1.0-dind)*myMemoTable.at(left) + (dind-left)*myMemoTable.at(left+1));
      } //else
      return evalCurves1(z);
   }

   inline double evalCurves2(const double y, const double c) const {
      if (size <= 1 && (!slides)) {
         return IRfun::evalCurve2(curveChoice,y,c);
      } //else
      double val = 0.0;
      double denom = 0.0;
      double mul;
      IRfun::CURVES curve;
      map<IRfun::CURVES,double>::const_iterator cbit = curveBook.begin();
      map<IRfun::CURVES,double>::const_iterator cbite = curveBook.end();
      while (cbit != cbite) {
         curve = cbit->first;
         mul = cbit->second;
         denom += mul;
         val += mul*IRfun::evalCurve2(curve,y,c);
         ++cbit;
      }
      val = IRutil::divifgt0(val,denom);
      if (!slides) { return val; }
      //else
      double val2 = IRfun::evalCurve2(slideCurveChoice,y,c);
      double w = (y < slideLo ? 0 : (y < slideMid ? (y - slideLo)/(slideMid - slideLo)
                    : (y < slideHi ? (slideHi + y - 2.0*slideMid)/(slideHi - slideMid) : 2.0)))/2.0;
      double wa = pow(w,slidePower);
      double slider = slideProp*wa/(wa + pow(1.0 - w, slidePower));
      return ((1.0 - slider)*val + slider*val2);
   }

   inline double mevalCurves2(const double y, const double c) const {
      if (y < memoCap) {
         double dind = y/memoStep;
         size_t left = size_t(dind);
         return ((left+1.0-dind)*myMemoTable.at(left) + (dind-left)*myMemoTable.at(left+1));
      } //else
      return evalCurves2(y,c);
   }

   inline double evalCurves3(const double x, const double s, const double c) const {
      if (size <= 1 && (!slides)) {
         return IRfun::evalCurve3(curveChoice,x,s,c);
      } //else
      double val = 0.0;
      double denom = 0.0;
      double mul;
      IRfun::CURVES curve;
      map<IRfun::CURVES,double>::const_iterator cbit = curveBook.begin();
      map<IRfun::CURVES,double>::const_iterator cbite = curveBook.end();
      while (cbit != cbite) {
         curve = cbit->first;
         mul = cbit->second;
         denom += mul;
         val += mul*IRfun::evalCurve3(curve,x,s,c);
         ++cbit;
      }
      val = IRutil::divifgt0(val,denom);
      if (!slides) { return val; }
      //else
      double val2 = IRfun::evalCurve3(slideCurveChoice,x,s,c);
      double w = (x < slideLo ? 0 : (x < slideMid ? (x - slideLo)/(slideMid - slideLo)
                    : (x < slideHi ? (slideHi + x - 2.0*slideMid)/(slideHi - slideMid) : 2.0)))/2.0;
      double wa = pow(w,slidePower);
      double slider = slideProp*wa/(wa + pow(1.0 - w, slidePower));
      return ((1.0 - slider)*val + slider*val2);
   }

   inline double mevalCurves3(const double x, const double s, const double c) const {
      if (x < memoCap) {
         double dind = x/memoStep;
         size_t left = size_t(dind);
         return ((left+1.0-dind)*myMemoTable.at(left) + (dind-left)*myMemoTable.at(left+1));
      } //else
      return evalCurves3(x,s,c);
   }


   inline void memoize3() {
      for (size_t i = 0; i < memoSize; i++) {
         myMemoTable.at(i) = evalCurves3(i*memoStep,s,c);
      }
   }

   inline void memoize2() {
      for (size_t i = 0; i < memoSize; i++) {
         myMemoTable.at(i) = evalCurves2(i*memoStep,c);
      }
   }

   inline void memoize1() {
      for (size_t i = 0; i < memoSize; i++) {
         myMemoTable.at(i) = evalCurves1(i*memoStep);
      }
   }

   inline void memoize(const size_t numArgs = 3) {
      if (numArgs == 3) {
         memoize3();
      } else if (numArgs == 1) {
         memoize1();
      } else if (numArgs == 2) {   
         memoize2();
      } else {
         memoize3();
      }
   }

 
 
   inline IRfun::WeightMethod selWeightMethod() const { 
      IRfun::WeightMethod weightMethod; 
      switch(weightMethodChoice) { 
       case IRfun::UNITWTS: 
       	 weightMethod = &IRfun::unitWeights; 
         break; 
       case IRfun::SUMWTS: 
       	 weightMethod = &IRfun::sumWeights; 
         break; 
       case IRfun::LOGSUMWTS: 
       	 weightMethod = &IRfun::logSumWeights; 
         break; 
       case IRfun::ENTROPYWTS: 
         weightMethod = &IRfun::entropyWeights; 
         break; 
       case IRfun::FALLOFFWTS: 
         weightMethod = &IRfun::falloffWeights; 
         break; 
       case IRfun::INVVARP: 
       	 weightMethod = &IRfun::invVarP0; 
         break; 
       default: 
       	 cout << "Using Unit Weights, hope that's OK." << endl; 
         weightMethod = &IRfun::unitWeights; 
      } 
      return weightMethod; 
   } 
 
   string showCurvePoints(double step, double cap) const {
      ostringstream o;
      double arg = 0.00;
      double lastRes = 1.0;
      double res;
      string spacer = "";
      while (arg <= cap) {
         res = mevalCurves3(arg,s,c);
         spacer = (res > lastRes ? spacer+" " : "");
         o << fixed << setprecision(3) << setw(5) << right
           << arg << ": " << spacer << setprecision(7) << setw(9) << res << endl;
         arg += step;
         lastRes = res;
      }
      return o.str();
   }

 
   string getName() const { 
      return name; 
   } 
      // + "s" + ftoa(s,3) + "c" + ftoa(c,3); 
   void setName(const string& gname) { name = gname; } 
 
   string getKind() const {
      string st = "";
      map<IRfun::CURVES, double>::const_iterator cbit = curveBook.begin();
      map<IRfun::CURVES, double>::const_iterator cbite = curveBook.end();
      while (cbit != cbite) {
         st += "(" + IRfun::curveNames[IRfun::CURVES(cbit->first)] + ":" 
                   + IRutil::ftoa(cbit->second) + ")";
      //string st = IRfun::curveNames[curveChoice] + ", "
         ++cbit;
      }
      string slstr = (slides ? "" : "not ");
      if (slides) {
         st += " --> " + IRutil::ftoa(slideProp,2) + "*" + IRfun::curveNames[slideCurveChoice] 
                     + " by " + IRutil::ftoa(slidePower,3) + " in [" + IRutil::ftoa(slideLo,2) 
                     + "," + IRutil::ftoa(slideMid,2) + "," +  IRutil::ftoa(slideHi,2) + "]";
      }
      st += ", " + IRfun::weightNames[weightMethodChoice] + " weights";
      return st;
   }

   string paramsPosition(size_t prec = 4) const {
      string str = "s = " + IRutil::ftoa(s,prec) + ", c = " + IRutil::ftoa(c,prec)
                + ", d = " + IRutil::ftoa(d,prec) + ", v = " + IRutil::ftoa(v,prec)
                + ", a = " + IRutil::ftoa(a,prec) + ", hm = " + IRutil::ftoa(hm,prec)
                + ", hp = " + IRutil::ftoa(hp,prec) + ", b = " + IRutil::ftoa(b,prec);
      return str;
   }

   string getDescription() const { 
      string st = (memoCap > 0 ? "; memo(" + IRutil::ftoa(memoStep) + "," + IRutil::ftoa(memoCap) + ")" : "");
      //string st2 = getKind() + " with\n" + paramsPosition();
                // and judgment depth " + IRutil::itoa(judgmentDepth); 
      return getKind() + st + " with\n" + paramsPosition();
   } 

   string oneLine() const {
      return name + ": " + getDescription();
   }
 
   operator string() const { 
      return name + ": " + getDescription();
   } 
}; 
 
#endif    //end of #ifndef __IR_TRIAL_SPEC_H__ 
 
 
 
 
//File--------------------------GameInfo.h-------------------------------- 
 
#ifndef __IR_GAME_INFO_H__ 
#define __IR_GAME_INFO_H__ 

class TurnInfo;

class GameInfo { 
public:  
   const string gameID;
   const string engineID;
   const string platform;
   const int numThreads;
   const int hash;
   const int numPV;
   int minEngineDepth; //first depth with values given by engine
   const int minHighDepth;
   const int maxHighDepth;   //from AIF DepthRange
   const string egt;
   const string mode;
   //const string direction;  //from AIF mode
   //const string hashPolicy;
   //const string startTurn;
   
   const string eventName; 
   const string site; 
   const IRutil::SimpleDate date; 
   const int round; 
   const string whitePlayer; 
   const string blackPlayer; 
   const string result;//string is fine, as it is the pgn standard 

   const string eco; 
   const int whiteElo; 
   const int blackElo; 
   const int plyCount; 
   const IRutil::SimpleDate eventDate; 
   const string eventType;
   const int eventRounds;
   const string eventCountry;
   const string eventCategory;
   const string source; 
   const IRutil::SimpleDate sourceDate; 
   const string timeControl;  //e.g. [TimeControl "40/4800:20/2400:1200"]
   const string whiteTeam;
   const string blackTeam;
   const string whiteTeamCountry;
   const string blackTeamCountry;
   const string whiteFIDEID;
   const string blackFIDEID;


   //Extra fields
   const string gameBody;
   vector<TurnInfo*>* gameTurns;  //since turns are unique to game, can delete
 
   GameInfo(const string& gid, const string& eid, const string& pl,
      int nt, int ha, int numpv, int mindepth, int maxdepth, 
      const string& egtb, const string& modestr, const string& ev, const string& si,
      const IRutil::SimpleDate& dt, int rd, const string& wp, 
      const string& bp, const string& rslt, const string& eco2,
      int welo, int belo, int plyc, const IRutil::SimpleDate& edate, 
      const string& et, int er, const string& ec, const string& ecat, const string& src,
      const IRutil::SimpleDate& sdate, const string& tc, const string& wt, const string& bt,
      const string& wtc, const string& btc, const string& wfid, const string& bfid,
      const string& gb = "") 
      : gameID(gid), engineID(eid), platform(pl), numThreads(nt), hash(ha), numPV(numpv),
        minEngineDepth(1), minHighDepth(mindepth), maxHighDepth(maxdepth), egt(egtb), mode(modestr),
        eventName(ev), site(si), date(dt), round(rd), whitePlayer(wp), blackPlayer(bp),
        result(rslt), eco(eco2), whiteElo(welo), blackElo(belo), plyCount(plyc),
        eventDate(edate), eventType(et), eventRounds(er), eventCountry(ec), eventCategory(ecat),
        source(src), sourceDate(sdate), timeControl(tc), whiteTeam(wt), blackTeam(bt),
        whiteTeamCountry(wtc), blackTeamCountry(btc), whiteFIDEID(wfid), blackFIDEID(bfid),
        gameBody(gb), gameTurns(new vector<TurnInfo*>())
   {
      if (eid.find("omod") != string::npos) {
         minEngineDepth = 5;
      }
   } 
 
   virtual ~GameInfo() {
      /*
      for (vector<TurnInfo*>::iterator itr = gameTurns->begin(); itr != gameTurns->end(); itr++) {
         delete(*itr);
      } //Not allowed with forward reference, managed by Ensemble
      */
      delete(gameTurns); //individual turns are cleared from focus trial
   } 
}; 
 
#endif //end of __IR_GAME_INFO_H__ 
 
 
 
 
//File--------------------------TurnInfo.h--------------------------------- 
 
#ifndef __IR_TURN_INFO_H__ 
#define __IR_TURN_INFO_H__ 

#include <algorithm>
 
/** Class TurnInfo represents the raw data extracted by the Perl script 
    from the engine output.  The only *written* change to the raw data is  
    applying a hard DELTACAP of 10.00, because the Perl script translated  
    mates to this value, and engines may use this or a 5.00 cap in searches. 
    It computes actual "falloff" in two basic ways ways: 
    () turnFalloff = eval(this turn) - eval(next turn), signed. 
    () deltaFalloff = deltas[playedMoveIndex] when playedMoveIndex < NCUTOFF, 
       = box(deltas[NCUTOFF - 1], turnFalloff, falloffFix(deltas[NCUTOFF - 1])) 
       otherwise, where box(a,b,c) = if b < a then a else min(b,c). 
    When there is no next turn, the "falloffFix(...)" estimate is used.  Also: 
    () turnFalloffCapped applies the soft Trial::deltaCap value, and 
    () deltaFalloffCapped ditto. 
 
    Class TupleInfo represents scaled data and is used for all "predictions". 
    Scaling is done by class Trial while "filtering".  Deltas may be  
    adjusted both by capping large ones at the soft Trial::deltaCap 
    and by DeltaScale::mapDelta(...).  The cap is applied *before* scaling. 
    The class includes a constant field for one "actual" falloff stat: 
 
    () scaledFalloff = scaledDeltas[playedMoveIndex] if playedMoveIndex < N, 
          deltaScale->mapDelta(box([unscaled Turninfo stats])) otherwise.  So 
       scaledFalloff = deltaScale->mapDelta(source->deltaFalloff) in all cases. 
 
 
    The falloffFix is used much more actively to compute the /predicted/ stats: 
    () scaledFalloff.projectedValue = falloff using the scaled deltas, 
    () unscaledFalloff.projectedValue = applies deltaCap but not the scale, and hence 
       is the "pred" of TurnInfo::deltaFalloffCapped.   
    Thus the soft Trial::deltaCap is regarded as a feature of the data, while 
    the DeltaScale is not.  A contributing reason is that the soft cap value 
    may later be used to make engines more efficient while gathering data. 
    Clear as mud? 
 */ 
     
 
 
 
/** Raw Data pertaining to a game turn.  Not acted on directly---rather, 
    information is "filtered" and scaled when translating to a DecisionInfo 
    object.  NOT Catalogable---these classes want to be non-virtual and fast. 
    Indeed, perhaps I should de-virtualize the destructor and operator string; 
    this class would be "sealed" in C# lingo. 
 
    Constructed ONLY by Ensemble::readInputFile(istream& file). 
    INV: is legal at construction.

    ** Evals are in centipawn (int) units and from White's view unless otherwise said. **

    Most pathological case: some Rybka turns with eval outside -3.00..+3.00
    have just the depth-1 eval, for 1 move, owing to Rybka "jackrabbiting".
    It is AOK on these turns to consider that value as applying to all moves
    at all depths.  The lo..hi "window" setting will fill those values in,
    helped by the "n.a."-->IRutil::NAVAL values read and recorded here.
 */ 

/** TAMAL: Right now, this class is not fast, rather it consists of all the raw information
regarding the move.  It stores all the information of any particular turn for all the depths.
 */ 

class TurnInfo { 
 public: 
   const GameInfo* pGameInfo;    //AIF parent game or parent EPD file
   const int turnLowestDepth, turnHighestDepth; // = range of depths of AIF parent (game).
                       //Might be larger than the data actually read.
                       //Could be different for different turns?  Superseded by "infer"
   TurnInfo* prevTurn;  //do not delete---GameInfo manages
   TurnInfo* nextTurn;  //set from outside
   const string gameID;
   const string engineID;
   const int turnNumber; 
   const bool whiteToMove; 
   Move movePlayed;       //not const since set in ctor body
   Move engineMove;  
   const int currEvalCP;  //current evaluation in centipawns, from White's view
   const int prevEvalCP;  //eval of previous turn in game (opponent's), or NA
   const int nextEvalCP;  //eval of next turn in game, or NA if none
   const int turnFalloffCP;  //from player's view, i.e., nonnegative.
   //const int depth;
   const int nodeCount;
   const string fenCurrentPos;
   const int fiftyMR;
   const int repeatCount;
   const vector<Move>* repMoves;
   const vector<Move>* rep2Moves;
   const string repLine2;
   const size_t numLegalMoves;
   vector<Move>* legalMoves;       

   /** Evaluations read from AIF file in row-major order, in centipawns.
       Inner vector over depths indexed [lowestDepth .. highestDepth]
       Outer vector indexed [0 .. numLegalMoves-1].  All from White's view.
                     */
   vector <vector<int> >* depthEvalsCP; //mutable?, indexed from 0, use AIFoffset
   
   //Derived fields---some given, others adjusted later
   const int playedMoveIndex; 
   bool inRep;    //allows over-arching reason to exclude a move
   const bool firstLineMatch; 
   const bool eqTopMatch; 
   const int rawAD; //stored as 'n.a.' in AIF 
   const int srandSeed;     //fixed at construction, used to make sure the 
                            //"same" permutation is used each time the 
                            //corresponding scaled tuple is rebuilt. 
   //const int minDepthWithValue;  //1-based
   //const int maxDepthWithValue;
   const int numDepths;
   const size_t numConsideredMoves;        // ideally >= min(numPV,numLegalMoves)
   const vector<Move>* consideredMoves;          //ordered by engine at highest depth
   vector<Move>* bestMoveByDepth;  //filled in later
   vector<int>* bestEvalCPByDepth;           //again, from White's view 
   vector<int>* worstRecordedEvalCPByDepth;  //for use in m-PV mode, m = 10 or 20 or more

 
   TurnInfo(const GameInfo* pGmInfo, const int tlo, const int thi,
            const string& gid, const string& eid, const int tNumber, const bool wtm,
            const string& plydMove, const string& engMove, //const string& pmlan, const string& emlan,
            const int curEval, const int preEval, const int nexEval,
            const int d, const int nc,  const string& fenCurrPos, const int fmr,
            const int repCount, const vector<Move>* rm1, const string& rl2, 
            const size_t numLegalMov, const string& legMoves,
            const vector<Move>* cmv, vector<vector<int> >* devals,  //INV: parallel order
            const int playedMoveInd, bool extraRepeatFlag = false) 
    : pGameInfo(pGmInfo)
    , turnLowestDepth(tlo)
    , turnHighestDepth(thi)
    , prevTurn(NULL)
    , nextTurn(NULL)  //set from outside
    , gameID(gid)
    , engineID(eid)
    , turnNumber(tNumber)
    , whiteToMove(wtm)
    , movePlayed(Move())
    , engineMove(Move())
    , currEvalCP(curEval)
    , prevEvalCP(preEval)
    , nextEvalCP(nexEval)
      //turnFalloffCP(wtm ? curEval - nexEval : nexEval - curEval),
    , turnFalloffCP(fabs(curEval - nexEval))
    //, depth(d)
    , nodeCount(nc), fenCurrentPos(fenCurrPos), fiftyMR(fmr)
    , repeatCount(repCount), repMoves(rm1), rep2Moves(new vector<Move>()), repLine2(rl2)
    , numLegalMoves(numLegalMov)
    , legalMoves(new vector<Move>())
    , depthEvalsCP(devals)
    , playedMoveIndex(playedMoveInd)
    , inRep(extraRepeatFlag)
    , firstLineMatch(playedMoveInd == 0)
    , eqTopMatch(playedMoveInd < devals->size() && devals->at(playedMoveInd).at(thi-1) == curEval)  //use hi2 derived depth?
    , rawAD(wtm ? max(curEval-nexEval,0) : max(nexEval-curEval,0))
    , srandSeed(rand())
    //, minDepthWithValue(1), maxDepthWithValue(d)
    , numDepths(d) //can be greater than turnHighestDepth
    , numConsideredMoves(cmv->size())
    , consideredMoves(cmv) //bestMoveByDepth(new vector<Move>()),
    , bestMoveByDepth(new vector<Move>(d,Move()))
    , bestEvalCPByDepth(new vector<int>(d,IRutil::NAVAL))
    , worstRecordedEvalCPByDepth(new vector<int>(d,IRutil::NAVAL))
   { 
//cerr << "@";
      string lm = legMoves;
      while (lm.find(',') != string::npos) {
         lm.replace(lm.find(','), 1, " ");
      }
      istringstream iss(lm);
      string mv;
      Position pos(fenCurrPos);
      while (iss >> mv) {
         legalMoves->push_back(Move(pos.move2TAN(mv)));
      }
      if (legalMoves->size() != numLegalMov) {
         cerr << "Legal Move miscount: " << legalMoves->size() << " of "
              << numLegalMov << " loaded in turn" << endl << fenCurrPos << endl
              << "from " << legMoves << endl;
      }
      movePlayed.setTAN(pos.move2TAN(plydMove));
      engineMove.setTAN(pos.move2TAN(engMove));

      for (size_t d = tlo; d <= numDepths; d++) {  //absolute depths, leave defaults for d < tlo
         int btm = (whiteToMove ? 1 : -1);
         int bestEvalCPPTM = -IRutil::MATEVALCP;  //PTM = from player perspective
         int worstEvalCPPTM = IRutil::MATEVALCP;
         int i = 0;
         size_t useDepth = (d > thi ? thi : d);
         Move bestMove;
         while (i < numConsideredMoves) {
            int wtmEval = getEvalCP(i,useDepth);
            if (wtmEval != IRutil::PRUNVAL && wtmEval != IRutil::NAVAL
                && wtmEval != IRutil::NRECVAL) {
               int ptmEval = btm*wtmEval;
               if (ptmEval > bestEvalCPPTM) {
                  bestEvalCPPTM = ptmEval;
                  bestMove = cmv->at(i);
               } 
               if (ptmEval < worstEvalCPPTM) {
                  worstEvalCPPTM = ptmEval;
               }
            }
            i++;
         }
         if (bestEvalCPPTM == -IRutil::MATEVALCP) { bestEvalCPPTM = IRutil::NAVAL; }
         if (worstEvalCPPTM == IRutil::MATEVALCP) { worstEvalCPPTM = IRutil::NAVAL; }
         bestMoveByDepth->at(d-IRutil::AIFoffset) = bestMove;
         bestEvalCPByDepth->at(d-IRutil::AIFoffset) = btm*bestEvalCPPTM;  //back to White view
         worstRecordedEvalCPByDepth->at(d-IRutil::AIFoffset) = btm*worstEvalCPPTM;
         
      }
   } 
 
   virtual ~TurnInfo() { 
      delete(depthEvalsCP); //OK since value matrix
      delete(legalMoves);
      delete(consideredMoves);
      delete(repMoves);
      delete(rep2Moves);
      delete(bestMoveByDepth);
      delete(bestEvalCPByDepth);
      delete(worstRecordedEvalCPByDepth);
   }

   int getEvalCP(size_t i, size_t d) const {  //REQ indices in range: Caller guards
      return depthEvalsCP->at(i).at(d-IRutil::AIFoffset); //CAN return NAVAL etc.
   } 

   int findEvalCP(size_t i, size_t d) const {  //REQ: i in range, will fudge d, not used
      size_t s = depthEvalsCP->at(i).size();
      if (d > s) { d = s; }
      int evalCP = depthEvalsCP->at(i).at(d-IRutil::AIFoffset);
      while (evalCP >= IRutil::NAVAL && d != 6) {
         d = (d < 6 ? d+1 : d-1);   //!!! 6 is a magic # here
         evalCP = depthEvalsCP->at(i).at(d-IRutil::AIFoffset);
      }
      return evalCP;
   }

   int getBestEvalCPAtDepth(size_t d) const {  //treats d as absolute and sub-data depths as NA
      if (d > turnHighestDepth) { d = turnHighestDepth; }
      if (d < turnLowestDepth) { return IRutil::NAVAL; }
      return bestEvalCPByDepth->at(d-IRutil::AIFoffset);
   }

   double getRawSwingCPPTM(size_t i, size_t D, bool normalize) const {  //always from player perspective
      int swingCP = 0;
      int btm = (whiteToMove ? 1 : -1);
      size_t targetDepth = (D > turnHighestDepth ? turnHighestDepth : D);
      int topDelta = btm*(getBestEvalCPAtDepth(targetDepth) - getEvalCP(i, targetDepth));
      for (size_t d = turnLowestDepth; d < targetDepth; d++) {  //d = D skipped
         swingCP += btm*(getBestEvalCPAtDepth(d) - getEvalCP(i, d)) - topDelta;
      }
      return (normalize ? swingCP/double(targetDepth - turnLowestDepth) : swingCP);
   }
         
   void setRep(bool isRep) { inRep = isRep; }

   string getDepthEvalCPstr() const {
      string depthEvalInfo = "";
      string st;
      for( int i = 0; i< depthEvalsCP->size() ; i++) {
         vector<int> moveEvals = depthEvalsCP->at(i);
         string mv = (i < consideredMoves->size() ? consideredMoves->at(i).TAN2SAN() : "???");
         string pad = "     ";
         depthEvalInfo += mv + pad.substr(min(mv.length(),pad.length()));
         for( int j = 0; j < moveEvals.size() ; j++) {
            if (moveEvals.at(j) < IRutil::NAVAL) {
               st =  IRutil::itoa(moveEvals.at(j),5);
            } else {
               st = "?????";
               st = (moveEvals.at(j) == IRutil::NAVAL) ? " n.a." : st;
               st = (moveEvals.at(j) == IRutil::PRUNVAL) ? " PRUN" : st;
               st = (moveEvals.at(j) == IRutil::NRECVAL) ? " NREC" : st;
            }
            depthEvalInfo += st + " ";
         }
         depthEvalInfo += "\n";
      }
      return depthEvalInfo;
   }

   string getFEN() const { return IRutil::trim(fenCurrentPos); }
 
   bool match() { return (engineMove == movePlayed); }
   bool topMatch() {
      return match() || (whiteToMove ? (turnFalloffCP <= 0) : (turnFalloffCP >= 0)); 
   }

   operator string() const { 
   //note: Black moves already include "..." as part of them 
       
      string line1 = pGameInfo->whitePlayer 
            + " - " + pGameInfo->blackPlayer
            + ", " + pGameInfo->eventName + ", " + string(pGameInfo->date) 
            + " : " + pGameInfo->engineID; 
      string line2 = "Played move: " + string(movePlayed) + ", index " + IRutil::itoa(playedMoveIndex);
      string line3 = "Engine move: " + IRutil::itoa(turnNumber) + ". " 
            + string(engineMove) + ", considered " + IRutil::itoa(numConsideredMoves);
      string line4 = "Eval end-" + IRutil::itoa(turnHighestDepth) + ": " //maxDepthWithValue) + ": "  
            + IRutil::ftoa(currEvalCP/double(100),2) + "  (previously " 
            + IRutil::ftoa(prevEvalCP/double(100),2) + ")"; 
      // 
      string line5 = getDepthEvalCPstr();

      return line1 + "\n" + line2 + "\n" + line3 + "\n" + line4 + "\n" + line5; 
   } 
 
   string toString() const { return string(*this); }

   bool operator<(const TurnInfo& rhs) const { return getFEN() < rhs.getFEN(); }

   
}; 
 
 
 
#endif    //end of #ifndef __IR_TURN_INFO_H__ 
 
 
 
 
//File--------------------------TupleInfo.h--------------------------------- 
 
#ifndef __IR_TUPLE_INFO_H__ 
#define __IR_TUPLE_INFO_H__ 

static int tuplesMade = 0;
static int tuplesDeleted = 0;

enum APPLICATION_POLICIES {
   NO_SWING,
   JOIN_ABS,   //absolute swing, ditto LINK and SEPARATE and PROXY
   JOIN_REL1,
   JOIN_REL2,
   JOIN_REL3,
   LINK_ABS,
   LINK_REL1,
   LINK_REL2,
   LINK_REL3,
   SEPARATE_ABS,
   SEPARATE_REL1,
   SEPARATE_REL2,
   SEPARATE_REL3,
   PROXY_ABS,
   PROXY_REL1,
   PROXY_REL2,
   PROXY_REL3,
   NUM_APPLICATION_POLICIES
};

static map<APPLICATION_POLICIES,string> policyNames;
static void initPolicyNames() {
   policyNames[NO_SWING] = "noSwing";
   policyNames[JOIN_ABS] = "joinAbs";
   policyNames[JOIN_REL1] = "joinRel1";
   policyNames[JOIN_REL2] = "joinRel2";
   policyNames[JOIN_REL3] = "joinRel3";
   policyNames[LINK_ABS] = "linkAbs";
   policyNames[LINK_REL1] = "linkRel1";
   policyNames[LINK_REL2] = "linkRel2";
   policyNames[LINK_REL3] = "linkRel3";
   policyNames[SEPARATE_ABS] = "sepAbs";
   policyNames[SEPARATE_REL1] = "sepRel1";
   policyNames[SEPARATE_REL2] = "sepRel2";
   policyNames[SEPARATE_REL3] = "sepRel3";
   policyNames[PROXY_ABS] = "proxyAbs";
   policyNames[PROXY_REL1] = "proxyRel1";
   policyNames[PROXY_REL2] = "proxyRel2";
   policyNames[PROXY_REL3] = "proxyRel3";
}


enum SWING_OPTIONS {
   GO_SWING,
   NO_SWING_TERM,
   JOIN_TERMS,
   LINK_TERMS,
   SEPARATE_TERMS,
   APPLY_TO_PROXY,
   ABS_SWING,
   REL1_SWING,
   REL2_SWING,
   REL3_SWING,
   COUPLE_PARAMS,
   DECOUPLE_PARAMS,
   DEPTH_WTD,
   UNSCALED_SWING,
   SCALED_SWING,
   SIMPLE,
   PROPORTIONAL,
   DAMPED,
   BOXED,
   BOXED_OPTION,
   SCALE_HERE,
   TRANS_POWER,       //logistic translation of left-hand side
   NUM_SWING_OPTIONS
};

static APPLICATION_POLICIES combinePolicies(SWING_OPTIONS pol1, SWING_OPTIONS pol2) {
   switch(pol1) {
    case NO_SWING_TERM:
      return NO_SWING;
    case JOIN_TERMS:
      switch(pol2) {
       case ABS_SWING:
         return JOIN_ABS;
       case REL1_SWING:
         return JOIN_REL1;
       case REL2_SWING:
         return JOIN_REL2;
       case REL3_SWING:
         return JOIN_REL3;
       default:
         return JOIN_ABS;
      }
    case LINK_TERMS:
      switch(pol2) {
       case ABS_SWING:
         return LINK_ABS;
       case REL1_SWING:
         return LINK_REL1;
       case REL2_SWING:
         return LINK_REL2;
       case REL3_SWING:
         return LINK_REL3;
       default:
         return LINK_ABS;
      }
    case SEPARATE_TERMS:
      switch(pol2) {
       case ABS_SWING:
         return SEPARATE_ABS;
       case REL1_SWING:
         return SEPARATE_REL1;
       case REL2_SWING:
         return SEPARATE_REL2;
       case REL3_SWING:
         return SEPARATE_REL3;
       default:
         return SEPARATE_ABS;
      }
    case APPLY_TO_PROXY:
      switch(pol2) {
       case ABS_SWING:
         return PROXY_ABS;
       case REL1_SWING:
         return PROXY_REL1;
       case REL2_SWING:
         return PROXY_REL2;
       case REL3_SWING:
         return PROXY_REL3;
       default:
         return PROXY_ABS;
      }
    default:
      return NO_SWING;
   }
   cerr << "Unrecognized outer option, returning noSwing..." << endl;
   return NO_SWING;
}


struct SwingInfo {
   map<APPLICATION_POLICIES,double> swingBook;
   bool noSwing;
   bool depthDependentSwings;
   bool unscaledSwings;
   bool damped;
   bool prop;
   bool boxed;
   size_t boxKind;
   bool decouple;
   bool scaleHere;
   double transPower; //a in power p1^{(1 + a(1 - u_i))/u_i)}

   SwingInfo(map<APPLICATION_POLICIES,double> sb, bool dds, bool uss,
             bool da, bool pr, bool bo, size_t bk, bool dec, bool sch, double tp)
    : swingBook(sb), noSwing(sb.empty()), depthDependentSwings(dds), unscaledSwings(uss),
      damped(da), prop(pr), boxed(bo), boxKind(bk), decouple(dec), scaleHere(sch), transPower(tp)
   { }

   bool separates() const {
      map<APPLICATION_POLICIES,double>::const_iterator swie = swingBook.end();
      return (swingBook.find(SEPARATE_ABS) != swie || swingBook.find(SEPARATE_REL1) != swie
              || swingBook.find(SEPARATE_REL2) != swie || swingBook.find(SEPARATE_REL3) != swie);
   }

   operator string() const { 
      string str = "";
      map<APPLICATION_POLICIES,double>::const_iterator swbb = swingBook.begin();
      map<APPLICATION_POLICIES,double>::const_iterator swbe = swingBook.end();
      while (swbb != swbe) {
         str += "("+policyNames[swbb->first]+":"+IRutil::ftoa(swbb->second)+")";
         ++swbb;
      }
      str += (damped ? ",damped" : (prop ? ",prop" : (boxed ? ",boxed"+IRutil::itoa(boxKind) : ",simple")));
      if (unscaledSwings) { str += ",unscaled"; }
      if (decouple) { str += ";decouple"; }
      if (scaleHere) { str += ",scalesHere"; }
      if (transPower != 0.0) { str += ",tpwr " + IRutil::ftoa(transPower); }
      return str;
   }
      
};
   
   

struct CurveApplication {
   vector<double> values;
   size_t swapIndex;
   explicit CurveApplication(size_t numIndices = 0)
    : values(vector<double>(numIndices,0.0)), swapIndex(0)
   { }
};
   
 
/** A TupleInfo object is constructed ONLY by DecisionInfo::makeTuple.
    Tupleinfo stores the most pertinent information for projecting 
    probabilities.
    This is triggered by the class Trial. In this operation, the "deltas" 
    may be scaled from their "raw" values according to a DeltaScale object, 
    and scaledFalloff may be scaled similarly---but only at construction, 
    as signified by "const" on these fields.  This class needs speed and 
    should not be extended ("final" in Java, "sealed" in C#)---it has a  
    non-virtual destructor even though it *is* deleted via pointers. 
    More simply put, these structs are READ-ONLY---except that  
    TurnInfo::turnFalloff would be coded by /single-assignment/. 

    TODO: split off non-ephemerals into SwingInfo
 */ 
class TupleInfo { 
 
 public: 

   const TurnInfo* pTurn;                      //used only for diagnostics
   const vector<double>* const pScaledDeltas;  //shared? actually not...
   const vector<double>* moveSwings;           //passed to MoveProjection
   SwingInfo* swingPolicy;

   bool swingsWereSetNew;                  //notification not policy, true if reset

   const double evalPTM;                       //overall or perceived, player's perspective
   const int playedMoveIndex; 
   const int numDeltas; 
   const int altPlayedMoveIndex;               //used in event of shuffling equal-top moves
   const bool useAltPlayedMoveIndex; 
   const bool patchesProbs; 
   const double patchPower;

   const int doAltPlayedMoveIndex() {          //random shuffle of equal-top order
      int apmi; 
      int pmiLeft = playedMoveIndex - 1;  //should be on first occurrence 
      int pmiRight = playedMoveIndex + 1; //past-end 
      double pmd = pScaledDeltas->at(playedMoveIndex); 
      while (pmiLeft >= 0 && pScaledDeltas->at(pmiLeft) == pmd) { pmiLeft--; } 
      while (pmiRight < pScaledDeltas->size() 
                   && pScaledDeltas->at(pmiRight) == pmd) {  
         pmiRight++;  
      } 
      pmiLeft++;   //to put back on first tied value 
      apmi = pmiLeft + (IRutil::myRand(0,pmiLeft - pmiRight)); 
      return apmi; 
   } 
 
   TupleInfo(const TurnInfo* pt, const vector<double>* givenDeltas,
             const vector<double>* givenSwings, 
             SwingInfo* swp,
             double givenEval, int givenPlayedMoveIndex, bool ua, bool pp,
             const double ppwr) 
    : pTurn(pt)
    , pScaledDeltas(givenDeltas)
    , moveSwings(givenSwings)     //can be NULL  --?
    , swingPolicy(swp)
    , swingsWereSetNew(false)
    , evalPTM(givenEval)
    , playedMoveIndex(givenPlayedMoveIndex)
    , numDeltas(givenDeltas->size())
    , altPlayedMoveIndex(0)  //(doAltPlayedMoveIndex())
    , useAltPlayedMoveIndex(ua)
    , patchesProbs(pp)
    , patchPower(ppwr)
   { 
      tuplesMade++;
      if (tuplesMade % IRutil::TUPLEMODULUS == 0) {
         cerr << tuplesMade << " tuples made, " << tuplesDeleted
              << " deleted." << endl;
      } 
   }
 
   double getDelta(int index) {      //note: call on an unscaled TupleInfo for unscaled version
      return pScaledDeltas->at(index); 
   } 
   
   void setSwings(const vector<double>* newSwings) { 
      //swingPolicy->depthDependentSwings = true;
      swingsWereSetNew = true;
      moveSwings = newSwings;
   }
 
   ~TupleInfo() {  
      delete(pScaledDeltas);
      //if (swingsWereSetNew) { delete(moveSwings); }
      tuplesDeleted++;
      if (tuplesDeleted % IRutil::TUPLEMODULUS == 0) {
         cerr << tuplesDeleted << " tuples deleted, " << tuplesMade 
              << " tuples made." << endl;
      }
   } 
 
   int getPlayedMoveIndex() const { 
      return useAltPlayedMoveIndex ? altPlayedMoveIndex  
                                   : playedMoveIndex; 
   } 
 
 
   /** The $64,000 place where model parameters are reflected, aside from the
       possible and deferred impact of ts.d and ts.v on the weighting of depths.
       The other parameters behave in the following ways under different policies:

        s ("sensitivity") always divides eval-difference and swing values in centipawns.
        c ("consistency") is the main exponent of eval-difference and swing values.
        a ("slack power") is a supplementary power on the swing(-difference) values alone.
                          It can be tied to c by fixing it to be 1.0.
       hm ("heave minus") gauges extra reactivity when the eval or swing is negative.
                          It can be tied to s by fixing it to be 1.0.
       hp ("heave plus")  gauges extra reactivity when the eval or swing is positive.
                          It can be tied to hm by fixing it to be 1.0.
        b ("heave slack") is additive when heave multiplies delta, and otherwise 
                          supplements a's power on positive swing.  
                          It can be tied to a by fixing it to be 1.0.

       Thus fixing all of a,hm,hp,b = 1.0 makes s and c alone govern swing (aside from d and v).
       Tying hp to hm enables hm to control the reaction to swing in general.
       The swing sw1 of the first move at the judgment depth can never be negative.
       Observations show that the first 8-12 moves have positive swing on average.
       When sw1 is subtracted off to make "relative" swing, however, all moves after the first
       have negative swing on average.  (Moves tied for equal-top value are a notable exception.)
       Hence hm is used as the primary swing multiplier when swing is tied, and the multiplier
       on positive swing is hp*hm*swing not just hp*swing.

       Sign convention: in (hm*swing)^a, hm itself is >= 0, and when swing is < 0, the value
                        is -(hm*|swing|)^a.

       By definition an optimal move at the judgment depth cannot have negative swing, so it can
       never appear "more probable" than the pre-swing indication, only "less probable."
       It is however possible that the -(hm*|swing|)^a term for a move of negative swing can
       make the overall argument negative.  It is also common that positive swing may render
       all of the arguments positive.  The same adjustment is applied in both cases:
       the least or most-negative argument "minArg" is subtracted from every argument.

       Here are the behaviors when either (i) "scale" appears in swingPolicy, or (ii) not.
       
       --------------------------------------------------------------------------------

       Situation (i): This adjustmewnt is intended to be used with NoScaling or with UnitLineScale.  
       It is applied primarily to delta, and can be applied to swing either after the
       (unscaled) swing is joined to the (unscaled) delta, or separately.

       The governing observation is that (depending on the skill/Elo of the sample), there
       are values em,hp,b > 0 such that as a function of the eval x for the player to move,
       the average delta per move over positions of eval x closely obeys these linear relations:

          avgdelta(x) = b + ep*|x|     if x > 0
          avgdelta(x) = b + em*|x|     if x <= 0

       Much like stabilizing a heaving ship, the model behaves better if the ramping up of
       error with x is flattened out by scaling delta->delta' so that (at least approximately)
     
          avgdelta'(x) = b

       regardless of x.  This is done for x > 0 by multiplying delta' = H*delta where
       H is either H' or H" according as whether the eval is negative or positive:

          H'  =  1/(1 + (em/b)x)  =  b/(b + em*x)  =  1 - em*x/(b + em*x),
          H"  =  1/(1 + (ep/b)x)  =  b/(b + ep*x)  =  1 - ep*x/(b + ep*x).

       If ep/b stayed constant, ditto em/b, then this would be something to fix rather than fit
       according to rating/skill level.  Unfortunately(?), it does not stay constant.  Hence we
       fit these quantities: em == hm, and ep == hm*hp.  The latter looks weird but allows tying.
       The formulas by various swing policies---recall the convention on powers of negative numbers:

       Absolute Swing:
       Join:  Form z = (delta + swing^a)/(1 + (hm/b)*eval)     if eval < 0;
                     = (delta + swing^a)                       if eval = 0;
                     = (delta - swing^a)/(1 + (hm*hp/b)*eval)  if eval > 0.
              Then apply Curve(z,s,c).  (Not necessarily dimensionally correct in swing^a)

       Link:  Form z = (delta/s + (swing/s)^a)/(1 + (hm/b)*eval)     if eval < 0;
                     = (delta/s + (swing/s)^a)                       if eval = 0;
                     = (delta/s - (swing/s)^a)/(1 + (hm*hp/b)*eval)  if eval > 0.
              Then apply Curve(z,1,c).
              
       Sep:   Form delta' = delta/(1 + (hm/b)*eval)            if eval < 0;
                          = delta                              if eval = 0;
                          = delta/(1 + (hp*hm/b)*eval)         if eval > 0;
                   swing' = swing/(1 + (hm/b)*eval)            if eval < 0;
                          = swing                              if eval = 0;
                          = swing/(1 + (hp*hm/b)*eval)         if eval > 0;

              Then form z = (delta'/s)^c + (swing'/s)^{ac}
              and apply Curve(z,1,1).

       Proxy: Form delta' and swing' as in Sep and form z = (delta'/s)^c.  
              Apply u = Curve(z,1,1).  
              Then form u' = u + (swing'/s)^{ac}.  Keep track of minProxy over all j,
              and subtract it off for each j to get the final proxies.


       Relative Swing: Replace swing by swing(j) - swing(ifm) in the above, where
       ifm is the index of the first move at the judgment depth.

       ----------------------------------------------------------------------------------

       Description of situation (ii): This assumes delta has already been scaled and that
       swing is using the scaled deltas, so that hm,hp become multipliers of swing and
       b becomes a compounded power over a.  Again the terms hp*hm/s and a*b*c facilitate tying.
       When s and c are outermost the 3-place curve is applied, else Curve(z,1,1).
       
       Absolute Swing:
       Join:     z = delta - (hm*|swing|)^a      if swing < 0;  
                   = delta                       if swing = 0;
                 z = delta + (hp*hm*swing)^{ab}  if swing > 0.
                 Then apply Curve(z,s,c).

       Link:     z = delta/s - (hm*|swing|/s)^a      if swing < 0;
                   = delta/s                         if swing = 0;
                 z = delta/s + (hp*hm*swing/s)^{ab}  if swing > 0.
                 Then apply Curve(z,1,c).

       Separate: z = (delta/s)^c - (hm*|swing|/s)^{ac}    if swing < 0;
                   = (delta/s)^c                          if swing = 0;
                   = (delta/s)^c + (hp*hm*swing/s)^{abc}  if swing > 0.
                 Then apply Curve(z,1,1).

       Proxy:    u  = Curve(delta,s,c) as in the plain (non-swing) model.  Then define
                 u' = u - (hm*|swing|/s)^{ac}       if swing < 0;
                 u' = u                             if swing = 0;
                 u' = u + (hp*hm*swing/s)^{abc}     if swing > 0.
                 As above, subtract off minProxy from each u' = u'(j) so that one is 0.0.

       Relative Swing: 
       For each move j, define swing'(j) = swing(j) - sw1, 
       where sw1 is the swing of the first move at the judgment depth.  As noted above,
       (*) sw1 >= 0 always.
       (*) on average swing'(j) is < 0 for other moves j, but can be > 0 individually.
       Hence believe-it-or-else there is a further breakdown according to whether the
       plus/minus reckoning is applied to swing'(j) on the whole or to its parts, and
       whether this is done before or after powering.  We expand swing' back into its
       parts and omit the easily-inferred swing=0 cases in the cornucopia that follows.
       We also rely more on the power convention for negative arguments.
       Note that sw1 when isolated is always multiplied by hp*hm since it is nonnegative.
       

       Join1:   z = delta + (hm*swing - hm*sw1)^a                     if swing - sw1 <= 0;
                  = delta + (hp*hm*swing - hp*hm*sw1)^{ab}            if swing - sw1 > 0;

       Join2:   z = delta + (hm*swing - hp*hm*sw1)^a                  if swing <= 0;
                  = delta + (hp*hm*swing - hp*hm*sw1)^{ab}            if swing > 0;

       Join3:   z = delta + (hm*swing)^a - (hp*hm*sw1)^{ab}           if swing <= 0;
                  = delta + (hp*hm*swing)^{ab} - (hp*hm*sw1)^{ab}     if swing > 0. 

       Link1:   z = delta/s + ((hm*swing - hm*sw1)/s)^a                     if swing - sw1 <= 0;
                  = delta/s + ((hp*hm*swing - hp*hm*sw1)/s)^{ab}            if swing - sw1 > 0;

       Link2:   z = delta/s + ((hm*swing - hp*hm*sw1)/s)^a                  if swing <= 0;
                  = delta/s + ((hp*hm*swing - hp*hm*sw1)/s)^{ab}            if swing > 0;

       Link3:   z = delta/s + (hm*swing/s)^a - (hp*hm*sw1/s)^{ab}           if swing <= 0;
                  = delta/s + (hp*hm*swing/s)^{ab} - (hp*hm*sw1/s)^{ab}     if swing > 0.

       Sep1:    z = (delta/s)^c + ((hm*swing - hm*sw1)/s)^{ac}           if swing - sw1 <= 0;
                  = (delta/s)^c + ((hp*hm*swing - hp*hm*sw1)/s)^{abc}    if swing - sw1 > 0;

       Sep2:    z = (delta/s)^c + ((hm*swing - hp*hm*sw1)/s)^{ac}              if swing <= 0;
                  = (delta/s)^c + ((hp*hm*swing - hp*hm*sw1)/s)^{abc}          if swing > 0;

       Sep3:    z = (delta/s)^c + (hm*swing/s)^{ac} - (hp*hm*sw1/s)^{abc}      if swing <= 0;
                  = (delta/s)^c + (hp*hm*swing/s)^{abc} - (hp*hm*sw1/s)^{abc}  if swing > 0;

       Proxy1:  u' = u + ((hm*swing - hm*sw1)/s)^{ac}                 if swing - sw1 <= 0;
                   = u + ((hp*hm*swing - hp*hm*sw1)/s)^{abc}          if swing - sw1 > 0;

       Proxy2:  u' = u + ((hm*swing - hp*hm*sw1)/s)^{ac}              if swing <= 0;
                   = u + ((hp*hm*swing - hp*hm*sw1)/s)^{abc}          if swing > 0;

       Proxy3:  u' = u + (hm*swing/s)^{ac} - (hp*hm*sw1/s)^{abc}      if swing <= 0;
                u' = u + (hp*hm*swing/s)^{abc} - (hp*hm*sw1/s)^{abc}  if swing > 0.

    */

   void accumeCurve3(const TrialSpec& ts, const vector<double>& args,
                     const double mul, CurveApplication* cap) const {
      double minArg = IRutil::MATEVAL;
      for (int j = 0; j < numDeltas; j++) {
         if (args.at(j) < minArg) {
            //minIndex = j;
            minArg = args.at(j);
         }
      }
      for (int j = 0; j < numDeltas; j++) {
         double dp = args.at(j) - minArg;
         if (dp >= 0.0) {
            cap->values.at(j) += mul*ts.mevalCurves3(dp,ts.s,ts.c);
         } else {   //means NAN value or etc.
/*
            string fen = pTurn->getFEN();
            if (IRutil::PROBLEM_FENS.find(fen) == IRutil::PROBLEM_FENS.end()) {
               IRutil::PROBLEM_FENS.insert(fen);
               IRutil::PROBLEM_GAMES.insert(pTurn->gameID + "\n" + fen);
               cerr << "Bad tuple value[" << j << "] = " << dp << " in\n" << string(*this) << endl
                    //<< "from turn" << endl << string(*pTurn) << endl;
                    << "args.at(j) = " << args.at(j) << ", minArg = " << minArg << endl
                    << "from game " << pTurn->gameID << endl
                    << "@position " << pTurn->getFEN() << endl;
            }
*/
            cap->values.at(j) += 0.0;   //i.e., do nothing
         } 
      }
   }

   void accumeCurve2(const TrialSpec& ts, const vector<double>& args,
                     const double mul, CurveApplication* cap) const {
      double minArg = IRutil::MATEVAL;
      for (int j = 0; j < numDeltas; j++) {
         if (args.at(j) < minArg) {
            //minIndex = j;
            minArg = args.at(j);
         }
      }
      for (int j = 0; j < numDeltas; j++) {
         double dp = args.at(j) - minArg;
         if (dp >= 0.0) {
            cap->values.at(j) += mul*ts.mevalCurves2(dp,ts.c);
         } else {   //means NAN value or etc.
/*
            string fen = pTurn->getFEN();
            if (IRutil::PROBLEM_FENS.find(fen) == IRutil::PROBLEM_FENS.end()) {
               IRutil::PROBLEM_FENS.insert(fen);
               IRutil::PROBLEM_GAMES.insert(pTurn->gameID + "\n" + fen);
               cerr << "Bad tuple value[" << j << "] = " << dp << " in\n" << string(*this) << endl
                    //<< "from turn" << endl << string(*pTurn) << endl;
                    << "args.at(j) = " << args.at(j) << ", minArg = " << minArg << endl
                    << "from game " << pTurn->gameID << endl
                    << "@position " << pTurn->getFEN() << endl;
            }
*/
            cap->values.at(j) += 0.0;
         }
      }
   }

   void accumeCurve1(const TrialSpec& ts, const vector<double>& args,
                     const double mul, CurveApplication* cap) const {
      double minArg = IRutil::MATEVAL;
      for (int j = 0; j < numDeltas; j++) {
         if (args.at(j) < minArg) {
            //minIndex = j;
            minArg = args.at(j);
         }
      }
      for (int j = 0; j < numDeltas; j++) {
         double dp = args.at(j) - minArg;
         if (dp >= 0.0) {
            cap->values.at(j) += mul*ts.mevalCurves1(dp);
         } else {   //means NAN value or etc.
/*
            string fen = pTurn->getFEN();
            if (IRutil::PROBLEM_FENS.find(fen) == IRutil::PROBLEM_FENS.end()) {
               IRutil::PROBLEM_FENS.insert(fen);
               IRutil::PROBLEM_GAMES.insert(pTurn->gameID + "\n" + fen);
               cerr << "Bad tuple value[" << j << "] = " << dp << " in\n" << string(*this) << endl
                    //<< "from turn" << endl << string(*pTurn) << endl;
                    << "args.at(j) = " << args.at(j) << ", minArg = " << minArg << endl
                    << "from game " << pTurn->gameID << endl
                    << "@position " << pTurn->getFEN() << endl;
            }
*/
            cap->values.at(j) += 0.0;
         }
      }
   }

   void finishProxies(CurveApplication* cap) const { //, const double denom) const {  //sets final minIndex
      double maxProxy = -IRutil::MATEVAL;
      size_t maxIndex = 0;
      for (int j = 0; j < numDeltas; j++) {
         //cap->values.at(j) /= denom;
         if (cap->values.at(j) > maxProxy) {
            maxProxy = cap->values.at(j);    //maxProxy cannot be > denom but can be < denom
            maxIndex = j;
         }
      }
      //if (maxIndex != cap->swapIndex) {
         //cout << "swap index changed from " << cap->swapIndex << " to " << maxIndex << endl;
      //}
      cap->swapIndex = maxIndex;
      for (int j = 0; j < numDeltas; j++) {
         cap->values.at(j) /= maxProxy;
      }
   }

   CurveApplication* applyCurve(const TrialSpec& ts) const {
      CurveApplication* cap = new CurveApplication(numDeltas); //will be accumulated
      vector<double> perceivedArgs(numDeltas);  //entries are replaced, not accumulated
      //next two used only if scaleHere
      const double evalMul = (evalPTM <= 0.0 ? (-ts.hm * evalPTM) : (ts.hm * ts.hp * evalPTM));
      const double deltaMul = 1.0 - IRutil::divifne0(evalMul, ts.b + evalMul);
      //with all these, C++ templates could speed up loops over moves with ts fixed.
      const double sw1 = moveSwings->at(0);
      const double s = (fabs(ts.s) < IRutil::MINPROB ? IRutil::MINPROB : ts.s);
      const double b = (fabs(ts.b) < IRutil::MINPROB ? IRutil::MINPROB : ts.b);
      const double s2 = (swingPolicy->decouple ? 1.0 : s);
      const double exab = (swingPolicy->decouple ? b : ts.a*b);
      const double exca = (swingPolicy->decouple ? ts.a : ts.c*ts.a);
      const double excab = (swingPolicy->decouple ? b : ts.c*ts.a*b);
      const double h2 = (swingPolicy->decouple ? ts.hp : ts.hm*ts.hp);
      double mul, dj, swj, sgnj, term1, term2;
      double denom = 0.0;
      APPLICATION_POLICIES appPolicy;

      if (!(sw1 >= 0)) {
         string fen = pTurn->getFEN();
         if (IRutil::PROBLEM_FENS.find(fen) == IRutil::PROBLEM_FENS.end()) {
            IRutil::PROBLEM_FENS.insert(fen);
            IRutil::PROBLEM_GAMES.insert(pTurn->gameID + "\n" + fen);
            cerr << "Bad sw1 " << sw1 << " in tuple " << string(*this) << endl
                 //<< "from turn" << endl << string(*pTurn) << endl;
                 << "from game " << pTurn->gameID << endl
                 << "@position " << pTurn->getFEN() << endl;
         }
      }

      if (swingPolicy->swingBook.empty()) {
         cerr << "Swing choices empty, using NO_SWING..." << endl;
         swingPolicy->swingBook[NO_SWING] = 1.0;
      }

      map<APPLICATION_POLICIES, double>::const_iterator swbit = swingPolicy->swingBook.begin();
      map<APPLICATION_POLICIES, double>::const_iterator swbite = swingPolicy->swingBook.end();
      while (swbit != swbite) {
         appPolicy = swbit->first;
         mul = swbit->second;
         denom += mul;

         switch (appPolicy) {
          case NO_SWING:
            for (int j = 0; j < numDeltas; j++) {
               perceivedArgs.at(j) = (swingPolicy->scaleHere ? pScaledDeltas->at(j)*deltaMul
                                                             : pScaledDeltas->at(j));
            }
            accumeCurve3(ts, perceivedArgs, mul, cap);
            break;
   
          case JOIN_ABS:
            if (swingPolicy->scaleHere) {
               if (evalPTM <= 0.0) {
                  for (int j = 0; j < numDeltas; j++) {
                     swj = moveSwings->at(j);
                     sgnj = (swj > 0 ? +1.0 : -1.0);
                     perceivedArgs.at(j) = (pScaledDeltas->at(j) + pow(swj*sgnj,ts.a))
                                         /(1.0 - evalPTM*ts.hm/b);
                  }
   	       } else {
                  for (int j = 0; j < numDeltas; j++) {
                     swj = moveSwings->at(j);
   		  sgnj = (swj > 0 ? +1.0 : -1.0);
   		  perceivedArgs.at(j) = (pScaledDeltas->at(j) + pow(swj*sgnj,ts.a))
                                         /(1.0 + evalPTM*h2/b);
                  }
               }
            } else {
               for (int j = 0; j < numDeltas; j++) {
                  swj = moveSwings->at(j);
                  sgnj = (swj > 0 ? +1.0 : -1.0);
                  if (swj <= 0.0) {
                     perceivedArgs.at(j) = pScaledDeltas->at(j) - pow(sgnj*swj*ts.hm, ts.a);
                  } else {
                     perceivedArgs.at(j) = pScaledDeltas->at(j) + pow(swj*h2, exab);
                  }
               }
            }
            accumeCurve3(ts, perceivedArgs, mul, cap);
            break;
   
          case JOIN_REL1:   //assume not scaling here
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj - sw1 <= 0.0 ? -1.0 : +1.0);
               if (sgnj <= 0.0) {
                  perceivedArgs.at(j) = pScaledDeltas->at(j) - pow(sgnj*(swj-sw1)*ts.hm, ts.a);
               } else {
                  perceivedArgs.at(j) = pScaledDeltas->at(j) + pow((swj-sw1)*h2, exab);
               }
            }
            accumeCurve3(ts, perceivedArgs, mul, cap);
            break;
   
          case JOIN_REL2:   //assume not scaling here
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj - ts.hp*sw1 <= 0.0 ? -1.0 : +1.0);
               if (swj <= 0.0) {
                  perceivedArgs.at(j) = pScaledDeltas->at(j) + sgnj*pow(sgnj*(ts.hm*swj - h2*sw1), ts.a);
               } else {
                  sgnj = (swj - sw1 <= 0.0 ? -1.0 : +1.0);
                  perceivedArgs.at(j) = pScaledDeltas->at(j) + sgnj*pow(sgnj*(swj-sw1)*h2, exab);
               }
            }
            accumeCurve3(ts, perceivedArgs, mul, cap);
            break;
   
          case JOIN_REL3:   //assume not scaling here
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj <= 0 ? -1.0 : +1.0);
               if (swj <= 0.0) {
                  perceivedArgs.at(j) = pScaledDeltas->at(j) 
                                      + sgnj*pow(sgnj*ts.hm*swj, ts.a)
                                      - pow(h2*sw1, exab);
               } else {
                  perceivedArgs.at(j) = pScaledDeltas->at(j)
                                      + sgnj*pow(h2*swj, exab)
                                      - pow(h2*sw1, exab);
               }
            }
            accumeCurve3(ts, perceivedArgs, mul, cap);
            break;
   
          case LINK_ABS:
            if (swingPolicy->scaleHere) {
               if (evalPTM <= 0.0) {
                  for (int j = 0; j < numDeltas; j++) {
                     swj = moveSwings->at(j);
                     sgnj = (swj > 0 ? +1.0 : -1.0);
                     perceivedArgs.at(j) = (pScaledDeltas->at(j)/s + pow(swj*sgnj/s,ts.a))
                                         /(1.0 - evalPTM*ts.hm/b);    //must be s ^ not s2
                  }
               } else {
                  for (int j = 0; j < numDeltas; j++) {
                     swj = moveSwings->at(j);
                     sgnj = (swj > 0 ? +1.0 : -1.0);
                     perceivedArgs.at(j) = (pScaledDeltas->at(j)/s + pow(swj*sgnj/s,ts.a))
                                         /(1.0 + evalPTM*h2/b);       //must be s ^ not s2
                  }
               }
            } else {
               for (int j = 0; j < numDeltas; j++) {
                  swj = moveSwings->at(j);
                  sgnj = (swj > 0 ? +1.0 : -1.0);
                  if (swj <= 0.0) {
                     perceivedArgs.at(j) = pScaledDeltas->at(j)/s - pow(sgnj*swj*ts.hm/s2, ts.a);
                  } else {
                     perceivedArgs.at(j) = pScaledDeltas->at(j)/s + pow(swj*h2/s2, exab);
                  }
               }
            }
            accumeCurve2(ts, perceivedArgs, mul, cap);
            break;
   
          case LINK_REL1:   //assume not scaling here
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj - sw1 <= 0 ? -1.0 : +1.0);
               if (sgnj <= 0.0) {
                  perceivedArgs.at(j) = pScaledDeltas->at(j)/s - pow(sgnj*(swj-sw1)*ts.hm/s2, ts.a);
               } else {
                  perceivedArgs.at(j) = pScaledDeltas->at(j)/s + pow((swj-sw1)*h2/s2, exab);
               }
            }
            accumeCurve2(ts, perceivedArgs, mul, cap);
            break;
   
          case LINK_REL2:   //assume not scaling here
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj - ts.hp*sw1 <= 0 ? -1.0 : +1.0);
               if (swj <= 0.0) {
                  perceivedArgs.at(j) = pScaledDeltas->at(j)/s 
                                           + sgnj*pow(sgnj*(ts.hm*swj - h2*sw1)/s2, ts.a);
               } else {
                  sgnj = (swj - sw1 <= 0.0 ? -1.0 : +1.0);
                  perceivedArgs.at(j) = pScaledDeltas->at(j)/s 
                                           + sgnj*pow(sgnj*(swj-sw1)*h2/s2, exab);
               }
            }
            accumeCurve2(ts, perceivedArgs, mul, cap);
            break;
   
          case LINK_REL3:   //assume not scaling here
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj <= 0.0 ? -1.0 : +1.0);
               if (sgnj <= 0.0) {
                  perceivedArgs.at(j) = pScaledDeltas->at(j)/s
                                      + sgnj*pow(sgnj*ts.hm*swj/s2, ts.a)
                                      - pow(h2*sw1/s2, exab);
               } else {
                  perceivedArgs.at(j) = pScaledDeltas->at(j)/s
                                      + sgnj*pow(h2*swj/s2, exab)
                                      - pow(h2*sw1/s2, exab);
               }
            }
            accumeCurve2(ts, perceivedArgs, mul, cap);
            break;
   
          case SEPARATE_ABS:
            if (swingPolicy->scaleHere) {
               if (evalPTM <= 0.0) {
                  for (int j = 0; j < numDeltas; j++) {
                     swj = moveSwings->at(j);
                     sgnj = (swj > 0 ? +1.0 : -1.0);
                     term1 = pScaledDeltas->at(j)/(1.0 - evalPTM*ts.hm/b);
                     term2 = sgnj*swj/(1.0 - evalPTM*ts.hm/b);
                     perceivedArgs.at(j) = pow(term1/s, ts.c) + sgnj*pow(term2/s2, exca);
                  }
               } else {
                  for (int j = 0; j < numDeltas; j++) {
                     swj = moveSwings->at(j);
                     sgnj = (swj > 0 ? +1.0 : -1.0);
                     term1 = pScaledDeltas->at(j)/(1.0 - evalPTM*h2/b);
                     term2 = sgnj*swj/(1.0 - evalPTM*h2/b);
                     perceivedArgs.at(j) = pow(term1/s, ts.c) + sgnj*pow(term2/s2, exca);
                  }
               }
            } else {
               for (int j = 0; j < numDeltas; j++) {
                  swj = moveSwings->at(j);
                  sgnj = (swj > 0 ? +1.0 : -1.0);
                  term1 = pScaledDeltas->at(j);
                  if (swj <= 0.0) {
                     term2 = ts.hm*sgnj*swj;
                     perceivedArgs.at(j) = pow(term1/s,ts.c) - pow(term2/s2, exca);
                  } else {
                     term2 = h2*swj;
                     perceivedArgs.at(j) = pow(term1/s,ts.c) + pow(term2/s2, excab);
                  }
               }
            }
            accumeCurve1(ts, perceivedArgs, mul, cap);
            break;
   
          case SEPARATE_REL1:   //assume not scaling here
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj - sw1 <= 0 ? -1.0 : +1.0);
               term1 = pScaledDeltas->at(j);
               if (sgnj <= 0.0) {
                  term2 = sgnj*ts.hm*(swj - sw1);
                  perceivedArgs.at(j) = pow(term1/s, ts.c) + sgnj*pow(term2/s2, exca);
               } else {
                  term2 = sgnj*h2*(swj - sw1);
                  perceivedArgs.at(j) = pow(term1/s, ts.c) + sgnj*pow(term2/s2, excab);
               }
            }
            accumeCurve1(ts, perceivedArgs, mul, cap);
            break;
   
          case SEPARATE_REL2:   //assume not scaling here
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj - ts.hp*sw1 <= 0 ? -1.0 : +1.0);
               term1 = pScaledDeltas->at(j);
               if (swj <= 0.0) {
                  term2 = sgnj*(ts.hm*swj - h2*sw1);
                  perceivedArgs.at(j) = pow(term1/s, ts.c) + sgnj*pow(term2/s2, exca);
               } else {
                  sgnj = (swj - sw1 <= 0.0 ? -1.0 : +1.0);
                  term2 = sgnj*h2*(swj - sw1);
                  perceivedArgs.at(j) = pow(term1/s, ts.c) + sgnj*pow(term2/s2, excab);
               }
            }
            accumeCurve1(ts, perceivedArgs, mul, cap);
            break;
   
          case SEPARATE_REL3:   //assume not scaling here
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj <= 0 ? -1.0 : +1.0);
               term1 = pScaledDeltas->at(j);
               if (swj <= 0.0) {
                  perceivedArgs.at(j) = pow(term1/s, ts.c)
                                      + sgnj*pow(sgnj*ts.hm*swj/s2, exca)
                                      - pow(h2*sw1/s2, excab);
               } else {
                  perceivedArgs.at(j) = pow(term1/s, ts.c)
                                      + pow(h2*swj/s2, excab)
                                      - pow(h2*sw1/s2, excab);
               }
            }
            accumeCurve1(ts, perceivedArgs, mul, cap);
            break;
   
          case PROXY_ABS:
            //cap = new CurveApplication(numDeltas);
            if (swingPolicy->scaleHere) {
               if (evalPTM <= 0.0) {
                  for (int j = 0; j < numDeltas; j++) {
                     term1 = pScaledDeltas->at(j)/(1.0 - evalPTM*ts.hm/b);
                     cap->values.at(j) += mul*(ts.evalCurves1(pow(term1/s,ts.c)));
                     swj = moveSwings->at(j);
                     sgnj = (swj > 0 ? +1.0 : -1.0);
                     term2 = sgnj*swj/(1.0 - evalPTM*ts.hm/b);
                     cap->values.at(j) += mul*sgnj*pow(term2/s2, exca);
                  }
               } else {
                  for (int j = 0; j < numDeltas; j++) {
                     term1 = pScaledDeltas->at(j)/(1.0 - evalPTM*h2/b);
                     cap->values.at(j) += mul*(ts.evalCurves1(pow(term1/s,ts.c)));
                     swj = moveSwings->at(j);
                     sgnj = (swj > 0 ? +1.0 : -1.0);
                     term2 = sgnj*swj/(1.0 - evalPTM*h2/b);
                     cap->values.at(j) += mul*sgnj*pow(term2/s2, exca);
                  }
               }
            } else {
               for (int j = 0; j < numDeltas; j++) {
                  swj = moveSwings->at(j);
                  sgnj = (swj > 0 ? +1.0 : -1.0);
                  term1 = pScaledDeltas->at(j);
                  cap->values.at(j) += mul*(ts.evalCurves1(pow(term1/s,ts.c)));
                  if (swj <= 0.0) {
                     term2 = ts.hm*sgnj*swj;
                     cap->values.at(j) -= mul*pow(term2/s2, exca);
                  } else {
                     term2 = h2*swj;
                     cap->values.at(j) += mul*pow(term2/s2, excab);
                  }
               }
            }
            //finishProxies(cap);
            //return cap;
            break;
   
          case PROXY_REL1:   //assume not scaling here
            //cap = new CurveApplication(numDeltas);
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj - sw1 <= 0 ? -1.0 : +1.0);
               term1 = pScaledDeltas->at(j);
               cap->values.at(j) += mul*(ts.evalCurves1(pow(term1/s,ts.c)));
               if (sgnj <= 0.0) {
                  term2 = sgnj*ts.hm*(swj - sw1);
                  cap->values.at(j) += mul*sgnj*pow(term2/s2, exca);
               } else {
                  term2 = sgnj*h2*(swj - sw1);
                  cap->values.at(j) += mul*sgnj*pow(term2/s2, excab);
               }
            }
            //finishProxies(cap);
            //return cap;
            break;
   
          case PROXY_REL2:   //assume not scaling here
            //cap = new CurveApplication(numDeltas);
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj - ts.hp*sw1 <= 0 ? -1.0 : +1.0);
               term1 = pScaledDeltas->at(j);
               cap->values.at(j) += mul*(ts.evalCurves1(pow(term1/s,ts.c)));
               if (swj <= 0.0) {
                  term2 = sgnj*(ts.hm*swj - h2*sw1);
                  cap->values.at(j) += mul*sgnj*pow(term2/s2, exca);
               } else {
                  sgnj = (swj - sw1 <= 0.0 ? -1.0 : +1.0);
                  term2 = sgnj*h2*(swj - sw1);
                  cap->values.at(j) += mul*sgnj*pow(term2/s2, excab);
               }
            }
            //finishProxies(cap);
            //return cap;
            break;
   
          case PROXY_REL3:   //assume not scaling here
            //cap = new CurveApplication(numDeltas);
            for (int j = 0; j < numDeltas; j++) {
               swj = moveSwings->at(j);
               sgnj = (swj <= 0 ? -1.0 : +1.0);
               term1 = pScaledDeltas->at(j);
               cap->values.at(j) += mul*(ts.evalCurves1(pow(term1/s,ts.c)));
               if (swj <= 0.0) {
                  cap->values.at(j) += mul*(sgnj*pow(sgnj*ts.hm*swj/s2, exca) - pow(h2*sw1/s2, excab));
               } else {
                  cap->values.at(j) += mul*(pow(h2*swj/s2, excab) - pow(h2*sw1/s2, excab));
               }
            }
            //finishProxies(cap);
            //return cap;
            break;
         }
         swbit++;
      }
      finishProxies(cap);  //, denom);
      return cap;
   }


   operator string() const { 
      string out = "";
      if (pScaledDeltas->size() == 0) {
         cerr << "Empty tuple found---error" << endl;
      } else {
         out += "EvalPTM ";
         out += IRutil::ftoa(evalPTM,2) + string(", deltas and swings used:\n");
         //out += IRutil::ftoa(pScaledDeltas->at(0),2); 
         int j = 0; 
         while (j < pScaledDeltas->size()) { 
            out += IRutil::itoa(j,2) + " ";
            out += IRutil::ftoa(pScaledDeltas->at(j),2); 
            out += " + ";
            if (j < moveSwings->size()) {
               out += IRutil::ftoa(moveSwings->at(j),3);
            } else {
               out += "NoSwing";
            }
            out += "\n";
            j++; 
         }
         //out.at(out.size()-1) = ')';
      }   
      return out;
   }

}; 
 

#endif    //end of #ifndef __IR_TUPLE_INFO_H__ 
 
 
 
//File--------------------------TurnContext.h---------------------------------

#ifndef __IR_TURN_CONTEXT_H__
#define __IR_TURN_CONTEXT_H__

/** TurnContext supplies information about the current turn needed to
    compute scaling.  It holds the current evaluation /at a given depth/,
    which may differ from the evaluation at the highest reference depth.
    It also holds the evaluations of the previous and next moves, which 
    are used for filtering and are at the perceivedDepth.
    Intended to be created on-the-fly.
    Pre-scaled evaluations are held as a.bc doubles, not as ints.
    Eval is from White's point of view.
 */

class TurnContext {        //plain old data
 public:
   string TANmove;
   string engineID;
   bool whiteToMove;
   double currEval;  //in pawn .00 not cp units, can be depth-dependent
   double prevEval;
   double nextEval;
   TurnContext(const string& smove, const string& eid, bool gwtm, double gce, double gpe, double gne)
    : TANmove(smove), engineID(eid), whiteToMove(gwtm), currEval(gce), prevEval(gpe), 
      nextEval(gne)
   { }
   operator string() const { 
      ostringstream oss;
      string wtm = whiteToMove ? "wtm" : "btm";
      oss << TANmove << ": " << currEval << ", prev: " << prevEval 
          << ", next: " << nextEval << ", " << wtm;
      return oss.str();
   }
};
   
#endif

 
//File-----------------------DeltaScales.h------------------------------------ 
 
#ifndef __IR_DELTA_SCALES_H__ 
#define __IR_DELTA_SCALES_H__ 
 
//------------------------SCALE MODIFICATION---------------------------------- 
 
 
enum DELTA_SCALES {   //parallel code with Ensemble::scalesMenu 
   NO_SCALING,        //a placeholder, also used for debugging 
   LINEAR_SCALE,      //can differ from NO_SCALING in slope and when pinned 
   MUL_SCALE,         //multiplies delta by 1/(1+cx)^pow
   MIX_SCALE,
   DIVLOG_SCALE, 
   LOG_SCALE,         //implemented as a special case of class FractalScale 
   FRACTAL_SCALE, 
   FULL_FRACTAL_SCALE, 
   NUM_DELTA_SCALES    
}; 
 
enum DELTA_PATCHES { 
   NO_PATCH = NUM_DELTA_SCALES, 
   MATCH_PROBS,       //hardwire 58% fix 
   BALANCE_TIES,      //give playedMoveIndex random place among tied moves 
   UP_TIED_TOP,       //add equalTopFix to all tied deltas 
   PUSH_TIED_TOP,     //add fix progressively to top ties and following deltas 
   PUSH_ALL_TIES,     //add fix progressively to all ties and following deltas 
   NUM_DELTA_PATCHES 
}; 
    
 
/** Translate evaluation differences ("deltas") as reported by chess  
    engines in "raw scale" to scales that might be perceived by players.   
    The motivation is that a tenth-of-a-pawn difference may not matter as 
    much between moves that are already inferior by 1-2 pawns, *and/or* when 
    the position itself favors the stronger side by 1-2 pawns, either now 
    or on the previous turn.   
 
    The re-scaling is intended to depend only on the "facts on the board", 
    not on the skill of the players, so it is applied while filtering 
    TurnContext down to TupleInfo, not while doing fitting.  This also takes 
    it away from the most speed-critical code, so we use function objects. 
    The re-scaling is not absorbed by the regression because it is stepwise, 
    with a "plateau" of evals where unit-scale is applied. 

    This class also handles the four main modes of operation with the deltas,
    depending on whether bool weightEvalsFirst is set true or false, and on
    whether swing is applied.  Here are the combinations:

    1. userLowDepth < userHighDepth && !weightEvalsFirst: The "Rolls Royce" option,
       complete with gas (time) guzzling.  Each depth in that range is treated as
       a separate regression, yielding a probability judgment using each depth's
       data only.  Then the probabilities for each move are combined using weights 
       specified in the class Trial and depending on the "d" and "v" parameters.
    2. userLowDepth < userHighDepth && weightEvalsFirst: The deltas for each
       depth are aggregated into one vector of deltas for a single regression.
       Swing is not used---rather the aggregation of deltas takes care of that
       in-tandem with the "d" and "v" parameters ("v" may always be fixed).
    3. userLowDepth == userHighDepth (== D) && !weightEvalsFirst: This has the same
       effect as just using the one depth D for judgment; d and v are ignored.
    4. userLowDepth == userHighDepth (== D) && weightEvalsFirst: This differs by 
       unlocking "Swing" and the userSwingLow..userSwingHigh range.  Differences
          delta(i,d) - delta(i,D)
       are aggregated using a similar vector of weights from class Trial, which
       in turn are updated with any change to "d" and (optionally) "v".
 */ 
class DeltaScale : public Catalogable { 
   string name; 
   bool weightEvalsFirst;
   //string swingPolicy;
   SwingInfo* swingPolicy;
   //APPLICATION_POLICIES applicationPolicy;
   //bool scaleThere;
   //bool depthDependentSwings;
   DELTA_PATCHES patchPolicy; 
   double patchPower;
   double equalTopFix;
   //double normFactor;
   map<string, double> normFactors;
   int zeroDepth;   //Used for Poisson weights (and the origin of swing?).
   size_t userLowDepth;
   size_t userHighDepth;
   size_t userSwingLow;
   size_t userSwingHigh;
   size_t judgmentDepth;
 protected:
   double deltaCap;

/*
   static APPLICATION_POLICIES parsePolicy(string swp) {
      bool join = (swp.find("join") != string::npos);
      bool link = (swp.find("link") != string::npos);
      bool sep = (swp.find("sep") != string::npos);
      bool proxy = (swp.find("proxy") != string::npos);
      bool rel1 = (swp.find("rel1") != string::npos || swp.find("relative1") != string::npos);
      bool rel2 = (swp.find("rel2") != string::npos || swp.find("relative2") != string::npos);
      bool rel3 = (swp.find("rel3") != string::npos || swp.find("relative3") != string::npos);
      bool rel = (swp.find("rel") != string::npos || swp.find("relative") != string::npos);
      if (join) {
         if (rel1) {
            return JOIN_REL1;
         } else if (rel2) {
            return JOIN_REL2;
         } else if (rel3) {
            return JOIN_REL3;
         } else if (rel) {
            return JOIN_REL1;
         } else {
            return JOIN_ABS;
         }
      } else if (link) {
         if (rel1) {
            return LINK_REL1;
         } else if (rel2) {
            return LINK_REL2;
         } else if (rel3) {
            return LINK_REL3;
         } else if (rel) {
            return LINK_REL1;
         } else {
            return LINK_ABS;
         }
      } else if (sep) {
         if (rel1) {
            return SEPARATE_REL1;
         } else if (rel2) {
            return SEPARATE_REL2;
         } else if (rel3) {
            return SEPARATE_REL3;
         } else if (rel) {
            return SEPARATE_REL1;
         } else {
            return SEPARATE_ABS;
         }
      } else if (proxy) {
         if (rel1) {
            return PROXY_REL1;
         } else if (rel2) {
            return PROXY_REL2;
         } else if (rel3) {
            return PROXY_REL3;
         } else if (rel) {
            return PROXY_REL1;
         } else {
            return PROXY_ABS;
         }
      } else {
         return NO_SWING;
      }
   }
*/

 public: 
   explicit DeltaScale(const string& gname, 
                       bool wef,
                       //string swp = "0(separate,relative2,damped)",
                       SwingInfo* swp,
                       DELTA_PATCHES gpatchPolicy = NO_PATCH,
                       double gppwr = IRutil::CENTRALPATCHPOWER,
                       double etf = 0.0,
                       //double nf = 1.0,
                       map<string,double> nf = map<string,double>(),
                       int zd = 1,
                       size_t ld = 30,
                       size_t hd = 30,
                       size_t swld = 5,
                       size_t swhd = 19,
                       size_t jd = 0,
                       double cap = IRutil::DELTACAP)
    : name(gname), weightEvalsFirst(wef), swingPolicy(swp), 
      //applicationPolicy(parsePolicy(swp)), scaleThere(swp.find("scale") != string::npos),
      //depthDependentSwings(swp.find("relative") != string::npos 
                           //|| swp.find("boxed") != string::npos),
      patchPolicy(gpatchPolicy),  patchPower(gppwr), equalTopFix(etf),
      normFactors(nf), zeroDepth(zd), userLowDepth(ld), userHighDepth(hd),
      userSwingLow(swld), userSwingHigh(swhd), judgmentDepth(jd), deltaCap(cap)
   { } 
   virtual ~DeltaScale() { } 
   virtual double mapDelta(const double delta, const TurnContext* const t) const = 0; 

   bool weightsEvalsFirst() const { return weightEvalsFirst; }
   double getEqualTopFix() const { return equalTopFix; } 
   DELTA_PATCHES getPatchPolicy() const { return patchPolicy; } 
   double getPatchPower() const { return patchPower; }
   double getTransPower() const { return swingPolicy->transPower; }
   map<string,double> getNormFactors() const { return normFactors; }

   string normFactorString() const {
      ostringstream oss;
      map<string, double>::const_iterator mitr = normFactors.begin();
      map<string, double>::const_iterator mite = normFactors.end();
      while (mitr != mite) {
         oss << "(*" << (*mitr).first << "*," << (*mitr).second << ") ";
         ++mitr;
      }
      return oss.str();
   }

   void addNormFactor(const string& key, const double value) { 
      normFactors[key] = value;  //overwrites since map not multimap
   }
   double lookupNF(const TurnContext* const tc, const double def = 1.0) const {
      map<string, double>::const_iterator mitr = normFactors.begin();
      map<string, double>::const_iterator mite = normFactors.end();
      while (mitr != mite) {
         if (tc->engineID.find((*mitr).first) != string::npos) {
            return (*mitr).second;
         }
         ++mitr;
      }
      return def;
   }
      
         

   //void setPatchPolicy(DELTA_PATCHES newPolicy) { patchPolicy = newPolicy; } 
   void setWEF(bool wef) { weightEvalsFirst = wef; }
   void setSwingPolicy(SwingInfo* swp) { swingPolicy = swp; }
   //void setApplicationPolicy(APPLICATION_POLICIES ap) { applicationPolicy = ap; }
   //void setApplicationPolicy(string swp) { applicationPolicy = parsePolicy(swp); }
   //void setScaleThere(string swp) { scaleThere = (swp.find("scale") != string::npos); }
   void setLowDepth(size_t lo) { userLowDepth = lo; }
   void setHighDepth(size_t hi) { userHighDepth = hi; }
   void setSwingLow(size_t swlo) { userSwingLow = swlo; }
   void setSwingHigh(size_t swhi) { userSwingHigh = swhi; }
   void setZeroDepth(int zd) { zeroDepth = zd; }
   void setJudgmentDepth(size_t jd) { judgmentDepth = jd; }
   void setDeltaCap(double newCap) { deltaCap = newCap; }
   void extendName(string ext) { name += ext; }
   
   double getDeltaCap() const { return deltaCap; }
   SwingInfo* getSwingPolicy() const { return swingPolicy; }
   //APPLICATION_POLICIES getApplicationPolicy() const { return applicationPolicy; }
   //bool scalesThere() const { return scaleThere; }
   //bool hasDepthDependentSwings() const { return depthDependentSwings; }
   size_t getLowDepth() const { return userLowDepth; }
   size_t getHighDepth() const { return userHighDepth; }
   size_t getSwingLow() const { return userSwingLow; }
   size_t getSwingHigh() const { return userSwingHigh; }
   int getZeroDepth() const { return zeroDepth; }
   size_t getJudgmentDepth() const { return judgmentDepth; }

   virtual string getName() const { 
      return name;
      //ostringstream oss;
      //oss << name << "depths[" << userLowDepth << ".." << userHighDepth << "]";
      //if (weightEvalsFirst) { oss << "WEF"; }
      //return oss.str();
   } 
   virtual string getDescription() const { 
      string policy; 
      switch(patchPolicy) { 
       case NO_PATCH: 
         policy = "using raw probabilities"; 
         break; 
       case MATCH_PROBS: 
         policy = "patching probabilities"; 
         break; 
       case BALANCE_TIES: 
         policy = "balancing ties"; 
         break; 
       case UP_TIED_TOP: 
         policy = "equal top deltas add " + IRutil::ftoa(getEqualTopFix(),3); 
         break; 
       case PUSH_TIED_TOP: 
         policy = "equal top deltas push " + IRutil::ftoa(getEqualTopFix(),3); 
         break; 
       case PUSH_ALL_TIES: 
         policy = "all equal deltas push " + IRutil::ftoa(getEqualTopFix(),3); 
         break; 
       default: 
         policy = "Unknown policy"; 
      } 
      return "; " + policy + normFactorString(); 
   } 
   virtual operator string() const {  
      return getName() + ":\n" + getDescription(); 
   } 
}; 
 
 
/** Placeholder class---implementations use Boolean option to avoid re-scaling. 
 */ 
class UnitScale : public DeltaScale { 
 public: 
   UnitScale(bool wef, SwingInfo* swp, DELTA_PATCHES pp, double ppwr, double equalTopFix,
             map<string,double> nf, int zd, size_t ld, size_t hd, size_t sld, size_t shd,
             size_t jd, double cap) 
    : DeltaScale("UnitScale", wef, swp, pp, ppwr, equalTopFix, nf, zd, ld, hd, sld, shd, jd, cap) 
   { } 
   virtual double mapDelta(const double delta, const TurnContext* const turn) const { 
      return delta; 
   } 
/* 
   virtual string getDescription() const {  
      return "always 1.0; equal-top deltas add "  
               + IRutil::ftoa(getEqualTopFix(),3);  
   } 
*/ 
}; 
 

 
/** Abstract base class for defining any scale by differential means. 
    This allows scales that don't have good closed formulas, and is 
    intuitively more convenient even for those that do.  Implements  
    mapDelta(x,turn) but has new abstract function lineElement(x,turn). 
    Note classes TranslateByEval and StraddleEvals, which assumes 
    CLASS INV: the LineElement admits affine translation for positive x  
    and is interpretable as being symmetric for negative x. 
 */ 
class LineScale : public DeltaScale {     
   double epsilon; 
 public: 
   double getEpsilon() const { return epsilon; } 
 
   LineScale(const string& name, bool wef, SwingInfo* swp, DELTA_PATCHES pp, double ppwr,
             double equalTopFix, map<string,double> nf, 
             int zd, size_t ld, size_t hd, size_t sld, size_t shd, size_t jd, double eps)  
      : DeltaScale(name, wef, swp, pp, ppwr, equalTopFix, nf, zd, ld, hd, sld, shd, jd)
      ,  epsilon(eps)  
   { } 
 
   /** Formally defined only for x >= 0, but assumed symmetric for x < 0 
    */ 
   virtual double lineElement(const double x, const TurnContext* turn) const = 0; 
 
   /************************************************************************* 
   Integration using the Simpson method with accuracy estimation. 
   Adapted from ALGLIBC code by Sergey Bochkanov, (C) 2005-2007. 
   The integral of function f over [a,b] is calculated with the 
   accuracy of order epsilon.  KWR: lineElement(x, turn) plays the role of f. 
      KWR: Thus far the only info extracted from the turn is the eval e  
   used as an offset, and this is used only as a subtractive translation.   
   Instead of integrating from 0 to delta, we could go from -e to -e + delta. 
   But this integral could straddle 0 and hence need two pieces, and we'd 
   still need e as a second parameter to mapDelta anyway, not a class field. 
   More important, since this is not the most time-critical code, it is 
   better to be clear about how the line-element itself depends on the e. 
   *************************************************************************/ 
   double integralSimpson(const double a, const double b, 
                          const TurnContext* turn) const { 
       double s2 = 1.0; 
       double h = b - a; 
       double s = lineElement(a,turn) + lineElement(b,turn); 
       double s1, s3; 
       double x; 

if (h < 0.0) {
   cerr << "negative case: a = " << a << ", b = " << b << ", turn " 
        << (turn->operator string()) << endl;
   return 0.0;
}
       do { 
           s3 = s2; 
           h = h/2; 
           s1 = 0.0; 
           x = a + h; 
           do { 
               s1 += 2*lineElement(x,turn); 
               x += 2*h; 
           } while (x < b); 
           s += s1; 
           s2 = (s + s1)*h/3.0; 
           x = fabs(s3 - s2)/15.0; 
       } while (x > epsilon); 
       return s2; 
   } 
 
   double mapDelta(const double delta, const TurnContext* const turn) const { 
      return integralSimpson(0.0, lookupNF(turn)*delta, turn); 
      //!! normalization of engines is done only here
   } 
   //still leaves getDescription() abstract 
}; 


/** An example of a direct mapping scale.
    Multiply delta by 1/(1 + gx) if x > 0, 1(1 + g'x) if treatNegSeparately && x < 0.
    The player-to-move eval comes from the TurnContext.
    Implicitly assumes that in the observed relation in positions of value x:

         avgdelta(x)  =  a_E  +  b_E * x,

    the ratio g = b_E/a_E (for x > 0) is independent of the Elo rating E.
    That's not quite true but is a reasonable approximation.
    The constant g (or its reciprocal) is called the "gradient" in the scales menu and below.
    The different g' is called the negGradient---there is observed to be a
    different limit a'_E > a_E as x approaches 0 from below (see "Firewall at Zero" post).
    The eval x is obtained from the TurnContext item.
 */
class MulScale : public LineScale {
   double radius;
   double power;
   double gradient;
   double negGradient;
   bool splitNegative;

 public:
   MulScale(string baseName, bool wef, SwingInfo* swp, DELTA_PATCHES pp, double ppwr, double equalTopFix,
            map<string,double> nf, int zd, size_t ld, size_t hd, size_t sld, size_t shd, size_t jd,
            double r, double pwr, double gr, double ngr, bool split)
    : LineScale(baseName, wef, swp, pp, ppwr, equalTopFix, nf, 
                zd, ld, hd, sld, shd, jd, IRutil::LINESCALEEPSILON)
    , radius(r), power(pwr), gradient(gr), negGradient(ngr), splitNegative(split)
   { }
/*
   virtual double mapDelta(const double delta, const TurnContext* turn) const {
      double g = (turn->currEval > 0 ? gradient : negGradient);
      if (delta <= radius) {
         return delta;
      } else {
         return delta/pow(1.0 + fabs(turn->currEval)*g, power);
      }
   }
*/

   virtual double lineElement(const double x, const TurnContext* turn) const {
      double g = ((splitNegative && turn->currEval < 0) ? negGradient : gradient);
      if (x <= radius) {
         return 1.0;
      } else {
         return 1.0/pow(1.0 + fabs(turn->currEval)*g, power);
      }
   }

   virtual double mapDelta(const double delta, const TurnContext* const turnc) const {
      double g = ((splitNegative && turnc->currEval < 0) ? negGradient : gradient);
      double absEval = fabs(turnc->currEval);
      return (absEval <= radius ? delta : delta/pow(1.0 + absEval*g, power));
   }

   virtual string getDescription() const {
      return "Multiplies delta by 1/(1 + g*x)^pow";
   }
};

/** SubScale has a different theory: it applies if in the equation

         avgdelta(x)  =  a_E  +  b_E * x,

    the "b_E" is close to constant.  So this parameter is called beta for x > 0
    and negBeta for x < 0.  Currently (7/29/16), SubScale is not used in the code;
    it is present only to help motivate MixScale.
 */
class SubScale : public LineScale {
   double radius;
   double power;    //keep at 1
   double beta;
   double negBeta;
   bool splitNegative;
 public:
   SubScale(string baseName, bool wef, SwingInfo* swp, DELTA_PATCHES pp, double ppwr, double equalTopFix,
            map<string,double> nf, int zd, size_t ld, size_t hd, size_t sld, size_t shd, size_t jd,
            double r, double pwr, double gb, double ngb, bool split)
    : LineScale(baseName, wef, swp, pp, ppwr, equalTopFix, nf, 
                zd, ld, hd, sld, shd, jd, IRutil::LINESCALEEPSILON)
    , radius(r), power(pwr), beta(gb), negBeta(ngb), splitNegative(split)
   { }

   virtual double lineElement(const double x, const TurnContext* turn) const {
      return 0.0;
   }

   virtual double mapDelta(const double delta, const TurnContext* const turnc) const {
      double b = ((splitNegative && turnc->currEval < 0) ? negBeta : beta);
      double absEval = fabs(turnc->currEval);
      return ((absEval <= radius || delta < absEval*b) ? delta : delta - pow(absEval*b, power));
   }

   virtual string getDescription() const {
      return "Subtracts (bx)^power from delta";
   }
};

/** Since neither assumption is shown to hold, MixScale attempts to flatten in a way that
    compensates by sliding a weighting factor "gamma" as the errors delta get bigger:  Let

                    alpha = tanh(gamma*(delta - beta*x))
    
    Then return alpha*SubScale + (1-alpha)*MulScale.  Note that since tanh(0) = 0, for
    delta = beta*x we just get MulScale, and the code ensures continuity by applying only
    MulScale for delta smaller than beta*x too.  Since a_E is close to the same for the
    negative-side relation, we can presume that negBeta/beta ~= negGradient/gradient.
    Thus the strategy is that gradient and negGradient should be taken from one end (say, 2800)
    and beta from the other (say, Elo 1050), and gamma adjusted as a "slider" between them.
 */
class MixScale : public LineScale {
   double radius;
   double power;    //keep at 1
   double gradient;
   double negGradient;
   bool splitNegative;
   double beta;     //the b in the implicit SubScale may differ from "gradient".
   double gamma;    //gauges how to weight the linear combination vis-a-vis delta
 public:
   MixScale(string baseName, bool wef, SwingInfo* swp, DELTA_PATCHES pp, double ppwr, double equalTopFix,
            map<string,double> nf, int zd, size_t ld, size_t hd, size_t sld, size_t shd, size_t jd,
            double r, double pwr, double gr, double ngr, bool split, double gbeta, double ggamma)
    : LineScale(baseName, wef, swp, pp, ppwr, equalTopFix, nf, 
                zd, ld, hd, sld, shd, jd, IRutil::LINESCALEEPSILON)
    , radius(r), power(pwr), gradient(gr), negGradient(ngr), splitNegative(split), beta(gbeta), gamma(ggamma)
   { }

   virtual double lineElement(const double x, const TurnContext* turn) const {
      return 0.0;
   }

   virtual double mapDelta(const double delta, const TurnContext* const turnc) const {
      double g = ((splitNegative && turnc->currEval < 0) ? negGradient : gradient);
      double b = ((splitNegative && turnc->currEval < 0) ? beta : beta*negGradient/gradient);
      double absEval = fabs(turnc->currEval);
      double denom = pow(1.0 + absEval*g, power);
      double transDelta = delta - pow(absEval*b, power);
      if (absEval >= radius) {
         if (transDelta < 0) {
            return (delta/denom);
         } else {
            double alpha = tanh(gamma*transDelta);
            return (alpha*transDelta + (1.0-alpha)*delta/denom);
         }
      } else {
         return 1.0;
      }
   }

   virtual string getDescription() const {
      return "Mixes MulScale and subtracting (gx)^power from delta";
   }
};



 
 
class TranslateByEval : public LineScale { 
   LineScale* ls; 
 public: 
   TranslateByEval(LineScale* gls)  
      : LineScale("TranslateByEval [" + gls->getName() + "]",  gls->weightsEvalsFirst(), 
                  gls->getSwingPolicy(), gls->getPatchPolicy(), gls->getPatchPower(), 
                  gls->getEqualTopFix(), gls->getNormFactors(), gls->getZeroDepth(), 
                  gls->getLowDepth(), gls->getHighDepth(), gls->getSwingLow(), 
                  gls->getSwingHigh(), gls->getJudgmentDepth(), gls->getEpsilon()), 
        ls(gls)  
   { } 
   virtual double lineElement(const double x, const TurnContext* pTurn) const { 
      double origin = pTurn->whiteToMove ? pTurn->currEval : -(pTurn->currEval); 
      return ls->lineElement(fabs(x - origin), pTurn); 
   } 
   virtual double mapDelta(const double delta, const TurnContext* const turnc) const {
      return ls->mapDelta(delta, turnc);
   }
   virtual string getDescription() const { 
      return ls->getDescription() + "; scaling by eval"; 
   } 
}; 
 
class StraddleEvals : public LineScale { 
   LineScale* ls; 
 public: 
   StraddleEvals(LineScale* gls) 
      : LineScale("StraddleEvals [" + gls->getName() + "]",  gls->weightsEvalsFirst(), 
                  gls->getSwingPolicy(), gls->getPatchPolicy(), gls->getPatchPower(), 
                  gls->getEqualTopFix(), gls->getNormFactors(), gls->getZeroDepth(), 
                  gls->getLowDepth(), gls->getHighDepth(), gls->getSwingLow(), 
                  gls->getSwingHigh(), gls->getJudgmentDepth(), gls->getEpsilon()),
        ls(gls) { } 
   virtual double lineElement(const double x, const TurnContext* pTurn) const { 
      double origin = 0.0; 
      if (pTurn->currEval < 0.0 && pTurn->prevEval != IRutil::NAVAL && pTurn->prevEval < 0.0) { 
         origin = max(pTurn->currEval, pTurn->prevEval); 
      } else if (pTurn->currEval > 0.0 && pTurn->prevEval > 0.0) {   // uses NAVAL > 0
         origin = min(pTurn->currEval, pTurn->prevEval); 
      } 
      origin = pTurn->whiteToMove ? origin : -origin; 
      return ls->lineElement(fabs(x - origin), pTurn); 
   } 
   virtual string getDescription() const { 
      return ls->getDescription()  //"[" + ls->getName() + "]," 
                 + "; scaling midway between eval and prev-eval"; 
   } 
 
}; 
 
/** Make lineElement decrease to 0 at the cap value deltaCap. 
    Leaves value at x = stepStart (= radius) unchanged. 
    Could, but does not, assume that x <= deltaCap. 
    Squares adjustment to concentrate it at the far end. 
 */ 
class PinToCap : public LineScale { 
   LineScale* ls; 
   double stepStart;  // <= deltaCap 
   double deltaCap; 
 public:  
   PinToCap(LineScale* gls, double gstart, double gcap) 
      : LineScale("PinToCap("+IRutil::ftoa(gcap,2)+")[" + gls->getName() + "]",
                  gls->weightsEvalsFirst(), gls->getSwingPolicy(),
                  gls->getPatchPolicy(), gls->getPatchPower(), 
                  gls->getEqualTopFix(), gls->getNormFactors(), gls->getZeroDepth(), 
                  gls->getLowDepth(), gls->getHighDepth(), gls->getSwingLow(), 
                  gls->getSwingHigh(), gls->getJudgmentDepth(), gls->getEpsilon()),
        ls(gls), stepStart(gstart), deltaCap(gcap) 
   { } 
   virtual double lineElement(const double x, const TurnContext* turn) const { 
      double res = ls->lineElement(x,turn); 
      if (x >= deltaCap) { 
         res = 0.0; 
      } else if (x <= stepStart) { 
         //do nothing 
      } else { 
         res -= ls->lineElement(deltaCap,turn) 
                          * IRutil::sqr((x-stepStart)/(deltaCap-stepStart)); 
      } 
      return res; 
   } 
   virtual string getDescription() const { 
      return ls->getDescription() + "; Make differential zero at cap"; 
   } 
}; 
 
//class PureLineScale : public LineScale { 
    
/** Since Ensemble code expects a LineScale, this rather than class UnitScale 
    is used as a singleton class for a no-scaling placeholder. 
 */ 
class UnitLineScale : public LineScale { 
 public: 
   UnitLineScale(const string& name, bool wef, SwingInfo* swp, DELTA_PATCHES pp, double ppwr, double etf,
                 map<string,double> nf, int zd, size_t ld, size_t hd, size_t sld, size_t shd,
                 size_t jd) 
         : LineScale(name, wef, swp, pp, ppwr, etf, nf, zd, ld, hd, sld, shd, jd, IRutil::LINESCALEEPSILON) 
   { } 
   virtual double lineElement(const double x, const TurnContext* turn) const { 
      return 1.0; 
   } 
   virtual string getDescription() const { 
      return "dx = always 1.0, NormFactors " + normFactorString()
                   + ", equal-top deltas add " 
                   + IRutil::ftoa(getEqualTopFix(),3); 
   } 
}; 
 
class LinearScale : public LineScale { 
   double radius; 
   double scalePower; 
   double gradient; 
 public: 
   LinearScale(const string& name, bool wef, SwingInfo* swp, DELTA_PATCHES pp, double ppwr, double etf,
               map<string,double> nf, int zd, size_t ld, size_t hd, size_t sld, size_t shd,
               size_t jd, double r, double sp, double gr) 
      : LineScale(name, wef, swp, pp, ppwr, etf, nf, zd, ld, hd, sld, shd, jd, IRutil::LINESCALEEPSILON),
                  radius(r), scalePower(sp), gradient(gr) 
   { } 
   virtual double lineElement(const double x, const TurnContext* turn) const { 
      if (x <= radius) { 
         return 1.0; 
      } else {   //line with value "gradient" at x=radius and value 
                 //scalePower*gradient at x=IRutil::DELTACAP (unless pinned) 
                 //Hence setting gradient = scalePower = 1 yields unit scale. 
         //double width = IRutil::DELTACAP - radius; 
         double width = deltaCap - radius;
         double value = gradient*(1.0 + (scalePower - 1.0)*(x - radius)/width); 
         return max(0.0, value); 
      } 
   } 
   virtual string getDescription() const { 
      //double width = IRutil::DELTACAP - radius; 
      double width = deltaCap - radius;
      string desc; 
      if (gradient == 1.0) { 
         if (scalePower == 1.0) { 
            desc = "Equivalent to unit scale (unless pinned)"; 
         } else { 
            desc = "Linear with slope " + IRutil::ftoa((scalePower - 1)/width)  
                 + " after radius " + IRutil::ftoa(radius,2); 
         } 
      } else { 
         if (scalePower == 1.0) { 
            desc = "Flat with value " + IRutil::ftoa(gradient)  
                 + " after radius " + IRutil::ftoa(radius,2); 
         } else { 
            desc = "Linear with slope "  
                 + IRutil::ftoa(gradient*(scalePower - 1)/width)  
                 + " after value " + IRutil::ftoa(gradient) 
                 + " at radius " + IRutil::ftoa(radius,2); 
         } 
      } 
      desc += ",\nwith normFactors " + normFactorString()
                    + "and equal-top add " + IRutil::ftoa(getEqualTopFix(),3);
      return desc; 
   } 
}; 
 
 
 
 
/** For position values outside radius r of the origin, scale down by the 
    log of the multiple of r involved.  Withing radius r, scaling is 1. 
    If, say, radius = 0.5 pawns, then the difference between delta = 1.00 
    and delta = 1.01 is scaled with division by (1 + log2(1.00/0.5)) = 2. 
    For delta = 2.00, the next hundredth of a pawn is scaled down by 1+2 = 3. 
 
    Integrating this line element gives rise to the famous Li(x) function  
    from analytic number theory, which has no simple closed formula.   
    Since we use mainly for small values of x and have the 
    stepwise plateau feature---and this is called only while filtering, not 
    regressing---we use Simpson rather than x/log(x) to approximate. 
 
    To keep a common menu-interface with FractalScale next, we implement a 
    scale-factor parameter "c", and a gradient parameter "gr", making  
 
                         1/gr*(1 + c*log(x/r))  
 
    the actual line element.  CLASS INV: gr = 1.0 makes the line element 1.0 
    at x = r, making it continuous with the "plateau".  Since C++ "log" is  
    to base, we'd use c = ln(2) to make the log be base-2 as described above. 
    In FractalScale, the "c" plays a much larger role, but in both cases it 
    comes from (x/r)^c, and we encourage analogy to "c" in the regressions. 
 
    Also in these classes, the "turn" parameter is ignored---though it's used 
    when composed with TranslateBy[Prev]Eval.  Whether yet-another abstract 
    parent should remove it, and factor the fields (r,gr,c), is dubious. 
 */ 
class DivLogScale : public LineScale { 
   double radius; 
   double scalePower; 
   double gradient;   
 public: 
   DivLogScale(const string& name, bool wef, SwingInfo* swp, DELTA_PATCHES pp, double ppwr, double etf,
               map<string,double> nf, int zd, size_t ld, size_t hd, size_t sld, size_t shd,
               size_t jd, double r, double sp, double gr)  
      : LineScale(name, wef, swp, pp, ppwr, etf, nf, zd, ld, hd, sld, shd, jd, IRutil::LINESCALEEPSILON),
        radius(r), scalePower(sp), gradient(gr) 
   { } 
   virtual double lineElement(const double x, const TurnContext* turn) const { 
      if (x <= radius) { 
         return 1.0; 
      } else { 
         return 1.0/(gradient * (1.0 + scalePower*log(x/radius))); 
      } 
   } 
   virtual string getDescription() const { 
      string desc; 
      if (gradient == 1.0) { 
         if (scalePower == 1.0) { 
            desc = "1/(1 + ln(x/r)) with r = " + IRutil::ftoa(radius,2); 
         } else { 
            desc = "1/(1 + c*ln(x/r)) with r = " + IRutil::ftoa(radius,2) 
                      + ", c = " + IRutil::ftoa(scalePower); 
         } 
      } else { 
         if (scalePower == 1.0) { 
            desc = "1/g*(1 + ln(x/r)) with r = " + IRutil::ftoa(radius,2) 
                      + ", g = " + IRutil::ftoa(gradient); 
         } else { 
            desc = "1/g(1 + c*log(x/r)) with r = " + IRutil::ftoa(radius,2)  
                + ", c = " + IRutil::ftoa(scalePower)  
                + ", g = " + IRutil::ftoa(gradient); 
         } 
      } 
      desc += ",\nwith normFactors " + normFactorString()
                    + " and equal-top add " + IRutil::ftoa(getEqualTopFix(),3);
      return desc; 
   } 
}; 
 
/** Integrating a line element of 1/y from y=1 to y=z yields ln(z). 
    The effect is thus more drastic on outlier deltas than with DivLogScale. 
    We generalize this to allow 1/y^c, intended for c <= 1. 
 */ 
class FractalScale : public LineScale { 
   double radius; 
   double scalePower; 
   double gradient; 
 public: 
   FractalScale(const string& name, bool wef, SwingInfo* swp, DELTA_PATCHES pp, double ppwr, double etf,
                map<string,double> nf, int zd, size_t ld, size_t hd, size_t sld, size_t shd,
                size_t jd, double r, double sp, double gr) 
      : LineScale(name, wef, swp, pp, ppwr, etf, nf, zd, ld, hd, sld, shd, jd, IRutil::LINESCALEEPSILON),
        radius(r), scalePower(sp), gradient(gr) 
   { } 
 public: 
   virtual double lineElement(const double x, const TurnContext* turn) const { 
      if (x <= radius) { 
         return 1.0; 
      } else { 
         return 1.0/(gradient * pow(x/radius, scalePower)); 
      } 
   } 
   virtual string getDescription() const { 
      string desc; 
      if (gradient == 1.0) { 
         if (scalePower == 1.0) { 
            desc = "Log-log scaling of deltas above r = "  
                        + IRutil::ftoa(radius,2); 
         } else { 
            desc = "1/(x/r)^c with r = " + IRutil::ftoa(radius,2) + ", c = " 
                + IRutil::ftoa(scalePower); 
         } 
      } else { 
         if (scalePower == 1.0) { 
            desc = "Log-log scaling of deltas above r = "  
                + IRutil::ftoa(radius,2) + ", g = " + IRutil::ftoa(gradient); 
         } else { 
            desc = "1/g*(x/r)^c) with r = " + IRutil::ftoa(radius,2) + ", c = " 
                + IRutil::ftoa(scalePower) + ", g = " + IRutil::ftoa(gradient); 
         } 
      } 
      desc += ",\nwith normFactors " + normFactorString()
                    + " and equal-top add " + IRutil::ftoa(getEqualTopFix(),3);
      return desc; 
   } 
}; 
 
/** Integrating a line element of 1/y from y=1 to y=z yields ln(z). 
    The effect is thus more drastic on outlier deltas than with DivLogScale. 
    We generalize this to allow 1/y^c, intended for c <= 1. 
    "Full" means radius r == 0; the radius is not polled.
 */ 
class FullFractalScale : public LineScale { 
   double scalePower; 
   double gradient; 
   double negGradient;
 public: 
   FullFractalScale(const string& name, bool wef, SwingInfo* swp, DELTA_PATCHES pp, double ppwr, double etf,
                    map<string,double> nf, int zd, size_t ld, size_t hd, size_t sld, size_t shd,
                    size_t jd, double sp, double gr, double ngr) 
    : LineScale(name, wef, swp, pp, ppwr, etf, nf, zd, ld, hd, sld, shd, jd, IRutil::LINESCALEEPSILON)
    , scalePower(sp), gradient(gr), negGradient(ngr) 
   { } 
 public: 
   virtual double lineElement(const double x, const TurnContext* turn) const { 
      double gr = (turn->whiteToMove ? gradient : negGradient);
      return 1.0/pow(1 + x*gr, scalePower); 
   } 
   virtual string getDescription() const { 
      string desc; 
      if (gradient == 1.0) { 
         if (scalePower == 1.0) { 
            desc = "Log(1 + ...) scaling"; 
         } else { 
            desc = "1/(1 + x)^c with c = " 
                + IRutil::ftoa(scalePower); 
         } 
      } else { 
         if (scalePower == 1.0) { 
            desc = "Log(1 + ...) scaling graded + by " + IRutil::ftoa(gradient)
            + "; - by " + IRutil::ftoa(negGradient); 
         } else { 
            desc = "1/(1 + gx)^c with c = " 
               + IRutil::ftoa(scalePower) + ", g = " + IRutil::ftoa(gradient)
            + ";" + IRutil::ftoa(negGradient); 
         } 
      } 
      desc += ", with normFactors " + normFactorString()
                    + " and equal-top add " + IRutil::ftoa(getEqualTopFix(),3);
      return desc; 
   } 
}; 
 
/** Version of FullFractalScale that doesn't lend itself to translation by eval
    but handles the eval origin directly.  Overrides mapDelta directly too.
    Activate by setting all translations "off" and choosing FullFractalScale
    in the first part of the scales menu.  TurnContext has eval from White's view.
 */
class SimpleFullFractalScale : public LineScale {
   double scalePower;
   double gradient;
   double negGradient;
   double gradientRatio; 
 public:
   SimpleFullFractalScale(const string& name, bool wef, SwingInfo* swp,
         DELTA_PATCHES pp, double ppwr, double etf,
         map<string,double> nf, int zd, size_t ld, size_t hd, size_t sld, size_t shd,
         size_t jd, double sp, double gr, double ngr)
    : LineScale(name, wef, swp, pp, ppwr, etf, nf, zd, ld, hd, sld, shd, jd, IRutil::LINESCALEEPSILON)
    , scalePower(sp), gradient(gr), negGradient(ngr), 
      gradientRatio(IRutil::divifgt0(gradient,negGradient))
   { }
 public:
   virtual double lineElement(const double x, const TurnContext* turn) const {
      double gr = (turn->whiteToMove ? gradient : negGradient);
      return 1.0/pow(1 + x*gr, scalePower);  //to be ignored
   }
   virtual double mapDelta(const double delta, const TurnContext* const turn) const {
      double evalPTM = (turn->whiteToMove ? turn->currEval : -1*turn->currEval);
      double postEval = evalPTM - delta;
      double term1 = (evalPTM > 0 ? log(1.0 + evalPTM*gradient)/gradient
                                  : -log(1.0 - evalPTM*negGradient)/negGradient);
      double term2 = (postEval > 0 ? -log(1.0 + postEval*gradient)/gradient
                                   : log(1.0 - postEval*negGradient)/negGradient);
      return (term1 + term2);
   }
   virtual string getDescription() const {
      string desc;
      if (gradient == 1.0) {
         if (scalePower == 1.0) {
            desc = "Log(1 + ...) scaling";
         } else {
            desc = "1/(1 + x)^c with c = "
                + IRutil::ftoa(scalePower);
         }
      } else {
         if (scalePower == 1.0) {
            desc = "Log(1 + ...) scaling graded + by " + IRutil::ftoa(gradient)
            + "; - by " + IRutil::ftoa(negGradient);
         } else {
            desc = "1/(1 + gx)^c with c = "
               + IRutil::ftoa(scalePower) + ", g = " + IRutil::ftoa(gradient)
            + ";" + IRutil::ftoa(negGradient);
         }
      }
      desc += ", with normFactors " + normFactorString()
                    + " and equal-top add " + IRutil::ftoa(getEqualTopFix(),3);
      desc += "; scaling from 0";
      return desc;
   }
};

 
 
/** Combine two line metrics by averaging, so that the differential within 
    the plateau stays at 1.0.  If we could assume mapDelta(x,turn) is  
    likewise linear, then we could make this class general for DeltaScale. 
    Assume they both have the same patch policy, use the one from ds1. 
 */ 
class BinaryScale : public LineScale { 
   //LineScale* ds1, ds2;    //Caught this common error before compiling! 
   LineScale* ds1; 
   LineScale* ds2; 
 public: 
   BinaryScale(LineScale* d1, LineScale* d2)  
      : LineScale("Binary [" + d1->getName() + ", " + d2->getName() + "]", 
                   d1->weightsEvalsFirst(),
                   d1->getSwingPolicy(),
                   d1->getPatchPolicy(),
                   d1->getPatchPower(),
                   min(d1->getEqualTopFix(), d2->getEqualTopFix()),  
                   d1->getNormFactors(),  //assumed same for d2
                   max(d1->getZeroDepth(), d2->getZeroDepth()),  //really should be equal
                   max(d1->getLowDepth(), d2->getLowDepth()),
                   min(d1->getHighDepth(), d2->getHighDepth()),  //ditto
                   max(d1->getSwingLow(), d2->getSwingLow()),
                   min(d1->getSwingHigh(), d2->getSwingHigh()),
                   max(d1->getJudgmentDepth(), d2->getJudgmentDepth()),
                   max(d1->getEpsilon(), d2->getEpsilon())), 
        ds1(d1), ds2(d2)  
   { } 
   virtual double lineElement(const double x, const TurnContext* turn) const { 
      return (ds1->lineElement(x,turn) + ds2->lineElement(x,turn))/2.0; 
   } 
   virtual string getDescription() const { 
      string desc = ""; 
      desc += "[" + ds1->getName() + ", " + ds2->getName() + "]"; 
      desc += ", equal-top deltas add " + IRutil::ftoa(getEqualTopFix(),3); 
      return desc; 
   } 
}; 
 
class TernaryScale : public LineScale { 
   LineScale* ds1; 
   LineScale* ds2; 
   LineScale* ds3; 
 public: 
   TernaryScale(LineScale* d1, LineScale* d2, LineScale* d3) 
      : LineScale("Ternary [" + d1->getName() + ", " + d2->getName() + ", " 
                      + d3->getName() + "]", 
                   d1->weightsEvalsFirst(),
                   d1->getSwingPolicy(),
                   d1->getPatchPolicy(),
                   d1->getPatchPower(),
                   min(min(d1->getEqualTopFix(), d2->getEqualTopFix()), 
                      d3->getEqualTopFix()), 
                   d1->getNormFactors(),
                   max(max(d1->getZeroDepth(), d2->getZeroDepth()), d3->getZeroDepth()),  
                   max(max(d1->getLowDepth(), d2->getLowDepth()), d3->getHighDepth()),
                   min(min(d1->getHighDepth(), d2->getHighDepth()), d3->getHighDepth()),  //ditto
                   max(max(d1->getSwingLow(), d2->getSwingLow()), d3->getSwingLow()),
                   min(min(d1->getSwingHigh(), d2->getSwingHigh()), d3->getSwingHigh()),
                   max(max(d1->getJudgmentDepth(), d2->getJudgmentDepth()), d3->getJudgmentDepth()),
                   max(max(d1->getEpsilon(), d2->getEpsilon()), 
                      d3->getEpsilon())), 
        ds1(d1), ds2(d2), ds3(d3) 
   { } 
   virtual double lineElement(const double x, const TurnContext* turn) const { 
      return (ds1->lineElement(x,turn) + ds2->lineElement(x,turn)  
                    + ds3->lineElement(x,turn))/3.0; 
   } 
   virtual string getDescription() const { 
      string desc = ""; 
      desc += "[" + ds1->getName() + ", " + ds2->getName()  
                  + ", " + ds3->getName() + "]"; 
      desc += ", equal-top deltas add " + IRutil::ftoa(getEqualTopFix(),3);  
      return desc; 
   } 
 
}; 
 
 
#endif    //end of #ifndef __IR_DELTA_SCALES_H__ 
 
 
//File-----------------------DecisionInfo.h------------------------------------ 
 
 
#ifndef __IR_DECISION_INFO_H__ 
#define __IR_DECISION_INFO_H__ 


/** Class DecisionInfo accesses depth info in absolute int units from TurnInfo,
    but stores them in relative 2-place units ("deltas") from overall eval.

    ** Whereas TurnInfo uses centipawn (int) units, DecisionInfo uses pawn (p.nn) units. **
    ** Evals are from White's view unless marked PTM; swings are always from player view. **

    The class reads data with depths dataLowDepth..dataHighDepth, but stores data
    only in the window userLowDepth..userHighDepth specified by theScale.  
    If userLowDepth < dataLowDepth, then TupleInfo objects for the lowest-depth true info
    are replicated, and similarly for the highest-depth info if userHighDepth > dataHighDepth.
    Note that userLowDepth > dataHighDepth is possible---e.g. when the engine cuts out early
    giving a quick mate---whereupon the top-depth info is replicated.
 */
class DecisionInfo { 
 public:
   const TurnInfo* pParent;
   //const size_t numLegalMoves;   //== pParent->numLegalMoves
   const size_t numMovesWithValues;
   const size_t playedMoveIndex;
   const bool useAltPlayedMoveIndex;
   const double deltaCap;
   const bool patchesProbs;
   const bool scalesDeltas;

   const DeltaScale* theScale;
   const size_t dataLowDepth; //== pParent->turnLowestDepth, least depth with move eval
   const size_t dataHighDepth;//== pParent->turnHighestDepth, greatest with a move eval
                              //Could be >= and <= respectively.  Currently passed in via
                              //Ensemble's readInputFile method, so assume correct here
   const size_t userLowDepth;       //==theScale->userLowDepth
   const size_t userHighDepth;      //==theScale->userHighDepth
   const size_t numTuples;//== hi - lo + 1

   vector <TupleInfo*> depthDeltasScaled;   //ALL CONSTRUCTED, not assigned, own copies
                                            //indexed [0 .. dataHighDepth-dataLowDepth]
   vector <TupleInfo*> depthDeltasUnscaled; //Important function: discrete comparisons for rank.
   vector <double>* decMoveSwings;          //indexed 0 .. numMovesWithValues-1
   vector <double> bestEvals;               //indexed [0 .. dataHighDepth-dataLowDepth]
   vector <double> worstEvals;              //"", both constructed not assigned
   //vector <Move> bestMoveAtDepth;         //duplicated in TurnInfo
   vector<size_t> indexFirstMoveAtDepth;    //the top-depth index/rank of the first
                                            //occurrence of the best value at depth d

   vector <TupleInfo*> windowDeltasScaled;  //indexed [0 .. userHi-userLo], not own copies
   vector <TupleInfo*> windowDeltasUnscaled;
   vector <double> windowBests;
   vector <double> windowWorsts;

   vector <double> unscaledFalloff;       //get from pParent
   vector <double> scaledFalloff;         //range over all depths
   const double turnFalloffCapped;        //TAMAL: do we need unscaledFalloffCapped ?? KWR: No.
   double bootWeight;

   //TupleInfo contains information about const vector<double>* const scaledDeltas;
   //Need to do it for all legal moves 

 public:
   DecisionInfo(const TurnInfo* parent, bool gscaledDeltas, DeltaScale* ds, bool pp, bool ua,
                vector<vector<int> >* evalSwap)  //evalSwap passed as space from Trial
    : 
      pParent(parent)
    , numMovesWithValues(min(parent->numLegalMoves, pParent->numConsideredMoves))   //parent->numLegalMoves)
      //use 1+ to give a "catchall" slot for moves not in top NumConsidered?
    , playedMoveIndex(parent->playedMoveIndex)
    , useAltPlayedMoveIndex(ua)
    , deltaCap(gscaledDeltas ? ds->getDeltaCap() : IRutil::DELTACAP)
    , patchesProbs(pp)
    , scalesDeltas(gscaledDeltas)
    , theScale(ds)
    , dataLowDepth(parent->turnLowestDepth)
    , dataHighDepth(parent->turnHighestDepth)
    , userLowDepth(ds->getLowDepth())
    , userHighDepth(ds->getHighDepth())
    , numTuples(ds->getHighDepth() - ds->getLowDepth() + 1)   //user not data
    , decMoveSwings(new vector<double>(min(parent->numLegalMoves,pParent->numConsideredMoves), 0.0))
    , indexFirstMoveAtDepth(vector<size_t>())
    , turnFalloffCapped(min(parent->turnFalloffCP/100.0, gscaledDeltas ? ds->getDeltaCap() : IRutil::DELTACAP)) 
    , bootWeight(1.0)
   { 
      IRutil::decsMade++;
      if (IRutil::decsMade % IRutil::TURNSMODULUS == 0) {
         cerr << "Created " << IRutil::decsMade << " DecisionInfo objects against "
              << IRutil::decsDeleted << " deleted." << endl;
      }

      if (numMovesWithValues == 0) {
         cerr << endl << "numLegal == " << parent->numLegalMoves << ", numConsidered = "
              << pParent->numConsideredMoves << " in turn " << parent->toString() << endl;
      }
      processTurnInfo(evalSwap); 
      resetWindow();
   } 

   ~DecisionInfo() {
      vector<TupleInfo*>::iterator vitr = depthDeltasScaled.begin();
      vector<TupleInfo*>::iterator vite = depthDeltasScaled.end();
      while (vitr != vite) {
         TupleInfo* tp = *vitr++;
         delete(tp);
      }
      vitr = depthDeltasUnscaled.begin();
      vite = depthDeltasUnscaled.end();
      while (vitr != vite) {
         TupleInfo* tp = *vitr++;
         delete(tp);
      }
      delete(decMoveSwings);
      IRutil::decsDeleted++;
      if (IRutil::decsDeleted % IRutil::TURNSMODULUS == 0) {
         cerr << "Deleted " << IRutil::decsDeleted << " of " << IRutil::decsMade <<
         " DecisionInfo objects." << endl;
      }
   }
 
   /** Get eval in pawn 0.00 units, conversion from centipawns done here.  
       *All depth arguments in the public interface are absolute.*
       Allows d > dataHighDepth as argument.
    */
   double getEvalP(size_t i, size_t d) const { 
      const size_t useDepth = (d > dataHighDepth ? dataHighDepth : (d < dataLowDepth ? dataLowDepth : d));
      int cpeval = pParent->getEvalCP(i,useDepth);    //uses absolute depths
      int btm = pParent->whiteToMove? 1 : -1;
      double eval;
      switch(cpeval) {
       case IRutil::PRUNVAL:
         eval = getBestEvalP(useDepth) - btm*IRutil::PRUNCAP; //PRUNCAP is in p.nn units
         break;
       case IRutil::NRECVAL:
         eval = getWorstEvalP(useDepth);
         break;
       case IRutil::NAVAL:   //fake it, use already-scaled value
         eval = getBestEvalP(useDepth) 
                   - btm*(depthDeltasScaled.at(useDepth - dataLowDepth)->getDelta(i));
         break;
       default:
         eval = cpeval/double(100);
      }
      return eval;
   }

   double getBestEvalP(size_t d) const {  
      const size_t useDepth = (d > dataHighDepth ? dataHighDepth : (d < dataLowDepth ? dataLowDepth : d));
      return bestEvals.at(useDepth - dataLowDepth);
   }
   double getWorstEvalP(size_t d) const { 
      const size_t useDepth = (d > dataHighDepth ? dataHighDepth : (d < dataLowDepth ? dataLowDepth : d));
      return worstEvals.at(useDepth - dataLowDepth);
   }

   double getSwingScaled(size_t i, size_t D, bool normalize) const {  //always from player perspective
      double swing = 0.0;
      size_t targetDepth = (D > dataHighDepth ? dataHighDepth : D);
      TupleInfo* topTuple = getDepthInfoScaled(targetDepth);
      if (i >= topTuple->pScaledDeltas->size()) { 
         cerr << "Swing of non-considered move requested, returning NAVAL..." << endl;
         return IRutil::NAVAL; 
      } //else
      double topDelta = topTuple->pScaledDeltas->at(i);
      size_t userSwingLow = theScale->getSwingLow();
      size_t userSwingHigh = theScale->getSwingHigh();
      if (userSwingHigh < userSwingLow) {
         userSwingHigh = dataHighDepth;
         userSwingLow = dataLowDepth;
      }
      size_t swadd = (userSwingLow <= targetDepth && targetDepth <= userSwingHigh) ? 0 : 1;
      size_t numSWs = userSwingHigh - userSwingLow + swadd;
      for (size_t d = userSwingLow; d <= userSwingHigh; d++) { 
         TupleInfo* dTuple = getDepthInfoScaled(d);
         swing += (dTuple->pScaledDeltas->at(i) - topDelta);
      }

//debug
if (getRankAtDepth(i, D) == 0 && swing < 0) {
   cerr << "Swing bug " << swing << " in turn:" << endl << string(*this) << endl; 
}
      return (normalize ? swing/double(numSWs) : swing);
   }


   double getDecMoveSwing(size_t i) {
      if (i >= decMoveSwings->size()) {
         cerr << "Swing of over-top move requested, returning zero." << endl;
         return 0.0;
      }
      return decMoveSwings->at(i);
   }
      

   double getUnscaledFalloffAtMaxDepth() {
      return unscaledFalloff.at(unscaledFalloff.size()-1);
   }
    
   double getScaledFalloffAtMaxDepth() {
      return scaledFalloff.at(scaledFalloff.size()-1);
   }

   size_t getNumLegalMoves() const { return pParent->numLegalMoves; }
   size_t getNumMovesWithValues() const { return numMovesWithValues; }
    
   size_t getPlayedMoveIndex () const {   //indexed by highest-depth info
      return playedMoveIndex; 
   } 

   /** Call this with i = playedMoveIndex to get rank of played move at any depth.
       Note use of unscaled deltas to ensure comparisons for equality are discrete.
       In figuring ranks of equal-value moves, the assumption is that the engine's
       relative rank of them at depth d is estimated often enough by the rank at
       the data high depth D (which is what defines the given index i).
       At least that should be better than flipping coins...

       Relies on values for the called move i having been filled in at all depths.
       If move i did not have a value at depth d, it will have been given a
       joint last-place value, and the first occurrence of that value will
       become its rank.  Ideally distortion caused by this, such as fetching
       probabilities by those ranks, will be small.
    */
   size_t getRankAtDepth(size_t i, size_t d) const { 
      double numHigher = 0;  // "higher" means >= for j < i, > for j > i
      TupleInfo* tiu = getDepthInfoUnscaled(d);  //not own copy so don't delete
      double di = tiu->pScaledDeltas->at(i);     //should not bomb...
      for (int j = 0; j < i; j++) {
         if (tiu->pScaledDeltas->at(j) <= di) { numHigher++; }
      }
      for (int k = i+1; k < tiu->pScaledDeltas->size(); k++) {  //bound should == numDeltas
         if (tiu->pScaledDeltas->at(k) < di) { numHigher++; }
      }
      return numHigher;
   }

   size_t getIndexFirstMoveAtDepth(size_t depth) const {
      int useDepth = depth - dataLowDepth;
      if (useDepth >= depthDeltasScaled.size()) {
         useDepth = depthDeltasScaled.size()-1;
      } else if (useDepth < 0) {
         useDepth = 0;
      }
      return indexFirstMoveAtDepth.at(useDepth);
   }
   

   TupleInfo* getDepthInfoScaled(const size_t depth) const {
      int useDepth = depth - dataLowDepth;
      if (useDepth >= depthDeltasScaled.size()) {
         useDepth = depthDeltasScaled.size()-1;
      } else if (useDepth < 0) { 
         useDepth = 0; 
      }
      //return depthDeltasScaled.at(depth);  //IMPT: per indexing notes above, this was wrong
      return depthDeltasScaled.at(useDepth);
   }

   TupleInfo* getDepthInfoUnscaled(size_t depth) const {
      int useDepth = depth - dataLowDepth;
      if (useDepth >= depthDeltasUnscaled.size()) {
         useDepth = depthDeltasUnscaled.size()-1;
      } else if (useDepth < 0) { 
         useDepth = 0; 
      }
      return depthDeltasUnscaled.at(useDepth);
   }

   double getDeltaScaled(size_t i, size_t depth) const {
      return getDepthInfoScaled(depth)->pScaledDeltas->at(i);
   }

   double getDeltaUnscaled(size_t i, size_t depth) const {
      return getDepthInfoUnscaled(depth)->pScaledDeltas->at(i);
   }

   /** Currently forgives calls with depth > userHighDepth, returning the data
       above the user window if it exists, so same as above two methods.
       Could alternately return the userHighDepth info---or bomb...
    */
   TupleInfo* getWindowInfoScaled (size_t depth) const {
      int useDepth = depth - userLowDepth;
      if (useDepth >= windowDeltasScaled.size()) {
         useDepth = windowDeltasScaled.size()-1; //which might include higher data
      } else if (useDepth < 0) {
         useDepth = 0;
      }  
      return windowDeltasScaled.at(useDepth);
   }

   TupleInfo* getWindowInfoUnscaled (size_t depth) const {
      int useDepth = depth - userLowDepth;
      if (useDepth >= windowDeltasUnscaled.size()) {
         useDepth = windowDeltasUnscaled.size()-1; //which might include higher data
      } else if (useDepth < 0) {
         useDepth = 0;
      }
      return windowDeltasUnscaled.at(useDepth);
   }

   TupleInfo* getHighestTupleScaled() const {   //irrespective of user window
      return depthDeltasScaled.at(depthDeltasScaled.size()-1); 
   } 

   TupleInfo* getHighestTupleUnscaled() const {
      return depthDeltasUnscaled.at(depthDeltasUnscaled.size()-1);
   }
 
   double getHighestDepthMoveDeltaScaled(int index) const { 
      return getHighestTupleScaled()->getDelta(index); 
   } 

   double getHighestDepthMoveDeltaUnscaled(int index) const {
      return getHighestTupleUnscaled()->getDelta(index);
   }

   TupleInfo* getHighestWindowTupleScaled() const {
      return windowDeltasScaled.at(windowDeltasScaled.size()-1);
   }

   TupleInfo* getHighestWindowTupleUnscaled() const {
      return windowDeltasUnscaled.at(windowDeltasUnscaled.size()-1);
   }

   //double getHighestWindowDepthMoveDelta(int index) const {
      //return getHighestWindowTuple()->getScaledDelta(index);
   //}


   int getNumberOfMovesAnalyzed() const {
      return getHighestTupleScaled()->numDeltas;
   }

   double getSwing(size_t i) const {
      return decMoveSwings->at(i);
   }

   double getBootWeight() const { return bootWeight; }
   void setBootWeight(double wt) { bootWeight = wt; }
   void incBootWeight() { bootWeight += 1.0; }

   /** Create tuple from any deltas vector, not necessarily conforming size
       REQ: deltas are all non-negative, Black to move already cared for.
       REQ: deltas already in 2-place decimal units.
    */
   TupleInfo* makeTuple(const vector<double>* deltas, TurnContext* tc,
                        bool scaleIt, SwingInfo* swingPolicy, bool perceived) const {
      int lastEqPlace = 0;
      double pushAdd = 0.0;
      bool pushing = false;
      vector<double>* adjDeltas = new vector<double>(numMovesWithValues);

      scaleIt &= scalesDeltas;

      for (int k = 0; k < numMovesWithValues; k++) {
         double cappedDelta = min(deltas->at(k), deltaCap);
         if (cappedDelta != deltas->at(lastEqPlace)) {
            lastEqPlace = k;
         }
   
         if (scaleIt)  {
            switch(theScale->getPatchPolicy())  {
             case UP_TIED_TOP:
               if (k > 0 && cappedDelta == 0.0) {
                  cappedDelta += theScale->getEqualTopFix();
                  //cappedDelta += theScale->getEqualTopFix() + IRutil::LINESCALEEPSILON*(i-1);;
               }
               break;
             case PUSH_TIED_TOP:
               pushing = true;
               if (k > 0 && cappedDelta == 0.0) {
                  pushAdd += theScale->getEqualTopFix(); //progresses the fix
               }
               break;
             case PUSH_ALL_TIES:
               pushing = true;
               if (k > lastEqPlace) {
                  pushAdd += theScale->getEqualTopFix(); //progresses the fix
               }
               break;
             default:
               break;
            }
            if (pushing) { 
               cappedDelta += pushAdd; 
            }
   
            adjDeltas->at(k) = theScale->mapDelta(cappedDelta,tc);
   
         } else  {
            adjDeltas->at(k) = cappedDelta;
         }
      }
   
      //vector<double>* swings = (swingPolicy.find("none") == string::npos ? decMoveSwings : NULL);
      //vector<double>* swings = ((swingPolicy->noSwing || (!swingPolicy->depthDependentSwings)) ? decMoveSwings : NULL);
      //may be re-set by caller
      
      double evalPTM = (tc->whiteToMove ? tc->currEval : -tc->currEval);
      TupleInfo* pTupleInfo = new TupleInfo(pParent, adjDeltas, decMoveSwings, swingPolicy, 
                                            //theScale->getApplicationPolicy(),
                                            //theScale->scalesThere(), false,
	                                    evalPTM, playedMoveIndex, useAltPlayedMoveIndex,
                                            patchesProbs, theScale->getPatchPower());

      if (perceived) {
         delete(tc);
         delete(deltas);
      }
      return pTupleInfo;
   }
   
 
   /** Read evals from TurnInfo* pParent which are in centipawns as integers
       indexed first by legal move and then by depth.  Copy into swap as
       ints, with policy that lowest-depth analysis marked "n.a."
       by the special value NAVAL repeats the lowest-depth recorded value for
       the move; values marked PRUN have value (eval - multipv_cp), and values
       marked NREC share the lowest value of any move at that depth.
       Then values are scaled while being read from swap and formed into the
       final TupleInfo objects.  Use of common swap-space avoids copying.
    */
   void processTurnInfo(vector<vector<int> >* evalSwap) { 
      double deltaFallOff; 
 
      if (playedMoveIndex == -1) { 
         cerr << "error: move played not found in legal moves!: " 
              << pParent->movePlayed << ":" << endl; 
         for (vector<Move>::const_iterator it = pParent->legalMoves->begin(); 
              it != pParent->legalMoves->end(); ++it) { cerr << string(*it) << ", "; } 
         cerr << endl; 
      } 
      //TurnInfo has  vector <vector<int> > depthEvalsCP; 
      //inner vector has size (hi-lo+1) 

      //Evals are read as integers in centipawn units, scaled as doubles
      //in "pawn" units, dividing by double(100).

      int numDataDepths = dataHighDepth - dataLowDepth + 1;

      int btm = pParent->whiteToMove? 1 : -1;

      //Only depths with real data are handled

      vector<int> bestEvalsCP(numDataDepths, btm*(-IRutil::MATEVALCP));
      vector<int> worstEvalsCP(numDataDepths, btm*IRutil::MATEVALCP);
      //vector<Move> bestMoveVec(numDataDepths, Move());
      vector<size_t> indexFirstMoveVec(numDataDepths, 0);

      const vector<vector<int> >* rawEvalsCP = pParent->depthEvalsCP;
      //This uses absolute indexing, so use dataLowDepth as offset
      //evalSwap uses relative indexing, so no offset needed

      
      int printOffset = dataLowDepth;
      int offset = printOffset - IRutil::AIFoffset;

      int maxDepth = numDataDepths - 1;

      int cpeval = rawEvalsCP->at(0).at(offset + maxDepth);

      bestEvalsCP.at(maxDepth) = cpeval;
      int dp; //depth probe
 
      for (int i = 0; i < numMovesWithValues; i++) { 
         dp = maxDepth;

         //first compute the highest-depth valid value for this move.
         while (dp >= 0 && rawEvalsCP->at(i).at(dp+offset) == IRutil::NAVAL) {
            dp--; 
         }
         if (dp < 0) {
            cerr << "Move with no analysis read as NA." << endl;
            continue;  //fill with cpeval?
         }
         //else

         int lastVal = rawEvalsCP->at(i).at(dp+offset); //last valid value

         for (int d = maxDepth; d >= 0; d--) {
            cpeval = rawEvalsCP->at(i).at(d+offset);
            if (cpeval == IRutil::NAVAL) {
               cpeval = lastVal;
            } else if (cpeval == IRutil::NRECVAL) {
               cpeval = worstEvalsCP.at(d);
               //May be incorrect when different moves are NREC (e.g. beyond
               //Houdini's 32 at different depths, but judge extra error here
               //minimal compared to the fuzz of the 32-PV limit to begin with
               //Update: With 64-PV now we can ignore this.
               lastVal = cpeval;

            } else if (cpeval == IRutil::PRUNVAL) {
               cpeval = bestEvalsCP.at(d) - btm*int(100*IRutil::PRUNCAP);
               lastVal = cpeval;
            } else { //a real eval
               lastVal = cpeval;
            }

            evalSwap->at(d).at(i) = cpeval;

            if (btm*cpeval > btm*bestEvalsCP.at(d)) {
               bestEvalsCP.at(d) = cpeval;
if (i >= pParent->consideredMoves->size()) { 
cerr << "Trouble in " + string(*pParent);
} else {
               //bestMoveVec.at(d) = pParent->consideredMoves->at(i);
               indexFirstMoveVec.at(d) = i;  //will stay first occurrence
}
            }
            if (btm*cpeval < btm*worstEvalsCP.at(d)) {
               worstEvalsCP.at(d) = cpeval;
            }
         }
      }


      //At this point, no NA, PRUN, or NREC values are left.
      //Following is main place in code where deltas are scaled by "mapDelta"

      double myeval, beval, delta;   //in pawn 0.00 units

      TupleInfo* ptis;  //last value is top-depth deltas
      TupleInfo* ptiu;
      for(int dd = 0; dd < numDataDepths; ++dd) { 
         vector <double>* pDeltas = new vector<double>(); 
         double deltaFalloff; 
 
         for(int j = 0; j < numMovesWithValues; j++) { 
            myeval = (evalSwap->at(dd).at(j))/double(100);

            beval = (bestEvalsCP.at(dd))/double(100);
            delta = btm*(beval - myeval);
            //Should be nonnegative

if (delta < 0.0) {
   cerr << "NegD for j = " << j << ": " << pParent->movePlayed << ": " << delta << " at depth "
        << (dd+printOffset) << ", eval " << myeval << ", bestEval " << beval << endl;
}
 
            pDeltas->push_back(delta); 
         } 

         TurnContext* tc = new TurnContext(pParent->movePlayed,
                                           pParent->engineID,
                                           pParent->whiteToMove,
                                           beval,
                                           (pParent->prevEvalCP)/double(100),
                                           (pParent->nextEvalCP)/double(100));
         //Used by mapDelta.  Note that we use the depth-d current eval, but
         //the highest-depth eval from the previous and/or next turns (if any).
         //(!!! Maybe change that...?)

         bestEvals.push_back(bestEvalsCP.at(dd)/double(100));
         worstEvals.push_back(worstEvalsCP.at(dd)/double(100));
         //bestMoveByDepth.push_back(bestMoveVec.at(dd));
         indexFirstMoveAtDepth.push_back(indexFirstMoveVec.at(dd));

         ptiu = makeTuple(pDeltas,tc,false,theScale->getSwingPolicy(),false); //does not delete pDeltas yet
         ptis = makeTuple(pDeltas,tc,true,theScale->getSwingPolicy(),false);
         scaledFalloff.push_back(ptis->pScaledDeltas->at(playedMoveIndex));
         unscaledFalloff.push_back(ptiu->pScaledDeltas->at(playedMoveIndex));
         depthDeltasScaled.push_back(ptis); 
         depthDeltasUnscaled.push_back(ptiu);

         delete(pDeltas);
         delete(tc);
      } //end for int dd.  **At this point, non-window method calls work.**
        //Now do loop again to compute swing w.r. to theScale->judgmentDepth

      size_t jd = (theScale->getJudgmentDepth() == 0 ? dataHighDepth
                   : max(min(theScale->getJudgmentDepth(), dataHighDepth), dataLowDepth));
      TupleInfo* tijd = getDepthInfoScaled(jd);

      size_t userSwingLow = theScale->getSwingLow();
      size_t userSwingHigh = theScale->getSwingHigh();
      if (userSwingHigh < userSwingLow) {    //swing disabled in scale
         userSwingLow = dataLowDepth;
         userSwingHigh = dataHighDepth;
      }
      //int swingOffset = (theScale->getZeroDepth() <= dataLowDepth ? 0
      //: theScale->getZeroDepth() - dataLowDepth);
      //size_t swingRelLow = (userSwingLow < dataLowDepth ? 0 : userSwingLow - dataLowDepth);
      //size_t swingRelHigh = (userSwingHigh > dataHighDepth ? dataHighDepth - dataLowDepth
      //: userSwingHigh - dataLowDepth);
    
      //int numSwingDepths = numDataDepths - swingOffset;
      //int numSwingDepths = swingRelHigh - swingRelLow + 1;

      size_t swadd = (userSwingLow <= jd && jd <= userSwingHigh) ? 0 : 1;
      size_t numSWs = userSwingHigh - userSwingLow + swadd;  //fill in others from endpoints
      //int numWindowsSwingDepths = (userHighDepth >= swingOffset ? userHighDepth - swingOffset + 1 : 0);

      
/*
      for (size_t ddd = userSwingLow; ddd <= userSwingHigh; ddd++) {
         TupleInfo* tid = getDepthInfoScaled(ddd);
         for (int k = 0; k < numMovesWithValues; k++) {
            decMoveSwings->at(k) += tid->pScaledDeltas->at(k)/double(numSWs);
         }
      }

      for (int k = 0; k < numMovesWithValues; k++) {
         decMoveSwings->at(k) -= tijd->pScaledDeltas->at(k); //normalizes
      }
*/

      SwingInfo* swp = theScale->getSwingPolicy();

      for (size_t k = 0; k < numMovesWithValues; k++) {
         double kjdel = tijd->pScaledDeltas->at(k);  //di->getDeltaScaled(k,jd);
         //judgment depth is included in min/max comparison, so can use to initialize
         double kMinDelta = kjdel;
         double kMaxDelta = kjdel;
         double kMeanDelta = 0.0;
         double djdel;  //outside loop so as to dampen swing by highest-depth delta
         for (size_t ddd = userSwingLow; ddd <= userSwingHigh; ddd++) {
            //tcusw->currEval = di->getBestEvalP(ddd);
            djdel = getDeltaScaled(k, ddd);
            kMeanDelta += djdel;
            if (ddd >= 5) {
               if (djdel < kMinDelta) { kMinDelta = djdel; }
               if (djdel > kMaxDelta) { kMaxDelta = djdel; }
            }
            decMoveSwings->at(k) += (djdel - kjdel)/numSWs; //normalizes
         }
         kMeanDelta /= double(userSwingHigh - userSwingLow + 1);
         //if (kMaxDelta > IRutil::DELTACAP) { 
            //kMaxDelta = IRutil::DELTACAP; 
         //}
         //if (kMinDelta > IRutil::DELTACAP) { kMinDelta = IRutil::DELTACAP; }
         //double mul = (decMoveSwings->at(k) > 0.0 ? 1.0 : 1.15);
         const double mul = 1.0;
         const double scaler = 1.0 + theScale->getEqualTopFix();
         double factor = 1.0;
         if (kMinDelta > IRutil::MINPROB && kMeanDelta > IRutil::MINPROB) {
            //size_t boxStart = swp.find("boxed");
            if (swp->boxed) {
               //char c = swp.at(boxStart+5);
               unsigned int bxk = (unsigned int)swp->boxKind;
               switch(bxk) {
                case 0:
                  factor = scaler;
                  break;
                case 1: 
                  factor = (kMaxDelta - kMinDelta)/kMaxDelta;
                  break;
                case 2:
                  factor = (kMeanDelta - kMinDelta)/kMeanDelta;
                  break;
                case 3: 
                  factor = 1.0 - kMinDelta/(kMaxDelta + kMinDelta);
                  break;  //note: with 1 in place of kMaxDelta this is same as "damped"
                case 4:
                  factor = 1.0 - kMinDelta/(kMeanDelta + kMinDelta);
                  break;
                case 5:
                  factor = kMaxDelta/(2.0*kMeanDelta);
                  break;
                case 6:
                  //factor = kMaxDelta*kjdel/((kjdel + kMinDelta)*kMeanDelta);
                  factor = 1.0 - kMinDelta*kMinDelta/((scaler + kMinDelta)*kjdel);
                  break;
                case 7:
                  factor = (kMaxDelta - kMinDelta)/(kMaxDelta + kMinDelta);
                  break;
                case 8:
                  factor = IRutil::sqr((kMaxDelta - kMinDelta)/kMaxDelta);
                  break;
                case 9:
                  factor = sqrt((kMaxDelta - kMinDelta)/kMaxDelta);
                  break;
                default:
                  factor = (kMaxDelta - kMinDelta)/kMaxDelta;
               }
               //boxStart += 6;
               //if (boxStart < swp.size() && swp.at(boxStart) == 'a') {
                  //factor *= log(1 + (kjdel/kMinDelta));
               //} else if (boxStart < swp.size() && swp.at(boxStart) == 'b') {
                  //factor *= kjdel/kMeanDelta;
               //}
            } else {
               double kHiDelta = (jd < userSwingHigh ? djdel : kjdel);
               const double damp1 = (swp->prop ? 1.0 : 0.0);
               const double damp2 = (swp->damped ? 1.0 : 0.0);
               factor = scaler/(scaler + damp1*kHiDelta + damp2*kMinDelta);
            }
            decMoveSwings->at(k) *= mul*factor;
         }
      }

   } 

   void resetWindow() {   //REQ: processTurnInfo called first

      windowDeltasScaled.clear();
      windowDeltasUnscaled.clear();
      windowBests.clear();
      windowWorsts.clear();
      for (size_t j = userLowDepth; j <= userHighDepth; j++) {
         int k = min(max(j,dataLowDepth), dataHighDepth) - dataLowDepth;
         windowDeltasScaled.push_back(depthDeltasScaled.at(k)); //pushes existing TupleInfo*, not new
         windowDeltasUnscaled.push_back(depthDeltasUnscaled.at(k));
         windowBests.push_back(bestEvals.at(k));
         windowWorsts.push_back(worstEvals.at(k));
      }
   }
   //ENS: window vectors have same indices as weights held by Trial.
         
 
   operator string() const { 
      string out = string(*pParent) + "\n";
      out += string("Cap: deltaCap ") + IRutil::ftoa(deltaCap) + ", falloff: " 
          + IRutil::ftoa(turnFalloffCapped) + ", played move index: " 
          + IRutil::itoa(playedMoveIndex) + "\n";

      for (size_t ii = 0; ii < depthDeltasScaled.size(); ii++) {
         out += IRutil::itoa(ii+dataLowDepth,2) + ": " 
             + string(*(depthDeltasScaled.at(ii))) + "\n";
      }

      return out; 
   }  


 
}; 
 
#endif    //end of #ifndef __IR_DECISION_INFO_H__ 
 


 
//File-----------------------IRmodels.h----------------------------------- 

/**
A "Model" is defined by the function f on the left-hand side of the equation

    f(p_i)
    ------   =   g_c(x_i)           where x_i = scalediff(v_i,v_0)/s
    f(p_0)

The case f(p) = p is called "Shares", and gives p_i = p_0*g_c(x_i).
The case f(p) = lop(p) --- actually, f(p) = 1/log(1/p) --- gives
p_i = p_0^{1/g_c(x_i)} and is (hence) called "PowerShares".  

In each case the depth d parameter is reflected by taking a weighted
linear combination over depths in a "window" lo..hi, with weights according
to Poisson distribution.  The variation v parameter affects only the
concentration of the distribution, as its "coefficient of variation":
v = 1 gives pure Poisson, v = 0 puts all weight on the two integer neighbors
of d, and v --> infty creates a uniform (i.e., "flat") distribution on the 
window.  The four fittable parameters come from the TrialSpec, while the
window values lo,hi and also the zero-point z of the Poisson distribution
are set by the DeltaScale in effect.  

The rules for the window are as follows: The data class DecisionInfo 
maintains fields dataLowDepth and dataHighDepth giving the actual range
of depths output in the chess engine analysis.  In particular, dataLowDepth
is the least value k for which some move has a numerical value not "n.a."

(Whereas TurnInfo has range turnLowestDepth..turnHighestDepth including "n.a." columns.)
Note: The code allows for "n.a." columns at either end more than the engine standardly gvies.

The user window userLowDepth..userHighDepth is allowed to extend outside
dataLowDepth...dataHighDepth, with no restriction other than 
0 <= z <= userLowDepth (maybe better 1 <= z <= userLowDepth).
The Poisson weights vector is generated as pw[z..userHighDepth] with pw[userHighDepth]
including the tail to infinity.  Then the values in pw[z..userLowDepth-1]
are added to pw[userLowDepth] to make pw'[userLowDepth..userHighDepth]. 
Finally to make the depth-weights vector dw we do:

lo = max{userLowDepth,dataLowDepth}
hi = min{userHighDepth,dataHighDepth}
dw[lo] = pw[userLowDepth] + ... + pw[lo]
dw[hi] = pw[hi] + ... pw[userHighDepth]
dw[j] = pw[j] for lo < j < hi, which all satisfy dataLowDepth < j < dataHighDepth too.


**Tamal: this is a change from duplicating tuples in DecisionInfo to cover
cases where userLowDepth < dataLowDepth in particular.  The code in processTurnInfo that
overwrites initial "n.a."'s by values at the next-higher depths may still be
necessary, however, as I think there are cases where "n.a." happens at a
depth for which other moves have values, cases where it might not be really
a "PRUN" or "NREC" (?---not sure, but anyway that code can't hurt).
It may be silly to allow z < lo, but anyway I think little is lost by it.

The final issue is when the depth-weighting is done.  It can be applied to
the raw evaluations (even before scaling) to create a "perceived value" 
estimate for each move.  Then delta-differences are taken and scaled, still
using the best-move-at-highest-depth ordering of the DecisionInfo class
itself (hence taking care that the deltas while still nonnegative might not 
be monotonically increasing), to create a TupleInfo object that is treated
as in the old version of the model.  The "official" way (methodologically
sounder, IMO) is to use the TupleInfo for each depth given by DecisionInfo,
compute the probabilities p_{i,k} for each depth k, then 

                     p_i = \sum_k dw[k]p_{i,k}

In this sum, I think it is OK to limit k to lo <= k <= hi.  I had originally
thought I might want to preserve information about every depth in userLowDepth..userHighDepth,
but for userLowDepth <= k < lo there really isn't any new information. 
Bottom line is that the windowing nomenclature should be (IMHO):

1. TurnInfo has fields dataLowDepth, dataHighDepth, while the evals-array has
indexing [0 .. dataHighDepth-dataLowDepth]
2. DecisionInfo has the same fields, with similar indexing for the
"inside-out" evalSwap array.
3. DeltaScale has the fields userLowDepth,userHighDepth,z (remove the first two from TrialSpec).
4. Only the code here computes lo and hi.
 */
 
#ifndef __IR_MODELS_H__ 
#define __IR_MODELS_H__ 
 
#ifndef __IR_TUPLE_INFO_H__
#include "TupleInfo.h"
#endif

#ifndef __IR_DECISION_INFO_H__
#include "DecisionInfo.h"
#endif


namespace Models { 
 
   typedef vector<double> (*ModelProbs) (const TupleInfo* const ti, 
                                         const TrialSpec& ts); 
 
   enum MODEL {  
      SHARES,  
      POWER_SHARES,  
      //ENTROPY_SHARES, 
      NUM_MODELS 
   }; 

   /** Non-POD struct.  Should be kept by pointer and not copied, unlike TrialSpec.
    */
   struct MoveProjection {    //POD but with a pointer that caller takes charge of
      CurveApplication* proxies;
      vector<double>* probs;
      string firstMove;
      string highestProbMove;
      string playedMove;
      size_t indexFirstMove;        //top rank at judgment depth
      size_t indexHighestProbMove;  //initialized via swapIndex in getProbs(...)
      size_t indexPlayedMove;       //index of its prob in probs vector
      size_t rankPlayedMove;        //rank at judgment depth
      size_t equalTopIndexLimit;    //equal-top moves beyond this not counted as matches
      double probFirstMove;
      double probEqualTopMove;
      double probPlayedMove;
      double highestProb;
      double playedMoveDeltaScaled;
      double projFalloffScaled;
      double projFalloffVarianceScaled;
      double playedMoveDeltaUnscaled;
      double projFalloffUnscaled;
      double projFalloffVarianceUnscaled;
      double projLogSumScaled;
      double projLogSumUnscaled;
      double projEntropySumScaled;
      double projEntropySumUnscaled;
      double weight;  //previous fields are NOT already weighted.
      bool deleteSwingsHere;
      const vector<double>* swingsUsed;  //always set from outside; caller deletes(?)

      explicit MoveProjection(bool dds = true) : probs(NULL), proxies(NULL), firstMove("")
       , highestProbMove("") , playedMove(""), indexFirstMove(0), indexHighestProbMove(0), indexPlayedMove(0)
       , equalTopIndexLimit(IRutil::NCUTOFF)    //rankPlayedMove set later, not initialized 
       , probFirstMove(0.0), probEqualTopMove(0.0), probPlayedMove(0.0), highestProb(0.0)
       , playedMoveDeltaScaled(0.0), projFalloffScaled(0.0), projFalloffVarianceScaled(0.0)
       , playedMoveDeltaUnscaled(0.0), projFalloffUnscaled(0.0), projFalloffVarianceUnscaled(0.0)
       , projLogSumScaled(0.0), projLogSumUnscaled(0.0), projEntropySumScaled(0.0)
       , projEntropySumUnscaled(0.0), weight(0.0), deleteSwingsHere(dds), swingsUsed(NULL)
      { }
      virtual ~MoveProjection() { 
         delete(proxies);
         delete(probs); 
         if (deleteSwingsHere) { delete swingsUsed; }
      }  //usages should be pointers or const& 
   };

   inline vector<double>* fudgePatch(const size_t numw, const double patchPower);
   inline void patchProbs(vector<double>* probs, double patchPower);
      

   //Does not require swapping min/max to first index
   //inline vector<double> probsShares(const TupleInfo* const ti,  
   inline MoveProjection* probsShares(const TupleInfo* const ti,
                                      const TrialSpec& ts) {
      MoveProjection* mp = new MoveProjection(ti->swingsWereSetNew);
      mp->proxies = ti->applyCurve(ts);  //treated as own copy
      double pj;
      const size_t numProbs = mp->proxies->values.size();
      //vector<double> probs(numProbs);
      mp->probs = new vector<double>(numProbs);  //not init
      mp->swingsUsed = ti->moveSwings;
      mp->indexHighestProbMove = mp->proxies->swapIndex;  //other fields filled by callers
      double sumShares = 0.0; 
      for (int i = 0; i < numProbs; i++) { 
         sumShares += mp->proxies->values.at(i); 
      } 
 
      //test for fixing distortion removed 
      for (int j = 0; j < numProbs; j++) { 
         pj = mp->proxies->values.at(j) / sumShares;  //can be 1/INF 
         mp->probs->at(j) = (pj > IRutil::MINPROB ? pj : IRutil::MINPROB); 
      } 
      if (ti->patchesProbs) { patchProbs(mp->probs, ti->patchPower); }
      return mp;
   } 

 

   /**
       Requires permuting the applications to have min value in first index.
       Combines three measures to combat "inf" and "NaN" values: 
          () "invert" has a MAXINV cap, 
          () vectorRoot imposes a maximum probability for the first move, 
          () MINPROB puts a nonzero floor for probabilities of other moves. 
    */ 
   inline MoveProjection* probsPowerShares(const TupleInfo* const ti, 
                                           const TrialSpec& ts) {
      //vector<double> inverses = IRutil::invera(ti->applyCurve(ts)); 
      MoveProjection* mp = new MoveProjection(ti->swingsWereSetNew);
      mp->proxies = ti->applyCurve(ts);  //treated as own copy
      double swap = mp->proxies->values.at(mp->proxies->swapIndex);
      mp->proxies->values.at(mp->proxies->swapIndex) =  mp->proxies->values.at(0);
      mp->proxies->values.at(0) = swap;
      vector<double> inverses = IRutil::anvert(mp->proxies->values, ti->swingPolicy->transPower);
      size_t sz = inverses.size(); 
      mp->probs = new vector<double>(sz);
      mp->swingsUsed = ti->moveSwings;
      mp->indexHighestProbMove = mp->proxies->swapIndex;  //other fields filled by callers
      //vector<double> probs(sz); 
      double p0, pj; 
      {  //distortion-fixing test removed 
         p0 = (sz == 1 ? 1.0 : IRutil::vectorRoot(inverses, 1.0)); 
         mp->probs->at(0) = p0; 
         for (int j = 1; j < sz; j++) { 
            pj = pow(p0,inverses.at(j)); 
            mp->probs->at(j) = (pj > IRutil::MINPROB ? pj : IRutil::MINPROB); 
         } 
      } 
      if (mp->indexHighestProbMove > 0) {
         swap = mp->probs->at(mp->proxies->swapIndex);
         mp->probs->at(mp->proxies->swapIndex) = mp->probs->at(0);
         mp->probs->at(0) = swap;
         //swap back proxy values too just for show
         swap = mp->proxies->values.at(mp->proxies->swapIndex);
         mp->proxies->values.at(mp->proxies->swapIndex) =  mp->proxies->values.at(0);
         mp->proxies->values.at(0) = swap;
      }
      double dbg = 0.0;
      for (size_t m = 0; m < mp->probs->size(); m++) { dbg += mp->probs->at(m); }
      double test = fabs(1.0 - dbg);
      if (test > IRutil::SUMPROBSTOLERANCE) {
         if (test > IRutil::SHOUTTOLERANCE) {
            cerr << "Got sum " << dbg << " from p0 = " << p0 << " and inverses:" << endl;
            for (int i = 0; i < inverses.size(); i++) {
               cerr << inverses.at(i) << " ";
               if ((i + 1) % 10 == 0) { cerr << endl; }
            }
            cerr << endl;
         }
         IRutil::normalizeP(mp->probs);
      }
      if (ti->patchesProbs) { patchProbs(mp->probs, ti->patchPower); }
      return mp;
   } 


   /** Scales afterward.  The depthWts are an indirect dependence on TrialSpec, 
       judgmentDepth a possible one.  That is why the routine is here.
       It is possible that the judgmentDepth argument may override the one in theScale.
       Depth arguments in DecisionInfo methods are absolute, but the depthWts and
       SwingWts vectors are indexed from 0.  However, they obey the invariants that
       depthWts.size() = uhd - uld + 1, swingWts.size() = uswhi - uswlo + 1.
       So the code simply iterates over them.  
    */
   inline TupleInfo* perceivedTuple(const DecisionInfo* const di, 
                                    const vector<double>* depthWts,
                                    const vector<double>* swingWts,
                                    size_t judgmentDepth) {
   //REQ: depthWts.size() = hi - lo + 1 in the following.
   //And swingWts.size() = swhi - swlo + 1 likewise.
      int uld = di->theScale->getLowDepth();
      int uhd = di->theScale->getHighDepth();
      int lo = min(max(uld,int(di->dataLowDepth)),int(di->dataHighDepth));
      //"min" part covers cases like z = uld = 2 but move has depth-1 only.
      int hi = min(uhd,int(di->dataHighDepth));

      int numDWs = uhd - uld + 1;
      int numPWs = hi - lo + 1;   //so lo serves as offset to absolute depths

      vector<double> probWts(numPWs,0.0);
      int i,j;
      for (i = 0; i <= lo - uld; i++) {
         probWts.at(0) += depthWts->at(i);
      }
      for (j = 1; j < numPWs; j++) {
         probWts.at(j) = depthWts->at(lo-uld+j);
      }
      for (i = max(hi-uld+1,0); i < numDWs; i++) {
         probWts.at(numPWs-1) += depthWts->at(i);
      }


      size_t ell = di->getNumMovesWithValues();

      vector<double> perceivedEvals(ell,0.0);
      int btm = di->pParent->whiteToMove ? 1 : -1;
      double maxPE = btm*(-IRutil::MATEVAL);  //from White's viewpoint

      for (size_t i = 0; i < ell; i++) {
         for (size_t d = 0; d < numPWs; d++) {
            perceivedEvals.at(i) += di->getEvalP(i,d+lo)*probWts.at(d);//in 0.00 units
         }
         if ((btm*perceivedEvals.at(i)) > (btm*maxPE)) {
            maxPE = perceivedEvals.at(i); //move with max perceived eval need not be first one
         } 
      }

      TurnContext* tc = new TurnContext(di->pParent->movePlayed, 
                                        di->pParent->engineID,
                                        btm == 1,
                                        maxPE,
                                        di->pParent->prevEvalCP/100.0,
                                        di->pParent->nextEvalCP/100.0);
      //TurnContext* tcusw = new TurnContext(*tc);  //default copy constructor

      vector<double>* perceivedDeltas = new vector<double>(ell);
      for (size_t k = 0; k < ell; k++) {
         perceivedDeltas->at(k) = btm*(maxPE - perceivedEvals.at(k));
      }
      SwingInfo* swp = di->theScale->getSwingPolicy();


      TupleInfo* ti = di->makeTuple(perceivedDeltas, tc, true, swp, true); 
      //last arg makes perceived, and so deletes perceivedDeltas & tc



      if (swp->noSwing || (!swp->depthDependentSwings)) {
         return ti; 
      }  //else we use a depth-dependent swing measure


      size_t userSwingLow = di->theScale->getSwingLow();  //not assumed in range of data
      size_t userSwingHigh = di->theScale->getSwingHigh();
      
      size_t jd = (judgmentDepth == 0 ? di->dataHighDepth
                                      : min(judgmentDepth, di->dataHighDepth));
      jd = max(userSwingLow, jd);
      size_t swadd = 1;
      double skipProb = 0.0;
      if (userSwingLow <= jd && jd <= userSwingHigh) {
         skipProb = swingWts->at(jd - userSwingLow);
         swadd = 0;
      }
      //double hieval = di->getBestEvalP(jd);
      //tcusw->currEval = hieval;
      size_t numSWs = userSwingHigh - userSwingLow + swadd;
      
      vector<double>* userSwings = new vector<double>(ell, 0.0); //accumulated not assigned
      for (size_t j = 0; j < ell; j++) {
         double jdel = di->getDeltaScaled(j,jd);
         //double jMinDelta = IRutil::MATEVAL;  //jdel;  //judgment depth is included in the comparisons
         //double jMaxDelta = -IRutil::MATEVAL; //jdel;
         double jMinDelta = jdel;
         double jMaxDelta = jdel;
         double jMeanDelta = 0.0;
         double djdel;  //so is highest-depth delta even if jd is inside.
	 for (size_t d = 0; d < numSWs; d++) {
            size_t absDepth = d + userSwingLow;
            //tcusw->currEval = di->getBestEvalP(absDepth);
            djdel = di->getDeltaScaled(j, absDepth);
            jMeanDelta += djdel;
            if (absDepth >= 5) {
               if (djdel < jMinDelta) { jMinDelta = djdel; }
               if (djdel > jMaxDelta) { jMaxDelta = djdel; }
            }
            userSwings->at(j) += (swingWts->at(d) + skipProb/double(numSWs))*(djdel - jdel); //normalizes
         }
         jMeanDelta /= double(userSwingHigh - userSwingLow + 1);


         //if (jdel < jMinDelta) { jMinDelta = jdel; }
         //if (jdel > jMaxDelta) { jMaxDelta = jdel; }

         //Now we want to scale down according to minDelta and/or jHiDelta, but we also
         //want to keep the swings dimensioned in centipawns, not to become dimensionless.
         //Hence the idea of "boxed".
         
         //if (jMaxDelta > IRutil::DELTACAP) { 
            //jMaxDelta = IRutil::DELTACAP; 
         //}
         //if (jMinDelta > IRutil::DELTACAP) { jMinDelta = IRutil::DELTACAP; }
         //double mul = (userSwings->at(j) > 0.0 ? 1.0 : 1.15);
         const double mul = 1.0;
         const double scaler = 1.0 + di->theScale->getEqualTopFix();
         double factor = 1.0;
         if (jMinDelta > IRutil::MINPROB) {
            //size_t boxStart = swp.find("boxed");
            if (swp->boxed) {
               //char c = swp.at(boxStart+5);
               unsigned int bxk = (unsigned int)swp->boxKind;
               switch(bxk) {
                case 0:
                  factor = scaler;
                  break;
                case 1:
                  factor = (jMaxDelta - jMinDelta)/jMaxDelta;
                  break;
                case 2:
                  factor = (jMeanDelta - jMinDelta)/jMeanDelta;
                  break;
                case 3:
                  factor = 1.0 - jMinDelta/(jMaxDelta + jMinDelta);
                  break;  //note: with 1 in place of kMaxDelta this is same as "damped"
                case 4:
                  factor = 1.0 - jMinDelta/(jMeanDelta + jMinDelta);
                  break;
                case 5:
                  factor = jMaxDelta/(2.0*jMeanDelta);
                  break;
                case 6:
                  //factor = jMaxDelta*jdel/((jdel + jMinDelta)*jMeanDelta);
                  factor = 1.0 - jMinDelta*jMinDelta/((scaler + jMinDelta)*jdel);
                  break;
                case 7:
                  factor = (jMaxDelta - jMinDelta)/(jMaxDelta + jMinDelta);
                  break;
                case 8:
                  factor = IRutil::sqr((jMaxDelta - jMinDelta)/jMaxDelta);
                  break;
                case 9:
                  factor = sqrt((jMaxDelta - jMinDelta)/jMaxDelta);
                  break;
                default:
                  factor = (jMaxDelta - jMinDelta)/jMaxDelta;
               }
               //boxStart += 6;
               //if (boxStart < swp.size() && swp.at(boxStart) == 'a') {
                  //factor *= log(1 + (jdel/jMinDelta));
               //} else if (boxStart < swp.size() && swp.at(boxStart) == 'b') {
                  //factor *= jdel/jMeanDelta;
               //}
            } else {
               double jHiDelta = (jd < userSwingHigh ? djdel : jdel);
               const double damp1 = (swp->prop ? 1.0 : 0.0);
               const double damp2 = (swp->damped ? 1.0 : 0.0);
               factor = scaler/(scaler + damp1*jHiDelta + damp2*jMinDelta);
            }
            userSwings->at(j) *= mul*factor;
            if (!(userSwings->at(j) <= 0.0 || userSwings->at(j) > 0.0)) {
               cerr << "Bad value usw[" << j << "] = " << userSwings->at(j) << " in turn" << endl
                    << string(*di) << endl;
               IRutil::PROBLEM_FENS.insert(di->pParent->getFEN());
               IRutil::PROBLEM_GAMES.insert(di->pParent->gameID + "\n" + di->pParent->getFEN());
            }
         }
      }

      ti->setSwings(userSwings);  //will be deleted when ti is deleted
      return ti;
   }

   
//TrialSpec has "d" in absolute terms; DecisionInfo maintains relative terms
//internally but uses absolute depths as arguments.
 
   inline MoveProjection* getProbsShares(const DecisionInfo* const di,  
                                         const TrialSpec& ts,
                                         const vector<double>* depthWts,
                                         const vector<double>* swingWts,
                                         const double judgmentDepth) {

      if (di->theScale->weightsEvalsFirst()) {   //fff
         TupleInfo* ti = perceivedTuple(di, depthWts, swingWts, judgmentDepth); //news ti
         //vector<double> vee = probsShares(ti,ts);
         MoveProjection* mp = probsShares(ti,ts);
         delete(ti);
         return mp;
      } //else
      MoveProjection* mp = new MoveProjection(false);
      //vector<double> probs(di->getNumMovesWithValues(), 0.0);
      mp->probs = new vector<double>(di->getNumMovesWithValues(), 0.0);
      for (size_t depth = 0; depth < depthWts->size(); depth++) { 
         TupleInfo* ti = di->getWindowInfoScaled(depth); 

         MoveProjection* mpd = probsShares(ti,ts);
         //vector<double> dprobs = probsShares(ti,ts); 

         for (size_t i = 0; i < ti->numDeltas; i++) { 
            //probs.at(i) += depthWts->at(depth)*dprobs.at(i); 
            mp->probs->at(i) += depthWts->at(depth) * mpd->probs->at(i);
         } 
         delete(mpd);
      } 
      double dbg = 0.0;
      for (size_t m = 0; m < mp->probs->size(); m++) { dbg += mp->probs->at(m); }
      if (fabs(1.0 - dbg) > IRutil::SUMPROBSTOLERANCE) {
         cerr << "Bad Poisson-weighting combination" << dbg << endl;
         IRutil::normalizeP(mp->probs);
      }

      return mp; 
   } 
 
   inline MoveProjection* getProbsPowerShares(const DecisionInfo* const di,  
                                              const TrialSpec& ts,
                                              const vector<double>* depthWts,
                                              const vector<double>* swingWts,
                                              const double judgmentDepth) {
   //(OLD) Now assume that depthWts is aligned with di->windowDeltasScaled


      MoveProjection* mp;
      if (di->theScale->weightsEvalsFirst()) {   
         //TupleInfo* ti = perceivedTuple(di, ts, probWts);
         TupleInfo* ti = perceivedTuple(di, depthWts, swingWts, judgmentDepth); //news ti
         mp = probsPowerShares(ti,ts);
         delete(ti);
         return mp;
      }
      //else
      //vector<double> probs(di->pParent->numLegalMoves, 0.0);
      //vector<double> probs(di->getNumMovesWithValues(), 0.0);
      mp = new MoveProjection(false);
      mp->probs = new vector<double>(di->getNumMovesWithValues(), 0.0);
      for (size_t depth = 0; depth < depthWts->size(); depth++) {
         TupleInfo* ti = di->getWindowInfoScaled(depth);   //not new

         MoveProjection* mpd = probsPowerShares(ti,ts);

         for (size_t i = 0; i < ti->numDeltas; i++) { 
            mp->probs->at(i) += depthWts->at(depth) * mpd->probs->at(i);     
         } 
         delete(mpd);
      } 
      double dbg = 0.0;
      for (size_t m = 0; m < mp->probs->size(); m++) { dbg += mp->probs->at(m); }
      if (fabs(1.0 - dbg) > IRutil::SUMPROBSTOLERANCE) {
         cerr << "Bad Poisson-weighting combination" << dbg << endl;
         IRutil::normalizeP(mp->probs);
      }
      return mp; 
   } 
 
   //Now fills in all fields of mp, so that caller doesn't have to.
   inline MoveProjection* getProjection(const DecisionInfo* const di, 
                                        const TrialSpec& ts,  
                                        const vector<double>* depthWts,
                                        const vector<double>* swingWts,
                                        const MODEL model,
                                        const size_t equalTopIndexLimit = IRutil::NCUTOFF) {
      MoveProjection* mp;
      size_t jd = di->theScale->getJudgmentDepth();
      size_t useDepth = ((jd == 0 || jd >= di->dataHighDepth) ? di->dataHighDepth
                             : (jd <= di->dataLowDepth ? di->dataLowDepth : jd));
      switch(model) { 
       case SHARES: 
         mp = getProbsShares(di,ts,depthWts,swingWts,useDepth);
         break;
       case POWER_SHARES: 
         mp = getProbsPowerShares(di,ts,depthWts,swingWts,useDepth);
         break;
       case NUM_MODELS: 
       default: 
         cerr << "Bad model choice in getProjection(...), using PowerShares" << endl; 
         mp = getProbsPowerShares(di,ts,depthWts,swingWts,useDepth);
      } 
      size_t numDeltas = mp->probs->size();
      size_t pmi = di->getPlayedMoveIndex();
      mp->indexPlayedMove = pmi;
      mp->firstMove = di->pParent->engineMove;
      mp->playedMove = di->pParent->movePlayed;
      mp->highestProbMove = di->pParent->consideredMoves->at(mp->indexHighestProbMove);
      
      mp->rankPlayedMove = (useDepth >= di->dataHighDepth ? mp->indexPlayedMove
                            : di->getRankAtDepth(mp->indexPlayedMove,useDepth));
      mp->indexFirstMove = (useDepth >= di->dataHighDepth ? 0
                                : di->getIndexFirstMoveAtDepth(useDepth));

      mp->probFirstMove = mp->probs->at(mp->indexFirstMove);
      mp->probPlayedMove = mp->probs->at(pmi);   //not probs.at(playedRank), keyed to move not index
      //mp.playedMoveIndex = playedRank;
      //mp->topMoveProb = 0.0;
      //
      int i = 1;
      mp->equalTopIndexLimit = min(equalTopIndexLimit,numDeltas-1);
      if (useDepth >= di->dataHighDepth) {   //theScale->getJudgmentDepth() == 0) {
         mp->probEqualTopMove = mp->probFirstMove;
         while (i <= mp->equalTopIndexLimit
             && di->getEvalP(i,di->dataHighDepth) == di->getEvalP(0,di->dataHighDepth)) {
            mp->probEqualTopMove += mp->probs->at(i);
            i++;
         }
      } else {
         for (i = 0; i < numDeltas; i++) {
            if (di->getEvalP(i,useDepth) == di->getBestEvalP(useDepth)
                   && di->getRankAtDepth(i,useDepth) <= mp->equalTopIndexLimit) {
               mp->probEqualTopMove += mp->probs->at(i);
            }
        }
      }


      double pj = mp->probs->at(pmi);
                   // (pmi != IRutil::playedMoveNotInTopN   //pmi, NOT playedRank
                   // || (fixDistortion && treatMissAsMoveNN)) ? mp->probs->at(pmi) : 0.0;
      if (pj < IRutil::MINPROB) { pj = IRutil::MINPROB; }
      mp->probPlayedMove = pj;

      mp->playedMoveDeltaScaled = (useDepth >= di->dataHighDepth //theScale->getJudgmentDepth() == 0
                                  ? di->getHighestDepthMoveDeltaScaled(pmi)
                                  : di->getDeltaScaled(pmi,useDepth)); 
      mp->playedMoveDeltaUnscaled = (useDepth >= di->dataHighDepth //theScale->getJudgmentDepth() == 0
                                     ? di->getHighestDepthMoveDeltaUnscaled(pmi)
                                     : di->getDeltaUnscaled(pmi,useDepth));

      /*  Projection routines for error/falloff.  Convention is that we:
      (*) Use the probabilities computed over all depths according to current depthWeights.
      (*) Use only the error values at the judgment depth.
          Thus we create the TupleInfo object from the judgment depth, and call previous routines.
       */


      const TupleInfo* const ti = (useDepth >= di->dataHighDepth ? di->getDepthInfoScaled(jd) 
                                                                 : di->getHighestTupleScaled());
      const TupleInfo* const tiu = (useDepth >= di->dataHighDepth ? di->getDepthInfoUnscaled(jd) 
                                                                  : di->getHighestTupleUnscaled());
      double ds,du,pri,logpri,sqrds,sqrdu;

      for (size_t i = 0; i < ti->numDeltas; i++) {
         pri = mp->probs->at(i);
         pri = (pri < IRutil::MINPROB ? IRutil::MINPROB: pri);
         ds = ti->pScaledDeltas->at(i);  //cap already applied
         mp->projFalloffScaled += pri * ds;  //cap already applied
         du = tiu->pScaledDeltas->at(i);
         mp->projFalloffUnscaled += pri * du;
         logpri = IRutil::log2(1.0/pri);
         mp->projLogSumScaled += logpri * ds;
         mp->projLogSumUnscaled += logpri * du;
         mp->projEntropySumScaled += pri * logpri * ds;
         mp->projEntropySumUnscaled += pri * logpri * du;
      }
      if (mp->probs->size() == ti->numDeltas + 1) { //estimate falloff from last delta
         pri = mp->probs->at(ti->numDeltas);
         pri = (pri < IRutil::MINPROB ? IRutil::MINPROB: pri);
         mp->projFalloffScaled += pri * ds;
         mp->projFalloffScaled += pri * du;
         logpri = IRutil::log2(1.0/pri);
         mp->projLogSumScaled += logpri * ds;
         mp->projLogSumUnscaled += logpri * du;
         mp->projEntropySumScaled += pri * logpri * ds;
         mp->projEntropySumUnscaled += pri * logpri * du;
      }

      for (size_t i = 0; i < ti->numDeltas; i++) {
         pri = mp->probs->at(i);
         pri = (pri < IRutil::MINPROB ? IRutil::MINPROB: pri);
         sqrds = IRutil::sqr(ti->pScaledDeltas->at(i) - mp->projFalloffScaled);
         sqrdu = IRutil::sqr(tiu->pScaledDeltas->at(i) - mp->projFalloffScaled);
         mp->projFalloffVarianceScaled += pri * sqrds;
         mp->projFalloffVarianceUnscaled += pri * sqrdu;
      }
      if (mp->probs->size() == ti->numDeltas + 1) { //estimate falloff from last delta
         pri = mp->probs->at(ti->numDeltas);
         pri = (pri < IRutil::MINPROB ? IRutil::MINPROB: pri);
         mp->projFalloffVarianceScaled += pri * sqrds;
         mp->projFalloffVarianceUnscaled += pri * sqrdu;
      }

      vector<double>::const_iterator itr, itre, jtr, jtre;
      double p0;
      switch(ts.weightMethodChoice) {
       case IRfun::UNITWTS:
         mp->weight = 1.0;
         break;
       case IRfun::SUMWTS:
         mp->weight = 1.0/mp->probs->at(mp->indexHighestProbMove);
         break;
       case IRfun::LOGSUMWTS:
         mp->weight = log(1.0/mp->probs->at(mp->indexHighestProbMove));
         break;
       case IRfun::ENTROPYWTS:
         itre = mp->probs->end();
         for (itr = mp->probs->begin(); itr != itre; ++itr) {
            mp->weight += (*itr)*log(1.0/(*itr));
         }
         break;
       case IRfun::FALLOFFWTS:
         itr = mp->probs->begin();
         itre = mp->probs->end();
         jtr = ti->pScaledDeltas->begin();
         jtre = ti->pScaledDeltas->end();
         while (itr != itre && jtr != jtre) {
            mp->weight += (*itr++)*(*jtr++);
         }
         mp->weight /= ts.s;  //!!! was in older code too.
         break;
       case IRfun::INVVARP:
         p0 = min(mp->probs->at(mp->indexHighestProbMove), IRutil::P0TOLERANCE);
         mp->weight = min(IRutil::INVVARP0CAP, 1.0/(p0*(1.0 - p0)));
         break;
       default:
         cout << "Using Unit Weights, hope that's OK." << endl;
         mp->weight = 1.0;
      }

      return mp;
   } 
 
 
   /** Gives the (p_t,r_t) pair for a particular move t, but note: it 
       returns only the Endpt for "p"---you need the caller to swap 
       the two fields around to create the Endpt object for "r". 
    */ 
   inline IRutil::Endpt getProbEndpt(const DecisionInfo* const di, 
                             const TrialSpec& ts, 
                             const vector<double>* depthWts,
                             const vector<double>* swingWts,
                             const MODEL model,
                             size_t equalTopIndexLimit = IRutil::NCUTOFF) { 
      //vector<double> probs = getProbs(di,ts,depthWts,swingWts,model); 
      MoveProjection* mp = getProjection(di,ts,depthWts,swingWts,model,equalTopIndexLimit);
      //int pmi = ti->useAltPlayedMoveIndex ? ti->playedMoveIndex 
                                          //: ti->source->altPlayedMoveIndex; 
      int pmi = di->getPlayedMoveIndex(); 
      double cume = 0.0; 
      int i = 0; 
      while (i < pmi) {    //!!! needs change now
         //cume += probs.at(i); 
         cume += mp->probs->at(i);
         i++; 
      } 
      //return IRutil::Endpt(cume,cume+probs.at(i),getDecWeight(di,ts,probs)); 
      IRutil::Endpt endpt(cume, cume+mp->probs->at(i), mp->weight);
      delete(mp);
      return endpt;
   } 

   inline IRutil::Endpt getProbEndpt(MoveProjection* mp, const DecisionInfo* const di) {
      double cume = 0.0;
      int i = 0;
      while (i < mp->indexPlayedMove) {   //!! still needs change using di
         cume += mp->probs->at(i);
         i++;
      }
      return IRutil::Endpt(cume, cume+mp->probs->at(i), mp->weight);
   }


   /** Patched probabilities given by empirical testing with over 600,000 moves. 
    */ 
   inline vector<double>* fudgePatch(const size_t numw, const double patchPower) { 
      vector<double>* patchWeights = new vector<double>(numw); 
      //const double EMPIRICALFREQ = 0.5806; 
      //const double ratio = EMPIRICALFREQ/(1.0 - EMPIRICALFREQ); 
      const double ratio = patchPower/(1.0 - patchPower);
      double sum = 0.0; 
      double item = 1.0; 
      for (size_t i = 0; i < numw; i++) { 
         patchWeights->at(numw - i - 1) = item; 
         sum += item; 
         item = item*ratio; 
         //sum = sum*ratio + 1.0; 
      } 
      double dbg = 0.0; 
      for (size_t k = 0; k < numw; k++) { 
         patchWeights->at(k) = IRutil::divifgt0(patchWeights->at(k), sum); 
         dbg += patchWeights->at(k); 
      } 
      if (fabs(1.0 - dbg) > IRutil::SUMPROBSTOLERANCE) {  
         cerr << "Bad fudge\n"; 
         IRutil::normalizeP(patchWeights);
      } 
      return patchWeights; 
   } 
 
   inline void patchProbs(vector<double>* probs, double patchPower) { 
      const size_t s = probs->size(); 
      size_t i = 0; 
      while (i < s-1) { 
      //while (i < 1) {      //do only for equal-top 
         size_t j = i+1; 
         while (j < s && probs->at(j) >= probs->at(i) - IRutil::MINPROB) { 
            j++; 
         } 
         size_t diff = j - i; 
         if (diff > 1) { 
            double tp = 0.0; 
            size_t k = 0; 
            for (k = i; k < j; k++) { tp += probs->at(k); } 
            vector<double>* patchWeights = fudgePatch(diff, patchPower); 
            for (k = i; k < j; k++) { 
               probs->at(k) = tp * patchWeights->at(k-i); 
            } 
            delete(patchWeights);
            i = j; 
         } else { 
            i++; 
         } 
      } 
      double dbg = 0.0; 
      for (size_t m = 0; m < probs->size(); m++) { dbg += probs->at(m); } 
      if (fabs(1.0 - dbg) > IRutil::SUMPROBSTOLERANCE) { 
         cerr << "Really bad fudge: sum " << dbg << endl; 
         //IRutil::normalize(probs);
      } 
      //return probs; 
   } 
 
};        //end of namespace MODELS 
 
#endif    //end of #ifndef __IR_MODELS_H__ 
 
 

//File-------------------MoveSelector.h--------------------------------------

#ifndef __IR_MOVESELECTION_H__
#define __IR_MOVESELECTION_H__

#include <set>
#include <map>
#include <algorithm>

typedef bool (*MoveSelectorFn)(const TurnInfo* const, const Move&);

enum COMPARE { LEQ, EQ, GEQ };  //NOT < = >, but with <= and >=

class MoveSelector : public Catalogable {
 protected:        //C++: accessible to *immediate* subclasses only
   string name;
   bool excludeTurnIfEmpty;
   bool isSet;
   set<Move>* selectedMoves;  //changes with each turn
   MoveSelector(const string& gname, bool exc) 
    : name(gname), excludeTurnIfEmpty(exc), isSet(false), selectedMoves(new set<Move>()) 
   { }
   MoveSelector() 
    : name("anon"), excludeTurnIfEmpty(false), isSet(false), selectedMoves(new set<Move>()) 
   { }
 public:
   virtual ~MoveSelector() { delete(selectedMoves); }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const = 0;
   void makeExclude() { excludeTurnIfEmpty = true; }
   void makeInclude() { excludeTurnIfEmpty = false; }
   bool excludesTurnIfEmpty() const { return excludeTurnIfEmpty; }
   void declareSet() { isSet = true; }
   void makeSet(const TurnInfo* const pTurn) {
      selectedMoves->clear();
      vector<Move>::const_iterator itr = pTurn->legalMoves->begin();
      while (itr != pTurn->legalMoves->end()) {
         if (apply(pTurn, *itr)) {
            selectedMoves->insert(*itr);
         }
      }
      isSet = true;
   }

   /** Loading of turns is "lazy"---only when user wishes to iterate.  Hence side effect.
    *  Neat thing is that this code is needed only here in the abstract parent class.
    */
   virtual set<Move>::const_iterator begin(const TurnInfo* const pTurn) {
      makeSet(pTurn);
      return selectedMoves->begin();
   }
   virtual set<Move>::const_iterator end() const {
      return selectedMoves->end();
   }

   bool knownEmpty() const { return (isSet && selectedMoves->size() == 0); }

   virtual string getName() const { 
      string x = (excludeTurnIfEmpty ? "X" : "");
      return name + x; 
   }
   virtual string getDescription() const = 0;
   virtual operator string() const {  //works for many subclasses
      return getName() + ": " + getDescription();
   }
};

class FnSelector: public MoveSelector {
   MoveSelectorFn selectorFn;
 public:
   FnSelector(MoveSelectorFn gselfn, const string& name, bool exc)
      : MoveSelector(name, exc), selectorFn(gselfn) { }
   virtual ~FnSelector() { }  //parent destructor called automatically
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      return (*selectorFn)(pTurn, move);
   }
   virtual string getDescription() const {
      return "FnSelector";
   }
};

class NotSelector: public MoveSelector {
   MoveSelector* theSelector;
 public:
   NotSelector(MoveSelector* selector, const string& name, bool exc)
      : MoveSelector(name, exc), theSelector(selector) { }
   virtual ~NotSelector() { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      return !(theSelector->apply(pTurn, move));
   }
   virtual string getDescription() const {
      return "NotSelector [" + theSelector->getName() + "]";
   }
};


class AndSelector : public MoveSelector {
   list<MoveSelector*> conjuncts;
 public:
   AndSelector(const string& name, bool exc)
      : MoveSelector(name, exc), conjuncts(list<MoveSelector*>()) { }
   AndSelector(MoveSelector* lhs, MoveSelector* rhs, const string& name, bool exc)
      : MoveSelector(name, exc), conjuncts(list<MoveSelector*>())
   {
      conjuncts.push_back(lhs);
      conjuncts.push_back(rhs);
   }
   virtual ~AndSelector() { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      bool ans = true;
      for (list<MoveSelector*>::const_iterator it = conjuncts.begin();
           it != conjuncts.end(); it++) {
         if (!(*it)->apply(pTurn, move)) {
            ans = false;
            break;
         }
      }
      return ans;
   }
   void addConjunct(MoveSelector* tf) {
      conjuncts.push_back(tf);
   }

   virtual string getDescription() const {
      string out = "AndSelector [";
      for (list<MoveSelector*>::const_iterator it = conjuncts.begin();
           it != conjuncts.end(); it++) {
         out += (*it)->getName() + ",";
      }
      if (conjuncts.empty()) {
         out += "]";
      } else {
         out[out.size() - 1] = ']';
      }
      return out;
   }

   virtual operator string() const {
      string out = getName() + ": AndSelector [";
      for (list<MoveSelector*>::const_iterator it = conjuncts.begin();
           it != conjuncts.end(); it++) {
         out += string(**it) + ", ";    //string() makes this more verbose
      }
      if (conjuncts.empty()) {
         out += "]";
      } else {
         out[out.size() - 2] = ']';
      }
      return out;
   }
};

class OrSelector : public MoveSelector {
   list<MoveSelector*> disjuncts;
 public:
   OrSelector(const string& name, bool exc)
      : MoveSelector(name, exc), disjuncts(list<MoveSelector*>()) { }
   OrSelector(MoveSelector* lhs, MoveSelector* rhs, const string& name, bool exc)
      : MoveSelector(name, exc), disjuncts(list<MoveSelector*>())
   {
      disjuncts.push_back(lhs);
      disjuncts.push_back(rhs);
   }
   virtual ~OrSelector() { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      bool ans = false;
      for (list<MoveSelector*>::const_iterator it = disjuncts.begin();
           it != disjuncts.end(); it++) {
         if ((*it)->apply(pTurn, move)) {
            ans = true;
            break;
         }
      }
      return ans;
   }
   void addDisjunct(MoveSelector* tf) {
      disjuncts.push_back(tf);
   }

   virtual string getDescription() const {
      string out = "OrSelector [";
      for (list<MoveSelector*>::const_iterator it = disjuncts.begin();
           it != disjuncts.end(); it++) {
         out += (*it)->getName() + ",";
      }
      if (disjuncts.empty()) {
         out += "]";
      } else {
         out[out.size() - 1] = ']';
      }
      return out;
   }

   virtual operator string() const {
      string out = getName() + ": OrSelector [";
      for (list<MoveSelector*>::const_iterator it = disjuncts.begin();
           it != disjuncts.end(); it++) {
         out += (**it).getDescription() + ", " ;
      }
      if (disjuncts.empty()) {
         out += "]";
      } else {
         out[out.size() - 2] = ']';
      }
      return out;
   }

};


class MappedMoveSelector : public MoveSelector {
   map<string, set<Move>*>* fenMap;
 public:
   MappedMoveSelector(const string& name, bool exc)
    : MoveSelector(name, exc), fenMap(new map<string, set<Move>*>())
   { 
      declareSet();
   }
   virtual ~MappedMoveSelector() {
      map<string, set<Move>*>::iterator itr = fenMap->begin();
      while (itr != fenMap->end()) {
         delete(itr->second);
         itr++;
      }
      delete(fenMap);
   }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      map<string, set<Move>*>::iterator mitr = fenMap->find(pTurn->getFEN());
      if (mitr != fenMap->end()) {
         set<Move>::iterator sitr = mitr->second->find(move);
         return (sitr != mitr->second->end());
      } //else
      return false;
   }
   void addTurn(const TurnInfo* const pTurn, const vector<Move>& moves) {
      fenMap->operator[](pTurn->getFEN()) = new set<Move>();
      for (vector<Move>::const_iterator citr = moves.begin(); citr != moves.end(); citr++) {
         fenMap->at(pTurn->getFEN())->insert(*citr);
      }
   }
   size_t mapSize() const { return fenMap->size(); }
   virtual string getDescription() const {
      return "TurnMap";
   }
};
     
class OmniSelector : public MoveSelector {
 public:
   OmniSelector(): MoveSelector("Omni",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      return true;
   }
   virtual string getDescription() const {
      return "always true";
   }
};

class NullSelector : public MoveSelector {
 public:
   NullSelector(): MoveSelector("NullSelector",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      return false;
   }
   virtual string getDescription() const {
      return "always false";
   }
};

class PawnMoveSelector : public MoveSelector {
 public:
   PawnMoveSelector() : MoveSelector("PawnMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      char piece = move.getTAN()[0];
      bool wtm = pTurn->whiteToMove;
      return ((wtm && piece == 'P') || ((!wtm) && piece == 'p'));
   }
   virtual string getDescription() const {
      return "Pawn move";
   }
};

class KnightMoveSelector : public MoveSelector {
 public:
   KnightMoveSelector() : MoveSelector("KnightMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      char piece = move.getTAN()[0];
      bool wtm = pTurn->whiteToMove;
      return ((wtm && piece == 'N') || ((!wtm) && piece == 'n'));
   }
   virtual string getDescription() const {
      return "Knight move";
   }
};

class BishopMoveSelector : public MoveSelector {
 public:
   BishopMoveSelector() : MoveSelector("BishopMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      char piece = move.getTAN()[0];
      bool wtm = pTurn->whiteToMove;
      return ((wtm && piece == 'B') || ((!wtm) && piece == 'b'));
   }
   virtual string getDescription() const {
      return "Bishop move";
   }
};

class RookMoveSelector : public MoveSelector {
 public:
   RookMoveSelector() : MoveSelector("RookMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      char piece = move.getTAN()[0];
      bool wtm = pTurn->whiteToMove;
      return ((wtm && piece == 'R') || ((!wtm) && piece == 'r'));
   }
   virtual string getDescription() const {
      return "Rook move";
   }
};

class QueenMoveSelector : public MoveSelector {
 public:
   QueenMoveSelector() : MoveSelector("QueenMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      char piece = move.getTAN()[0];
      bool wtm = pTurn->whiteToMove;
      return ((wtm && piece == 'Q') || ((!wtm) && piece == 'q'));
   }
   virtual string getDescription() const {
      return "Queen move";
   }
};

class KingMoveSelector : public MoveSelector {
 public:
   KingMoveSelector() : MoveSelector("KingMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      char piece = move.getTAN()[0];
      bool wtm = pTurn->whiteToMove;
      return ((wtm && piece == 'K') || ((!wtm) && piece == 'k'));
   }
   virtual string getDescription() const {
      return "King move";
   }
};

class CastlingSelector : public MoveSelector {
 public:
   CastlingSelector() : MoveSelector("Castling",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      string tanMove = move.getTAN();
      return (tanMove.length() == 7 && tanMove.at(6) == 'c');
   }
   virtual string getDescription() const {
      return "Castling";
   }
};

class CaptureSelector : public MoveSelector {
 public:
   CaptureSelector() : MoveSelector("Capture",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      string tanMove = move.getTAN();
      return (tanMove.at(3) == 'x');
   }
   virtual string getDescription() const {
      return "Capture";
   }
};

class NonCaptureSelector : public MoveSelector {
 public:
   NonCaptureSelector() : MoveSelector("NonCapture",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      string tanMove = move.getTAN();
      return (tanMove.at(3) != 'x');
   }
   virtual string getDescription() const {
      return "Non-capture";
   }
};

class PromotionSelector : public MoveSelector {
 public:
   PromotionSelector() : MoveSelector("Promotion",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      string tanMove = move.getTAN();
      if (tanMove.length() < 7) { return false; }
      char pp = tanMove.at(6);
      bool wtm = pTurn->whiteToMove;
      return ((wtm && (pp == 'Q' || pp == 'N' || pp == 'R' || pp == 'B'))
            || ((!wtm) && (pp == 'q' || pp == 'n' || pp == 'r' || pp == 'b')));
   }
   virtual string getDescription() const {
      return "Promotion";
   }
};

class AdvancingMoveSelector : public MoveSelector {
 public:
   AdvancingMoveSelector() : MoveSelector("AdvancingMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      string tanMove = move.getTAN();
      bool wtm = pTurn->whiteToMove;
      return ((wtm && tanMove.at(2) < tanMove.at(5)) || (!wtm) && tanMove.at(2) > tanMove.at(5));
   }
   virtual string getDescription() const {
      return "Advancing move";
   }
};

class RetreatingMoveSelector : public MoveSelector {
 public:
   RetreatingMoveSelector() : MoveSelector("RetreatingMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      string tanMove = move.getTAN();
      bool wtm = pTurn->whiteToMove;
      return ((wtm && tanMove.at(2) > tanMove.at(5)) || (!wtm) && tanMove.at(2) < tanMove.at(5));
   }
   virtual string getDescription() const {
      return "Retreating move";
   }
};

class SidewaysMoveSelector : public MoveSelector {
 public:
   SidewaysMoveSelector() : MoveSelector("SidewaysMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      string tanMove = move.getTAN();
      bool wtm = pTurn->whiteToMove;
      return (tanMove.at(2) == tanMove.at(5));
   }
   virtual string getDescription() const {
      return "Sideways move";
   }
};

class CheckingMoveSelector : public MoveSelector {
 public:
   CheckingMoveSelector() : MoveSelector("CheckingMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      Position pos(pTurn->getFEN());
      pos.playMove(move);
      return pos.inCheck();
   }
   virtual string getDescription() const {
      return "Checking move";
   }
};

class EngineMoveSelector : public MoveSelector {
 public:
   EngineMoveSelector(): MoveSelector("EngineMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      return (move == pTurn->engineMove);
   }
   virtual string getDescription() const {
      return "Engine's first line";
   }
};

class PlayedMoveSelector : public MoveSelector {
 public:
   PlayedMoveSelector(): MoveSelector("PlayedMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      return (move == pTurn->movePlayed);
   }
   virtual string getDescription() const {
      return "The move played";
   }
};

class SamePieceAsPrevMoveSelector : public MoveSelector {
 public:
   SamePieceAsPrevMoveSelector(): MoveSelector("SamePieceAsPrevMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      TurnInfo* ppTurn = pTurn->prevTurn;
      if (ppTurn == NULL) { return false; }
      ppTurn = pTurn->prevTurn;
      if (ppTurn == NULL) { return false; }
      string tanMove = move.getTAN();
      string prevTAN = ppTurn->movePlayed.getTAN();
      return (prevTAN.at(4) == tanMove.at(1) && prevTAN.at(5) == tanMove.at(5));
   }
   virtual string getDescription() const {
      return "Same piece as player moved last";
   }
};

class EqualTopMoveSelector : public MoveSelector {
 public:
   EqualTopMoveSelector(): MoveSelector("EqualTopMove",false) { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      int cpeval = pTurn->depthEvalsCP->at(0).at(pTurn->turnHighestDepth-1);
      int index = 0;
      while (index < pTurn->numConsideredMoves
                && pTurn->depthEvalsCP->at(index).at(pTurn->turnHighestDepth-1) == cpeval) {
         if (pTurn->consideredMoves->at(index) == move) { return true; }
         index++;
      }
      return false;
   }
   virtual string getDescription() const {
      return "Same value as computer first move";
   }
};

class CompareSelector: public virtual MoveSelector {
   const double rhs;
   const COMPARE comparison;
 protected:
   CompareSelector(COMPARE gc, double r, bool nullExcludes, const string& gname)
         : MoveSelector(gname, nullExcludes), comparison(gc), rhs(r) {
      name = gname;
   }

 public:
   virtual ~CompareSelector() { }

   bool test(double lhs) const {
      bool ans;
      switch(comparison) {
       case LEQ:
         ans = lhs <= rhs;
         break;
       case EQ:
         ans = lhs == rhs;
         break;
       case GEQ:
         ans = lhs >= rhs;
         break;
      }
      return ans;
   }

   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const = 0;

   string relation() const {
      string rel = "";
      switch(comparison) {
       case LEQ:
         rel = "<=";
         break;
       case EQ:
         rel = "==";
         break;
       case GEQ:
         rel = ">=";
         break;
      }
      return rel;
   }

   virtual string getDescription() const {
      return relation() + " " + IRutil::ftoa(rhs);
   }
};

class MoveEvalSelector : public CompareSelector {
   double thresholdEval;   //in pawn not centipawn units, for show in print
   size_t atDepth;         //threshold passed as "geval" to parent
   bool playerView;
 public:
   MoveEvalSelector(const COMPARE comp, const double geval, const size_t gdepth,
                    bool ptm, bool nullExcludes, const string& name)
    : CompareSelector(comp, geval, nullExcludes, name)
    , thresholdEval(geval)
    , atDepth(gdepth)
    , playerView(ptm)
   { }
   virtual ~MoveEvalSelector() { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      size_t i = 0;
      int evalToTest;
      size_t useDepth;
      while (i < pTurn->numConsideredMoves) {
         if (pTurn->consideredMoves->at(i) == move) {
            if (atDepth == 0 || atDepth > pTurn->turnHighestDepth) {
               useDepth = pTurn->turnHighestDepth;
            } else if (atDepth < pTurn->turnLowestDepth) {
               useDepth = pTurn->turnLowestDepth;
            }
            int wtmEval = pTurn->getEvalCP(i,useDepth);
            if (wtmEval != IRutil::PRUNVAL && wtmEval != IRutil::NAVAL
                && wtmEval != IRutil::NRECVAL) {
               evalToTest = (((!playerView) || pTurn->whiteToMove) ? wtmEval : -wtmEval);
               return test(evalToTest/100.0);
            }
            return false;  //move does not have recorded value
         }
         i++;
      }
      return false;  //move not considered
   }

   virtual string getDescription() const {
      string who = (playerView ? "Player" : "White");
      string dstr = (atDepth == 0 ? "max" : IRutil::itoa(atDepth));
      return "Move Eval is " + relation() + " " + IRutil::ftoa(thresholdEval) 
            + " for " + who + " at depth " + dstr;
   }
};

class MoveRawDeltaSelector : public CompareSelector {
   double thresholdDelta;  //for show; tested value passed to parent.  In p.nn pawn units
   size_t atDepth;
 public: 
   MoveRawDeltaSelector(const COMPARE comp, const double gdelta, const size_t gdepth,
                     bool nullExcludes, const string& name)
    : CompareSelector(comp, gdelta, nullExcludes, name)
    , thresholdDelta(gdelta)
    , atDepth(gdepth)
   { }
   virtual ~MoveRawDeltaSelector() { }

   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      size_t i = 0;
      size_t useDepth;
      while (i < pTurn->numConsideredMoves) {
         if (pTurn->consideredMoves->at(i) == move) {
            if (atDepth == 0 || atDepth > pTurn->turnHighestDepth) {
               useDepth = pTurn->turnHighestDepth;
            } else if (atDepth < pTurn->turnLowestDepth) {
               useDepth = pTurn->turnLowestDepth;
            }
            int wtmEval = pTurn->getEvalCP(i,useDepth);
            int bestEval = pTurn->getBestEvalCPAtDepth(useDepth);
            return test((bestEval - wtmEval)/double(100));
         }
         i++;
      }
      return false;
   }

   virtual string getDescription() const {
      string dstr = (atDepth == 0 ? "max" : IRutil::itoa(atDepth));
      return "Move delta is " + relation() + " " + IRutil::ftoa(thresholdDelta)
            + " at depth " + dstr;
   }
};

class MoveRawSwingSelector : public CompareSelector {
   double thresholdSwing;  //can be negative
   size_t targetDepth;     //D in definition of swing, 0 for max
   bool normalize;
 public:
   MoveRawSwingSelector(const COMPARE comp, const double gdelta, const size_t gdepth,
                     bool norm, bool nullExcludes, const string& name)
    : CompareSelector(comp, gdelta, nullExcludes, name)
    , thresholdSwing(gdelta)
    , targetDepth(gdepth)
    , normalize(norm)
   { }
   virtual ~MoveRawSwingSelector() { }

   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      size_t i = 0;
      size_t useDepth = targetDepth;
      while (i < pTurn->numConsideredMoves) {
         if (pTurn->consideredMoves->at(i) == move) {
            if (targetDepth == 0 || targetDepth > pTurn->turnHighestDepth) {
               useDepth = pTurn->turnHighestDepth;
            } else if (targetDepth < pTurn->turnLowestDepth) {
               useDepth = pTurn->turnLowestDepth; //will return 0 for swing
            }
            double swingToTest = pTurn->getRawSwingCPPTM(i, useDepth, normalize);
            return test(swingToTest/double(100));
         }
         i++;
      }
      return false;
   }

   virtual string getDescription() const {
      string dstr = (targetDepth == 0 ? "max" : IRutil::itoa(targetDepth));
      string normstr = (normalize ? "normalized is " : "is ");
      return "Move swing " + normstr + relation() + " " + IRutil::ftoa(thresholdSwing)
            + " targeting depth " + dstr;
   }
};



#endif


 
//File-----------------------Filters.h---------------------------------------- 
 
#ifndef __IR_FILTERS_H__ 
#define __IR_FILTERS_H__ 
 
//-----------------------FILTERS------------------------------------------ 
 
typedef bool (*TurnFilterFn)(const TurnInfo* const); 
 
#ifndef __IR_MOVESELECTION_H__
#include "MoveSelector.h"
//enum COMPARE { LEQ, EQ, GEQ };  //NOT < = >, but with <= and >= 
#endif

class TurnFilter : public Catalogable {
 protected:        //C++: accessible to *immediate* subclasses only
   string name;
   TurnFilter(const string& gname) : name(gname) { }
   TurnFilter() : name("anon") { }
 public:
   virtual ~TurnFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const = 0;

   virtual string getName() const { return name; }
   virtual string getDescription() const = 0;
   virtual operator string() const {  //works for many subclasses
      return getName() + ": " + getDescription();
   }
};

inline bool allowAll(const TurnInfo* const pTurn) { return true; } 
 
class FnFilter : public TurnFilter { 
   TurnFilterFn filterFn; 
 public: 
   FnFilter(TurnFilterFn gfilter, const string& name) 
      : TurnFilter(name), filterFn(gfilter) { } 
   virtual ~FnFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return (*filterFn)(pTurn); 
   } 
   virtual string getDescription() const { 
      return "FnFilter"; 
   } 
}; 
 
class NotFilter : public TurnFilter { 
   TurnFilter* theFilter; 
 public: 
   NotFilter(TurnFilter* filter, const string& name) 
      : TurnFilter(name), theFilter(filter) { } 
   virtual ~NotFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return !(theFilter->apply(pTurn)); 
   } 
   virtual string getDescription() const { 
      return "NotFilter [" + theFilter->getName() + "]"; 
   } 
}; 
 
 
class AndFilter : public TurnFilter { 
   list<TurnFilter*> conjuncts; 
 public: 
   AndFilter(const string& name) 
      : TurnFilter(name), conjuncts(list<TurnFilter*>()) { } 
   AndFilter(TurnFilter* lhs, TurnFilter* rhs, const string& name) 
      : TurnFilter(name), conjuncts(list<TurnFilter*>()) 
   { 
      conjuncts.push_back(lhs); 
      conjuncts.push_back(rhs); 
   } 
   virtual ~AndFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      bool ans = true; 
      for (list<TurnFilter*>::const_iterator it = conjuncts.begin(); 
           it != conjuncts.end(); it++) { 
         if (!(*it)->apply(pTurn)) { 
            ans = false; 
            break; 
         } 
      } 
      return ans; 
   } 
   void addConjunct(TurnFilter* tf) { 
      conjuncts.push_back(tf); 
   } 
 
   virtual string getDescription() const { 
      string out = "AndFilter ["; 
      for (list<TurnFilter*>::const_iterator it = conjuncts.begin(); 
           it != conjuncts.end(); it++) { 
         out += (*it)->getName() + ","; 
      } 
      if (conjuncts.empty()) { 
         out += "]"; 
      } else { 
         out[out.size() - 1] = ']'; 
      } 
      return out; 
   } 
 
   virtual operator string() const { 
      string out = getName() + ": AndFilter ["; 
      for (list<TurnFilter*>::const_iterator it = conjuncts.begin(); 
           it != conjuncts.end(); it++) { 
         out += string(**it) + ", ";    //string() makes this more verbose 
      } 
      if (conjuncts.empty()) { 
         out += "]"; 
      } else { 
         out[out.size() - 2] = ']'; 
      } 
      return out; 
   } 
}; 
 
 
class OrFilter : public TurnFilter { 
   list<TurnFilter*> disjuncts; 
 public: 
   OrFilter(const string& name) 
      : TurnFilter(name), disjuncts(list<TurnFilter*>()) { } 
   OrFilter(TurnFilter* lhs, TurnFilter* rhs, const string& name) 
      : TurnFilter(name), disjuncts(list<TurnFilter*>()) 
   { 
      disjuncts.push_back(lhs); 
      disjuncts.push_back(rhs); 
   } 
   virtual ~OrFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      bool ans = false; 
      for (list<TurnFilter*>::const_iterator it = disjuncts.begin(); 
           it != disjuncts.end(); it++) { 
         if ((*it)->apply(pTurn)) { 
            ans = true; 
            break; 
         } 
      } 
      return ans; 
   } 
   void addDisjunct(TurnFilter* tf) { 
      disjuncts.push_back(tf); 
   } 
 
   virtual string getDescription() const { 
      string out = "OrFilter ["; 
      for (list<TurnFilter*>::const_iterator it = disjuncts.begin(); 
           it != disjuncts.end(); it++) { 
         out += (*it)->getName() + ","; 
      } 
      if (disjuncts.empty()) { 
         out += "]"; 
      } else { 
         out[out.size() - 1] = ']'; 
      } 
      return out; 
   } 
 
   virtual operator string() const { 
      string out = getName() + ": OrFilter ["; 
      for (list<TurnFilter*>::const_iterator it = disjuncts.begin(); 
           it != disjuncts.end(); it++) { 
         //out += string(**it) + ",";    //string() makes this more verbose 
         out += (**it).getDescription() + ", " ; 
      } 
      if (disjuncts.empty()) { 
         out += "]"; 
      } else { 
         out[out.size() - 2] = ']'; 
      } 
      return out; 
   } 
 
}; 
 
class WhiteToMoveFilter : public TurnFilter { 
 public: 
   WhiteToMoveFilter() : TurnFilter("WhiteToMove") { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return pTurn->whiteToMove; 
   } 
   virtual string getDescription() const { 
      return "WhiteToMoveFilter"; 
   } 
}; 
 
class BlackToMoveFilter : public TurnFilter { 
 public: 
   BlackToMoveFilter() : TurnFilter("BlackToMove") { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return !pTurn->whiteToMove; 
   } 
   virtual string getDescription() const { 
      return "BlackToMoveFilter"; 
   } 
}; 

class InCheckFilter : public TurnFilter {
 public:
   InCheckFilter() : TurnFilter("InCheck") { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      Position pos(pTurn->getFEN());
      return pos.inCheck();
   }
   virtual string getDescription() const {
      return "InCheckFilter";
   }
};

 
 
class PlayerFilter : public TurnFilter { 
 protected: 
   const string player; 
 public: 
   PlayerFilter(const string& gplayer, const string& name) 
      : TurnFilter(name), player(gplayer) { } 
   virtual ~PlayerFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
	   return IRutil::delimitedMatch(player,pTurn->pGameInfo->whitePlayer) 
                 || IRutil::delimitedMatch(player,pTurn->pGameInfo->blackPlayer); 
   } 
   virtual string getDescription() const { 
      return "PlayerFilter " + player; 
   } 
}; 
 
class PlayerOrFilter : public TurnFilter { 
 protected: 
   list<string> players; 
 public: 
   PlayerOrFilter(const string& player1, const string& name) 
      : TurnFilter(name), players(list<string>()) 
   { 
      players.push_back(player1); 
   } 
   PlayerOrFilter(const string& name) : TurnFilter(name), players(list<string>()) { } 
   virtual ~PlayerOrFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      bool ans = false; 
      for (list<string>::const_iterator it = players.begin(); 
           it != players.end(); it++) { 
         if (IRutil::delimitedMatch(*it, pTurn->pGameInfo->whitePlayer) 
             || IRutil::delimitedMatch(*it, pTurn->pGameInfo->blackPlayer)) { 
            ans = true; 
            break; 
         } 
      } 
      return ans; 
   } 
   void addPlayer(const string& newPlayer) { 
      players.push_back(newPlayer); 
   } 
   virtual string getDescription() const { 
      string out = "PlayerOrFilter ["; 
      for (list<string>::const_iterator it = players.begin(); 
           it != players.end(); it++) { out += (*it) + ","; } 
      out[out.size() - 1] = ']'; 
      return out; 
   } 
 
}; 
 
 
 
class PlayerOrToMoveFilter : public PlayerOrFilter { 
 public: 
   PlayerOrToMoveFilter(const string& player1, const string& name) 
      : PlayerOrFilter(player1,name) { } 
   PlayerOrToMoveFilter(const string& name) 
      : PlayerOrFilter(name) { } 
   virtual ~PlayerOrToMoveFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      bool ans = false; 
      for (list<string>::const_iterator it = players.begin(); 
           it != players.end(); it++) { 
         if ((IRutil::delimitedMatch(*it, pTurn->pGameInfo->whitePlayer)  
                 && pTurn->whiteToMove) 
         || (IRutil::delimitedMatch(*it, pTurn->pGameInfo->blackPlayer)  
                 && !pTurn->whiteToMove)) { 
            ans = true; 
            break; 
         } 
      } 
      return ans; 
   } 
   virtual string getDescription() const { 
      string out = "PlayerOrToMoveFilter ["; 
      for (list<string>::const_iterator it = players.begin(); 
           it != players.end(); it++) { out += (*it) + ","; } 
      out[out.size() - 1] = ']'; 
      return out; 
   } 
}; 
 
class PlayerToMoveFilter : public PlayerFilter { 
 public: 
   PlayerToMoveFilter(const string& player, const string& name) 
      : PlayerFilter(player,name) { } 
   virtual ~PlayerToMoveFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      bool ans = (pTurn->whiteToMove  
                        && IRutil::delimitedMatch(player,pTurn->pGameInfo->whitePlayer)) 
                  || ((!pTurn->whiteToMove)  
                        && IRutil::delimitedMatch(player,pTurn->pGameInfo->blackPlayer)); 
      return ans; 
   } 
   virtual string getDescription() const { 
      return PlayerFilter::getDescription() + ", to move"; 
   } 
}; 
 
class OpponentToMoveFilter : public PlayerFilter { 
 public: 
   OpponentToMoveFilter(const string& player, const string& name) 
      : PlayerFilter(player,name) { } 
   virtual ~OpponentToMoveFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      bool ans = (pTurn->whiteToMove  
                        && IRutil::delimitedMatch(player,pTurn->pGameInfo->blackPlayer)) 
                  || ((!pTurn->whiteToMove)  
                        && IRutil::delimitedMatch(player,pTurn->pGameInfo->whitePlayer)); 
      return ans; 
   } 
   virtual string getDescription() const { 
      return PlayerFilter::getDescription() + ", opponents' moves only"; 
   } 
}; 
 
class OpponentOrToMoveFilter : public PlayerOrFilter { 
 public: 
   OpponentOrToMoveFilter(const string& player1, const string& name) 
      : PlayerOrFilter(player1,name) { } 
   OpponentOrToMoveFilter(const string& name) 
      : PlayerOrFilter(name) { } 
   virtual ~OpponentOrToMoveFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      bool ans = false; 
      for (list<string>::const_iterator it = players.begin(); 
           it != players.end(); it++) { 
         if ((IRutil::delimitedMatch(*it, pTurn->pGameInfo->whitePlayer)  
                    && !pTurn->whiteToMove) 
              || (IRutil::delimitedMatch(*it, pTurn->pGameInfo->blackPlayer)  
                    && pTurn->whiteToMove)) { 
            ans = true; 
            break; 
         } 
      } 
      return ans; 
   } 
   virtual string getDescription() const { 
      string out = "PlayerOpponentOrToMoveFilter ["; 
      for (list<string>::const_iterator it = players.begin(); 
           it != players.end(); it++) { out += (*it) + ","; } 
      out[out.size() - 1] = ']'; 
      return out; 
   } 
}; 
 
 
 
class PlayerWhiteFilter : public PlayerFilter { 
 public: 
   PlayerWhiteFilter(const string& player, const string& name) 
      : PlayerFilter(player,name) { } 
   virtual ~PlayerWhiteFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return IRutil::delimitedMatch(player,pTurn->pGameInfo->whitePlayer); 
   } 
   virtual string getDescription() const { 
      return PlayerFilter::getDescription() + ", as White only"; 
   } 
}; 
 
class PlayerBlackFilter : public PlayerFilter { 
 public: 
   PlayerBlackFilter(const string& player, const string& name) 
      : PlayerFilter(player,name) { } 
   virtual ~PlayerBlackFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return IRutil::delimitedMatch(player,pTurn->pGameInfo->blackPlayer); 
   } 
   virtual string getDescription() const { 
      return PlayerFilter::getDescription() + ", as Black only"; 
   } 
}; 


class DrawnGameFilter : public TurnFilter {
 public:
   DrawnGameFilter() : TurnFilter("DrawnGame") { }
   virtual ~DrawnGameFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      return IRutil::delimitedMatch("1/2", pTurn->pGameInfo->result);
   }
   virtual string getDescription() const {
      return "DrawnGameFilter";
   }
};


class WhiteWinFilter : public TurnFilter {
 public:
   WhiteWinFilter() : TurnFilter("WhiteWin") { }
   virtual ~WhiteWinFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      return IRutil::delimitedMatch("1-0", pTurn->pGameInfo->result);
   }
   virtual string getDescription() const {
      return "WhiteWinFilter";
   }
};


class BlackWinFilter : public TurnFilter {
 public:
   BlackWinFilter() : TurnFilter("BlackWin") { }
   virtual ~BlackWinFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      return IRutil::delimitedMatch("0-1", pTurn->pGameInfo->result);
   }
   virtual string getDescription() const {
      return "BlackWinFilter";
   }
};


class PlayerWinFilter : public TurnFilter {
 public:
   PlayerWinFilter() : TurnFilter("PlayerWin") { }
   virtual ~PlayerWinFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      return (pTurn->whiteToMove && IRutil::delimitedMatch("1-0", pTurn->pGameInfo->result))
          || ((!(pTurn->whiteToMove)) && IRutil::delimitedMatch("0-1", pTurn->pGameInfo->result));
   }
   virtual string getDescription() const {
      return "PlayerWinFilter";
   }
};


class PlayerLossFilter : public TurnFilter {
 public:
   PlayerLossFilter() : TurnFilter("PlayerLoss") { }
   virtual ~PlayerLossFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      return (pTurn->whiteToMove && IRutil::delimitedMatch("0-1", pTurn->pGameInfo->result))
          || ((!(pTurn->whiteToMove)) && IRutil::delimitedMatch("1-0", pTurn->pGameInfo->result));
   }
   virtual string getDescription() const {
      return "PlayerLossFilter";
   }
};



 
/** "Q&D" versions of event and date filters use simple delimited substring 
    match, rather than match events to a table or parse into a Date class. 
    Thus one needs to reference Arena's event names from the data files. 
 */ 
class EventFilter : public TurnFilter { 
   const string event; 
 public: 
   EventFilter(const string& ev, const string& name) 
      : TurnFilter(name), event(ev) { } 
   virtual ~EventFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
	   return IRutil::delimitedMatch(event,pTurn->pGameInfo->eventName); 
   } 
   virtual string getDescription() const { 
      return "EventFilter \"" + event + "\""; 
   } 
}; 


/** Intended to match et = "tourn" or "swiss" or "team" or "rapid" or "blitz" 
 *  or "schev" or "ko" or "simul" etc.  Use AndFilter for multiple matches to
 *  things like "swiss(rapid)" and "tourn(team)" etc.
 */
class EventTypeFilter : public TurnFilter {
   const string eventType;
 public:
   EventTypeFilter(const string& et, const string& name)
      : TurnFilter(name), eventType(et) { }
   virtual ~EventTypeFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
           return IRutil::delimitedMatch(eventType,pTurn->pGameInfo->eventType);
   }
   virtual string getDescription() const {
      return "EventTypeFilter \"" + eventType + "\"";
   }
};

/** Many team-event games are marked only swiss() or etc. in ChessBase Big discs etc.
    Hence hunt for two other common telltales of a team event.
 */
class TeamEventFilter : public TurnFilter {
 public:
   TeamEventFilter() : TurnFilter("TeamEvent") { }
   virtual ~TeamEventFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      bool try1 = IRutil::delimitedMatch("team",pTurn->pGameInfo->eventType);
      bool try2 = IRutil::delimitedMatch("chT",pTurn->pGameInfo->eventName);
      bool try3 = IRutil::delimitedMatch("ch-T",pTurn->pGameInfo->eventName);
      bool try4 = IRutil::delimitedMatch("Tch",pTurn->pGameInfo->eventName);
      bool try5 = IRutil::delimitedMatch("T-ch",pTurn->pGameInfo->eventName);
      bool try6 = IRutil::isFilled(pTurn->pGameInfo->whiteTeam);
      return (try1 || try2 || try3 || try4 || try5 || try6);
   }
   virtual string getDescription() const {
      return "TeamEventFilter team/chT/ch-T/T-ch/Tch/WhiteTeam";
   }
};


class EngineFilter : public TurnFilter {
   const string engineNameMatch;
   const string version;  //match as string not number, assume comes after name
 public:
   EngineFilter(const string& enm, const string& ver, const string& name)
      : TurnFilter(name), engineNameMatch(enm), version(ver) { }
   virtual ~EngineFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      string eid = pTurn->engineID;
      string engID = pTurn->pGameInfo->engineID;
      size_t i = eid.find(engineNameMatch); //not delimited to allow "omod" e.g.
      size_t j = engID.find(engineNameMatch);
      if (i == string::npos && j == string::npos) { return false; }
      size_t len = engineNameMatch.size();
      string eidRest = eid.substr(i + len);
      string engIDRest = engID.substr(j + len);
      return (IRutil::delimitedMatch(version,eidRest)  //allows "9.4" to match "9.4.2"
               || IRutil::delimitedMatch(version,engIDRest));
   }
   virtual string getDescription() const {
      return "EngineFilter \"" + engineNameMatch + "\", \"" + version + "\"";
   }
};


 
 
/** General comparison class, maybe should have separate int analogue 
 */ 
class CompareFilter : public virtual TurnFilter { 
   const double rhs; 
   const COMPARE comparison; 
 protected: 
   CompareFilter(COMPARE gc, double r, const string& gname) 
         : TurnFilter(gname), comparison(gc), rhs(r) { 
      name = gname; 
   } 
 
 public: 
   virtual ~CompareFilter() { } 
 
   bool test(double lhs) const { 
      bool ans; 
      switch(comparison) { 
       case LEQ: 
         ans = lhs <= rhs; 
         break; 
       case EQ: 
         ans = lhs == rhs; 
         break; 
       case GEQ: 
         ans = lhs >= rhs; 
         break; 
      } 
      return ans; 
   } 
 
   virtual bool apply(const TurnInfo* const pTurn) const = 0; 
 
   string relation() const { 
      string rel = ""; 
      switch(comparison) { 
       case LEQ: 
         rel = "<="; 
         break; 
       case EQ: 
         rel = "=="; 
         break; 
       case GEQ: 
         rel = ">="; 
         break; 
      } 
      return rel; 
   } 
 
   virtual string getDescription() const { 
      return relation() + " " + IRutil::ftoa(rhs); 
   } 
}; 
 

class DateFilter : public CompareFilter {  //stores mangled date, not date 
   IRutil::SimpleDate date; //not used to compare, instead int passed to parent 
 public: 
   DateFilter(const COMPARE comp, const IRutil::SimpleDate gdate, const string& name) 
      : CompareFilter(comp, gdate.mangledDate(), name), date(gdate) 
   { } 
   virtual ~DateFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return test(pTurn->pGameInfo->date.mangledDate()); 
   } 
   virtual string getDescription() const { 
      return "Date is " + relation() + " " + string(date); 
   } 
}; 

class EventDateFilter : public CompareFilter {  //stores mangled date, not date
   IRutil::SimpleDate date; //not used to compare, instead int passed to parent
 public:
   EventDateFilter(const COMPARE comp, const IRutil::SimpleDate gdate, const string& name)
      : CompareFilter(comp, gdate.mangledDate(), name), date(gdate)
   { }
   virtual ~EventDateFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      return test(pTurn->pGameInfo->eventDate.mangledDate());
   }
   virtual string getDescription() const {
      return "Event date is " + relation() + " " + string(date);
   }
};

 
class YearFilter : public CompareFilter {  //stores mangled date, not date 
   int year; //not used to compare, instead int passed to parent 
 public: 
   YearFilter(const COMPARE comp, const int gyear, const string& name) 
      : CompareFilter(comp, gyear, name), year(gyear) 
   { } 
   virtual ~YearFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return test(pTurn->pGameInfo->date.getYear()); 
   } 
   virtual string getDescription() const { 
      return "Year is " + relation() + " " + IRutil::itoa(year); 
   } 
}; 
 

class WhiteEloFilter : public CompareFilter {  
   int elo; //not used to compare, instead int passed to parent
 public:
   WhiteEloFilter(const COMPARE comp, const int gelo, const string& name)
      : CompareFilter(comp, gelo, name), elo(gelo)
   { }
   virtual ~WhiteEloFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      int whiteElo = pTurn->pGameInfo->whiteElo;
      return whiteElo > 0 && test(whiteElo);
   }
   virtual string getDescription() const {
      return "White Elo is " + relation() + " " + IRutil::itoa(elo);
   }
};


class BlackEloFilter : public CompareFilter {
   int elo; //not used to compare, instead int passed to parent
 public:
   BlackEloFilter(const COMPARE comp, const int gelo, const string& name)
      : CompareFilter(comp, gelo, name), elo(gelo)
   { }
   virtual ~BlackEloFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      int blackElo = pTurn->pGameInfo->blackElo;
      return blackElo > 0 && test(blackElo);
   }
   virtual string getDescription() const {
      return "Black Elo is " + relation() + " " + IRutil::itoa(elo);
   }
};


class PlayerEloFilter : public CompareFilter {
   int elo; //not used to compare, instead int passed to parent
 public:
   PlayerEloFilter(const COMPARE comp, const int gelo, const string& name)
      : CompareFilter(comp, gelo, name), elo(gelo)
   { }
   virtual ~PlayerEloFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      int playerElo = pTurn->whiteToMove ? pTurn->pGameInfo->whiteElo 
                                         : pTurn->pGameInfo->blackElo;
      return (playerElo > 0 && test(playerElo));
   }
   virtual string getDescription() const {
      return "Elo of player to move is " + relation() + " " + IRutil::itoa(elo);
   }
};


class EloDiffFilter : public CompareFilter {
   int elodiff;
 public:
   EloDiffFilter(const COMPARE comp, const int gdiff, const string& name)
      : CompareFilter(comp, gdiff, name), elodiff(gdiff)
   { }
   virtual ~EloDiffFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      int playerElo = pTurn->whiteToMove ? pTurn->pGameInfo->whiteElo
                                         : pTurn->pGameInfo->blackElo;
      int oppElo = pTurn->whiteToMove ? pTurn->pGameInfo->blackElo
                                      : pTurn->pGameInfo->whiteElo;
      return (playerElo > 0 && oppElo > 0 && test(playerElo - oppElo));
   }
   virtual string getDescription() const {
      return "Elo diff is " + relation() + " " + IRutil::itoa(elodiff);
   }
};



class EloDiffWithinFilter : public CompareFilter {
   int elodiffbound;
 public:
   EloDiffWithinFilter(const COMPARE comp, const int gbound, const string& name)
      : CompareFilter(comp, gbound, name), elodiffbound(gbound)
   { }
   virtual ~EloDiffWithinFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      int playerElo = pTurn->whiteToMove ? pTurn->pGameInfo->whiteElo
                                         : pTurn->pGameInfo->blackElo;
      int oppElo = pTurn->whiteToMove ? pTurn->pGameInfo->blackElo
                                      : pTurn->pGameInfo->whiteElo;
      return (playerElo > 0 && oppElo > 0 && test(abs(playerElo - oppElo)));
   }
   virtual string getDescription() const {
      return "|Elo diff| is " + relation() + " " + IRutil::itoa(elodiffbound);
   }
};



class EvalWhiteFilter : public CompareFilter { 
 public: 
   EvalWhiteFilter(const COMPARE comp, const double threshold, const string& name) 
         : CompareFilter(comp, threshold, name) { } 
   virtual ~EvalWhiteFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
	   return test(pTurn->currEvalCP/double(100)); 
   } 
   virtual string getDescription() const { 
      return "White's eval " + CompareFilter::getDescription(); 
   } 
}; 
 
class PrevEvalWhiteFilter : public CompareFilter { 
 public: 
   PrevEvalWhiteFilter(const COMPARE comp, const double threshold, const string& name) 
      : CompareFilter(comp, threshold, name) { } 
   virtual ~PrevEvalWhiteFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return (pTurn->prevEvalCP != IRutil::NAVAL && test(pTurn->prevEvalCP/double(100))); 
   } 
   virtual string getDescription() const { 
      return "Prev White eval " + CompareFilter::getDescription(); 
   } 
}; 
 
 
class NextEvalWhiteFilter : public CompareFilter {
 public:
   NextEvalWhiteFilter(const COMPARE comp, const double threshold, const string& name)
      : CompareFilter(comp, threshold, name) { }
   virtual ~NextEvalWhiteFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      return (pTurn->nextEvalCP != IRutil::NAVAL && test(pTurn->nextEvalCP/double(100)));
   }
   virtual string getDescription() const {
      return "Next White eval " + CompareFilter::getDescription();
   }
};

class EvalWithinFilter : public CompareFilter { 
   size_t atDepth;
   map<string,double> normFactors;
 public: 
   EvalWithinFilter(const double threshold, const string& name, const size_t d = 0,
                    map<string,double> nf = map<string,double>()) 
         : CompareFilter(LEQ, threshold, name), atDepth(d), normFactors(nf) { } 
   virtual ~EvalWithinFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      int evalToTest = (atDepth == 0 ? pTurn->currEvalCP : pTurn->getBestEvalCPAtDepth(atDepth));
      string eid = pTurn->engineID;
      double factor = 1.0;
      map<string,double>::const_iterator itr = normFactors.begin();
      map<string,double>::const_iterator itre = normFactors.end();
      while (itr != itre) {
         string str = (*itr).first;
         if (eid.find(str) != string::npos) { factor = (*itr).second; }
         itr++;
      }
      return test(fabs(evalToTest*factor/100.0)); 
   } 
   virtual string getDescription() const { 
      string ds = (atDepth == 0 ? "" : string("at depth ") + IRutil::ftoa(atDepth) + string(" "));
      return "Turn |eval| " + ds + CompareFilter::getDescription(); 
   } 
}; 
 
 
class PrevEvalWithinFilter : public CompareFilter {   //count NAVAL as true
   size_t atDepth;
   map<string,double> normFactors;
 public: 
   PrevEvalWithinFilter(const double threshold, const string& name, const size_t d = 0,
                        map<string,double> nf = map<string,double>())
      : CompareFilter(LEQ, threshold, name), atDepth(d), normFactors(nf) { } 
   virtual ~PrevEvalWithinFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      TurnInfo* prevTurn = pTurn->prevTurn;
      if (prevTurn == NULL) { return true; }  //else
      double evalToTest = (atDepth == 0 ? prevTurn->currEvalCP : prevTurn->getBestEvalCPAtDepth(atDepth));
      string eid = pTurn->engineID;
      double factor = 1.0;
      map<string,double>::const_iterator itr = normFactors.begin();
      map<string,double>::const_iterator itre = normFactors.end();
      while (itr != itre) {
         string str = (*itr).first;
         if (eid.find(str) != string::npos) { factor = (*itr).second; }
         itr++;
      }
      return test(fabs(evalToTest*factor/100.0));
   } 
   virtual string getDescription() const { 
      string ds = (atDepth == 0 ? "" : string("at depth ") + IRutil::ftoa(atDepth) + string(" "));
      return "Prev turn |eval| " + ds + CompareFilter::getDescription(); 
   } 
}; 


class NextEvalWithinFilter : public CompareFilter {  //count end of game like current eval
   size_t atDepth;
   map<string,double> normFactors;
 public:
   NextEvalWithinFilter(const double threshold, const string& name, const size_t d = 0,
                        map<string,double> nf = map<string,double>())
      : CompareFilter(LEQ, threshold, name), atDepth(d), normFactors(nf) { }

   virtual ~NextEvalWithinFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      const TurnInfo* nextTurn = pTurn->prevTurn;
      if (nextTurn == NULL) { nextTurn = pTurn; }  //else
      double evalToTest = (atDepth == 0 ? nextTurn->currEvalCP : nextTurn->getBestEvalCPAtDepth(atDepth));
      string eid = pTurn->engineID;
      double factor = 1.0;
      map<string,double>::const_iterator itr = normFactors.begin();
      map<string,double>::const_iterator itre = normFactors.end();
      while (itr != itre) {
         string str = (*itr).first;
         if (eid.find(str) != string::npos) { factor = (*itr).second; }
         itr++;
      }
      return test(fabs(evalToTest*factor/100.0));
   }
   virtual string getDescription() const {
      string ds = (atDepth == 0 ? "" : string("at depth ") + IRutil::ftoa(atDepth) + string(" "));
      return "Next turn |eval| " + ds + CompareFilter::getDescription();
   }
};

 
 
class TurnNoFilter : public CompareFilter { 
 public: 
   TurnNoFilter(const COMPARE comp, const int fromTurn, const string& name) 
      : CompareFilter(comp, fromTurn, name) { } 
   virtual ~TurnNoFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return test(pTurn->turnNumber); 
   } 
   virtual string getDescription() const { 
      return "TurnNumber " + CompareFilter::getDescription(); 
   } 
}; 
 
 
class NumLegalMovesFilter : public CompareFilter { 
 public: 
   NumLegalMovesFilter(const COMPARE comp, const int numLegalMoves, const string& name) 
      : CompareFilter(comp, numLegalMoves, name) { } 
   virtual ~NumLegalMovesFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
	   return test(pTurn->numLegalMoves); 
   } 
   virtual string getDescription() const { 
      return "# legal moves " + CompareFilter::getDescription(); 
   } 
}; 


class PlycountFilter : public CompareFilter {
 public:
   PlycountFilter(const COMPARE comp, const int plyCount, const string& name)
      : CompareFilter(comp, plyCount, name) { }
   virtual ~PlycountFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
           return pTurn->pGameInfo->plyCount > 0 && test(pTurn->pGameInfo->plyCount);
   }
   virtual string getDescription() const {
      return "# game ply " + CompareFilter::getDescription();
   }
};

 
 
//ASSUMES TurnInfo moves are ordered by eval at highest depth 
class DeltaIFilter : public CompareFilter { 
   const int index; 
 public: 
   DeltaIFilter(const COMPARE comp, const double threshold, const int gindex, 
                   string name) 
      : CompareFilter(comp, threshold, name), index(gindex) { } 
   virtual ~DeltaIFilter() { } 
   virtual bool apply(const TurnInfo*  const pTurn) const { 
      if (index >= pTurn->depthEvalsCP->size()) {
		   //TAMAL:TODO: verify
		   return false;
      }
      //const double indexedEval =  //highDepth always given valid data
            //pTurn->depthEvalsCP->at(index).at(pTurn->turnHighestDepth-1)/double(100); 
      //return test(IRutil::round(pTurn->currEvalCP/double(100) - indexedEval, 2)); 
      const int indexedEvalCP = pTurn->depthEvalsCP->at(index).at(pTurn->turnHighestDepth-1);
      return test(fabs(pTurn->currEvalCP - indexedEvalCP)/100.0);
   } 
   virtual string getDescription() const { 
      return "Delta_" + IRutil::itoa(index) + " "  
                      + CompareFilter::getDescription(); 
   } 
}; 
 
class DeltaDiffFilter : public CompareFilter { 
   const int index1; 
   const int index2; 
 public: 
   DeltaDiffFilter(const COMPARE comp, const double threshold, 
               const int gindex1, const int gindex2, const string& name)  
      : CompareFilter(comp, threshold, name), index1(gindex1), index2(gindex2) 
     { } 
   virtual ~DeltaDiffFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      size_t sz = pTurn->depthEvalsCP->size();
      if (index1 >= sz || index2 >= sz) {
         return false;
      } else {
         int cpeval1 = pTurn->depthEvalsCP->at(index1).at(pTurn->turnHighestDepth);
         int cpeval2 = pTurn->depthEvalsCP->at(index2).at(pTurn->turnHighestDepth);
         return test(fabs(cpeval1 - cpeval2)/100.0);
      }
   } 
   virtual string getDescription() const { 
      return "DeltaDiff(" + IRutil::itoa(index1) + "," + IRutil::itoa(index2) 
                      + ") " + CompareFilter::getDescription(); 
   } 
}; 
 
 
/** Counts a turn with only one legal move as excluded. 
 */ 
//TAMAL: TODO DeltaIFilter(comp, threshold, 1, name) { }  //index from 0 .. what if no index 1 ??
class SecondDeltaFilter : public DeltaIFilter { 
 public: 
   SecondDeltaFilter(const COMPARE comp, const double threshold, const string& name) 
      : DeltaIFilter(comp, threshold, 1, name) { }  //index from 0 
   virtual ~SecondDeltaFilter() { } 
   //inherit apply and string getDescription() const 
}; 
 
class DeltaNFilter : public DeltaIFilter { 
 public: 
   DeltaNFilter(const COMPARE comp, const double threshold, const string& name) 
      : DeltaIFilter(comp, threshold, IRutil::MAXNUMLEGALMOVES - 1, name) { } 
   virtual ~DeltaNFilter() { } 
   //inherit apply and string getDescription() const 
}; 

class RepCountFilter : public CompareFilter {
   int count; //not used to compare, instead int passed to parent
   bool useReplines;  //Intended to help filter moves OUT
 public:
   RepCountFilter(const COMPARE comp, const int gcount, bool ur = false, const string& name = "RCF")
      : CompareFilter(comp, gcount, name), count(gcount), useReplines(ur)
   { }
   virtual ~RepCountFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      int rc = pTurn->repeatCount;
      bool extraFilter = true; //need to remain true to keep move IN
      if (useReplines) {
         vector<Move>::const_iterator bi = pTurn->repMoves->begin();
         vector<Move>::const_iterator ei = pTurn->repMoves->end();
         extraFilter &= (find(bi,ei,pTurn->movePlayed) == ei);
         extraFilter &= (pTurn->repLine2.find(string(pTurn->movePlayed)) == string::npos);
         //!!! must improve parsing of repLine2
      }
      return (extraFilter && test(rc));
   }
   virtual string getDescription() const {
      return "RepCount " + relation() + " " + IRutil::itoa(count) + (useReplines ? ", using replines" : "");
   }
};

class PlayedMoveIndexFilter : public CompareFilter {
 public:
   PlayedMoveIndexFilter(const COMPARE comp, const int index, const string& name)
      : CompareFilter(comp, index, name) { }
   virtual ~PlayedMoveIndexFilter() { }
   virtual bool apply(const TurnInfo* const pTurn) const {
      return test(pTurn->playedMoveIndex);
   }
   virtual string getDescription() const {
      return "PlayedMoveIndex " + CompareFilter::getDescription();
   }
};

class SelectorFilter : public virtual TurnFilter {
 protected:
   const MoveSelector* const theSelector;
   SelectorFilter(const string& gname, const MoveSelector* const ms)
         : TurnFilter(gname), theSelector(ms) {
      name = gname;  //??? From CompareFilter
   }

 public:
   virtual ~SelectorFilter() { }

   virtual bool apply(const TurnInfo* const pTurn) const = 0;

   virtual string getDescription() const {
      return "Filter from selector " + theSelector->getName();
   }
};

class PlayedMoveSelectedFilter : public SelectorFilter {
 public: 
   explicit PlayedMoveSelectedFilter(const MoveSelector* const ms)
         : SelectorFilter("PlayedMoveSelected by "+ms->getName(), ms) { }
   virtual ~PlayedMoveSelectedFilter() { }

   virtual bool apply(const TurnInfo* const pTurn) const {
      return theSelector->apply(pTurn, pTurn->movePlayed);
   }

   virtual string getDescription() const {
      return "Played move is a " + theSelector->getDescription();
   }
};

class EngineMoveSelectedFilter : public SelectorFilter {
 public:
   explicit EngineMoveSelectedFilter(const MoveSelector* const ms)
         : SelectorFilter("EngineMoveSelected by "+ms->getName(), ms) { }
   virtual ~EngineMoveSelectedFilter() { }

   virtual bool apply(const TurnInfo* const pTurn) const {
      return theSelector->apply(pTurn, pTurn->engineMove);
   }

   virtual string getDescription() const {
      return "Engine move is a " + theSelector->getDescription();
   }
};

class EqualTopMoveSelectedFilter : public SelectorFilter {
 public:
   explicit EqualTopMoveSelectedFilter(const MoveSelector* const ms)
         : SelectorFilter("EqualTopMoveSelected by"+ms->getName(), ms) { }
   virtual ~EqualTopMoveSelectedFilter() { }

   virtual bool apply(const TurnInfo* const pTurn) const {
      int i = 0;
      while (i < pTurn->consideredMoves->size()
               && pTurn->depthEvalsCP->at(i) == pTurn->depthEvalsCP->at(0)) {
         if (theSelector->apply(pTurn, pTurn->consideredMoves->at(i))) {
            return true;
         }
         i++;
      }
      return false;
   }

   virtual string getDescription() const {
      return "Some optimal move is a " + theSelector->getDescription();
   }
};

class SelectionNonemptyFilter : public SelectorFilter {
 public:
   explicit SelectionNonemptyFilter(const MoveSelector* const ms) 
         : SelectorFilter("Has"+ms->getName(), ms) { }
   virtual ~SelectionNonemptyFilter() { }

   virtual bool apply(const TurnInfo* const pTurn) const {
      int i = 0;
      while (i < pTurn->numLegalMoves) {
         if (theSelector->apply(pTurn, pTurn->legalMoves->at(i))) {
            return true;
         }
         i++;
      }
      return false;
   }

   virtual string getDescription() const {
      return "Some legal move is a " + theSelector->getDescription();
   }
};




//firstLine matches if engine move is the same as played move. 
class FirstLineMatchFilter : public TurnFilter { 
 public: 
   FirstLineMatchFilter() : TurnFilter("FirstLineMatch") { } 
   virtual ~FirstLineMatchFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return pTurn->firstLineMatch; 
   } 
   virtual string getDescription() const { 
      return "FirstLineMatchFilter"; 
   } 
}; 
 
// top patch if currEval is equal to the value of the played move.. played move is tie to the top... 
// Make sure.. currently currEval should be the eval of the best move not the played move. 
class EqualTopMoveFilter : public TurnFilter { 
 public: 
   EqualTopMoveFilter() : TurnFilter("EqualTopMove") { } 
   virtual ~EqualTopMoveFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      return pTurn->eqTopMatch; 
   } 
   virtual string getDescription() const { 
      return "Move equivalent to top move played"; 
   } 
}; 
 

/** Use top-depth values (before scaling) to meter the error made by player.
    Comparison is with eval(best move) - eval(played move)
 */
class FalloffFilter : public CompareFilter { 
 public: 
   FalloffFilter(const COMPARE comp, const double delta, const string& name)  
      : CompareFilter(comp, delta, name) { } 
   virtual ~FalloffFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
	   //TAMAL: TODO: What to do with deltaFallOff // Commemnting right now 
     // return test(IRutil::round(pTurn->deltaFalloff,2)); 
	   return test(0); 
   } 
   virtual string getDescription() const { 
      return "FalloffFilter " + CompareFilter::getDescription(); 
   } 
}; 
 
 
 
#endif    //end of #ifndef __IR_FILTERS_H__ 
 
 

 
//File------------------PerfData.h------------------------------------------- 
 
#ifndef __IR_PERFDATA_H__ 
#define __IR_PERFDATA_H__ 

#ifndef __IR_INCLUDES_H__
#include "IRincludes.h"
#endif
 
//-------------------STATISTICAL QUANTITIES---------------------------------- 
 

#ifndef __IR_UTIL_H__ 
#include "IRutil.h" 
#endif                      //end of #ifndef __IR_UTIL_H__ 
 
#ifndef __IR_FUNCTIONS_H__ 
#include "IRfunctions.h" 
#endif                      //end of #ifndef __IR_FUNCTIONS_H__ 
 
#ifndef __IR_MISC_GLOBAL_H__ 
#include "IRmiscGlobal.h" 
#endif	 //end of #ifndef __IR_MISC_GLOBAL_H__ 
 
#ifndef __IR_POSITION_H__
#include "Position.h"
#endif

#ifndef __IR_GAME_INFO_H__
#include "GameInfo.h"
#endif

#ifndef __IR_TRIAL_SPEC_H__ 
#include "TrialSpec.h" 
#endif	  //end of #ifndef __IR_TRIAL_SPEC_H__ 
 
#ifndef __IR_TURN_INFO_H__ 
#include "TurnInfo.h" 
#endif	  //end of #ifndef __IR_TURN_INFO_H__ 
 
#ifndef __IR_TUPLE_INFO_H__
#include "TupleInfo.h"
#endif 

#ifndef __IR_TURN_CONTEXT_H__
#include "TurnContext.h"
#endif

#ifndef __IR_FILTERS_H__ 
#include "Filters.h" 
#endif	  //end of #ifndef __IR_FILTERS_H__ 

#ifndef __IR_DELTA_SCALES_H__
#include "DeltaScales.h"
#endif    //end of #ifndef __IR_DELTA_SCALES_H__

 
#ifndef __IR_MODELS_H__
#include "IRmodels.h"
#endif


/*
struct MoveProjection { 
   double firstMoveProb; 
   double topMoveProb; 
   double playedMoveProb; 
   int playedMoveIndex; 
   double playedMoveDelta; 
   string firstMove; 
   string playedMove; 
   MoveProjection() : firstMoveProb(0.0), topMoveProb(0.0), playedMoveProb(0.0),
    playedMoveIndex(0), playedMoveDelta(0.0), firstMove(string("")), playedMove(string(""))
   { }
   ~MoveProjection() { }
}; 
*/

/** SimpleStats omits variance information.  //OK, well it has some.  //Indeed it has lots
    For speed in regression and bootstrapping.
 */
struct SimpleStats {   
   double accumWeight;
   vector<double> indexAccume;
   vector<double> indexMatchesWtd;   //includes first-index match
   vector<double> indexMatchesProjWtd;
   vector<double> indexMatchesVarianceProjWtd;
   double equalValueMatchWtd;
   double equalValueMatchProjWtd;
   double equalValueMatchVarianceProjWtd;
   double scaledFalloffWtd;
   double scaledFalloffProjWtd;
   double scaledFalloffVarianceProjWtd;
   double indexScoreWtd;
   double indexMassWtd;
   double indexScoreInvVarWtd;
   double indexScorePropWtd;
   double indexFitWtd;
   double indexDiffWtd;
   double indexDiffMassWtd;
   //vector<MoveSelector*>* mySelectors;   //left implicit
   vector<double> selectorMatchesPlayerWtd;   
   vector<double> selectorMatchesPlayerProjWtd;
   vector<double> selectorMatchesPlayerProjVarianceWtd;
   vector<double> selectorMatchesEngineWtd;
   SimpleStats(size_t numIndices, size_t numSelectors)
               //vector<MoveSelector*>* gselectors = new vector<MoveSelector*>())
    : accumWeight(0.0) //moveMatchWtd(0.0), moveMatchProjWtd(0.0),
    , indexAccume(vector<double>(numIndices,0.0))
    , indexMatchesWtd(vector<double>(numIndices,0.0))
    , indexMatchesProjWtd(vector<double>(numIndices,0.0))
    , indexMatchesVarianceProjWtd(vector<double>(numIndices,0.0))
    , equalValueMatchWtd(0.0), equalValueMatchProjWtd(0.0), equalValueMatchVarianceProjWtd(0.0)
    , scaledFalloffWtd(0.0), scaledFalloffProjWtd(0.0), scaledFalloffVarianceProjWtd(0.0)
    , indexScoreWtd(0.0), indexMassWtd(0.0), indexScoreInvVarWtd(0.0)
    , indexScorePropWtd(0.0), indexFitWtd(0.0), indexDiffWtd(0.0), indexDiffMassWtd(0.0)
    //, mySelectors(gselectors),
    , selectorMatchesPlayerWtd(vector<double>(numSelectors,0.0))
    , selectorMatchesPlayerProjWtd(vector<double>(numSelectors,0.0))
    , selectorMatchesPlayerProjVarianceWtd(vector<double>(numSelectors,0.0))
    , selectorMatchesEngineWtd(vector<double>(numSelectors,0.0))
   { }
   operator string() const {
      ostringstream oss;
      oss << scaledFalloffWtd << ": " << scaledFalloffProjWtd << " +- " << sqrt(scaledFalloffVarianceProjWtd)
          << endl << equalValueMatchWtd << ": " << equalValueMatchProjWtd << " +- " 
          << sqrt(equalValueMatchVarianceProjWtd) << endl;
      for (int j = 0; j < indexMatchesWtd.size(); j++) {
         oss << j << " " << indexMatchesWtd.at(j) << ": " << indexMatchesProjWtd.at(j) << " +- "
             << 2.0*sqrt(indexMatchesVarianceProjWtd.at(j)) << endl;
      }
      oss << "Selectors:" << endl;
      for (int i = 0; i < selectorMatchesPlayerWtd.size(); i++) {
         oss << i << " " << selectorMatchesPlayerWtd.at(i) << ": " << selectorMatchesPlayerProjWtd.at(i) 
             << " +- " << 2.0*sqrt(selectorMatchesPlayerProjVarianceWtd.at(i)) << endl;
      }
      return oss.str();
   }
};


class StatItem {
 public:
   string name;
   size_t maxOrderOfMagnitude;     //if max value is 999999.999 give value 6
   int numDecimals;  //can be negative, e.g. -2 means x100
   double measuredValue;
   double measuredVariance;

   double measuredSigma;
   double left2Sigma;
   double right2Sigma;

   StatItem() : name("???"), maxOrderOfMagnitude(8), numDecimals(2),
         measuredValue(0.0), measuredVariance(0.0) { 
      update();
   }

   StatItem(string gname, size_t maxOM, int numPlaces, double value, 
            double variance)
    : name(gname), maxOrderOfMagnitude(maxOM), numDecimals(numPlaces)
    , measuredValue(value), measuredVariance(variance) {
      update();
   }

   virtual ~StatItem() { }

   virtual void update(bool debug = false) {
      measuredSigma = sqrt(measuredVariance);
      left2Sigma = measuredValue - 2.0*measuredSigma;
      right2Sigma = measuredValue + 2.0*measuredSigma;
   }

   virtual void setName(string newName) { name = newName; }
   virtual void bootName() { setName(string("b-" + name)); }
   virtual void setMeasuredValue(double value) { measuredValue = value; }
   virtual void setMeasuredVariance(double value) { measuredVariance = value; }

   virtual operator string() const {
      ostringstream oss;
      size_t wd = 1 + numDecimals + maxOrderOfMagnitude;
      oss << std::setiosflags(ios::left) << setw(18) << name.substr(0,18);
      oss << resetiosflags(ios::left)
          << setiosflags(ios::right) << setiosflags(ios::fixed) 
          << showpoint << setprecision(numDecimals) 
          << setw(wd) << measuredValue;
      oss << setw(wd) << measuredSigma << ", two-sigma range: " 
          << setw(wd) << left2Sigma << "--" 
          << right2Sigma;
      return oss.str();
   }
};

class TestItem : public virtual StatItem {
 public:
   double projectedValue;
   double projectedVariance;
   int sign;              // +1 or -1
   double adjFactor;      //multiplier for dilated confidence intervals
   bool showAdj;

   double projectedSigma;
   double zScore;
   double projected2SigmaLeft;
   double projected2SigmaRight;
   double projectedSigmaAdj;
   double zScoreAdj;
   double projected2SigmaLeftAdj;
   double projected2SigmaRightAdj;

   TestItem() : StatItem(), projectedValue(0.0), projectedVariance(0.0)
    , sign(+1), adjFactor(1.0), showAdj(false) {
      update();
   }
   
   TestItem(string gname, size_t maxOM, int numPlaces, double value,
            double variance, double projValue, double projVariance,
            int gsign = 1, double af = 1.0, bool sa = false)
    : StatItem(gname, maxOM, numPlaces, value, variance)
    , projectedValue(projValue), projectedVariance(projVariance)
    , sign(gsign), adjFactor(af), showAdj(sa) {
      update();
   }

   virtual ~TestItem() { }

   virtual void update(bool debug = false) {
      StatItem::update();
      projectedSigma = sqrt(projectedVariance);
      zScore = sign*(measuredValue - projectedValue)/projectedSigma; //can be nan
      projected2SigmaLeft = projectedValue - 2.0*projectedSigma;
      projected2SigmaRight = projectedValue + 2.0*projectedSigma;
      projectedSigmaAdj = adjFactor*projectedSigma;
      zScoreAdj = sign*(measuredValue - projectedValue)/projectedSigmaAdj;
      projected2SigmaLeftAdj = projectedValue - 2.0*projectedSigmaAdj;
      projected2SigmaRightAdj = projectedValue + 2.0*projectedSigmaAdj;
   }

   virtual void setProjectedValue(double value) {  //caller must update afterward
      projectedValue = value;
   }
   virtual void setProjectedVariance(double newVariance) {
//cerr << "setting newVariance = " << newVariance << endl;
      projectedVariance = newVariance;
      //update(true);
      //update(false);
   }
      
   virtual operator string() const {
      ostringstream oss;
      double l2p = projected2SigmaLeft;  //(showAdj ? projected2SigmaLeft : projected2SigmaLeftAdj);
      double r2p = projected2SigmaRight; //(showAdj ? projected2SigmaRight : projected2SigmaRightAdj);
      double myz = zScore;   //(showAdj ? zScore : zScoreAdj);
      size_t wd = 1 + numDecimals + maxOrderOfMagnitude;
      oss << std::setiosflags(ios::left) << setw(18) << name.substr(0,18);
      oss << resetiosflags(ios::left) << setiosflags(ios::right)
          << showpoint << setiosflags(ios::fixed) << setprecision(numDecimals);
      oss << setw(wd) << projectedValue << setw(wd-3) << projectedSigma 
          << "; " << setw(wd) << measuredValue;
      oss << ", two-sigma range: " << setw(wd) << l2p << "--" << setw(wd) << r2p
          << ", z = " << showpos << setw(6) << myz;
      if (showAdj) { oss << ", adj " << zScoreAdj; }
      return oss.str();
   }
};

/** StatItem::measuredValue is interpeted as a running sum S_N, and measuredFreq as its mean.
 *  StatItem::measuredVariance however is re-interpreted as V_N = N*sigma_N^2, that is, as the
 *  running total variance.  The recursion for V_N in terms of S_N and the total volume T_N is:
 *  V_N = V_{N-1} + T_{N-1}(S_N/T_n - S_{N-1}/T_{N-1})^2 + (a_N - S_N/T_N)^2,
 *  where the new datum a_N includes any non-unti weight.  The uptick method thus has no add
 *  for the measured variance.  This makes measuredSigmaFreq correct as a percentage.
 *  For example, consider N = 98 with 49 observations of 0, 49 of 1.  Then we have:
 *  sigma = 0.5, sigma^2 = 0.25, N*sigma^2 = 24.5.  Next we observe a99 = 0, a100 = 1.
 *  On the first, uptick adds 98*(49/99 - 49/98)^2 + (49/99)^2 = 0.247474...
 *  On the second, uptick adds 99*(50/100 - 49/99)^2 + (1 - 50/100)^2 = 0.2525252...
 *  The net add is 0.5, bringing Nsigma^2 to 24.5 + 0.5 = 25.  So measuredSigma = 5.
 *  Finally measuredFreq = 0.5 = 50% and measuredSigmaFreq = 0.05 = 5%, as desired.
 */
class AggregateStat : public virtual StatItem {
 protected:
   double sampleVolume;       //for percentages, may be weighted
   //double runningTotal;     // = N*mean, or (total weight)*mean in general
   //double runningVariance;  // = N*sigma^2 etc.
   bool isPct;

 public:
   double measuredFreq;       // = total T divided by N
   double measuredSigmaFreq;  // = sigma/N
   double left2SigmaFreq;
   double right2SigmaFreq;

   AggregateStat() : StatItem(), sampleVolume(0.0), isPct(true) {
      update();
   }

   AggregateStat(string gname, size_t maxOM, int numPlaces, double value,
                 double variance, double volume, bool pct)
    : StatItem(gname, maxOM, numPlaces, value, variance)
    , sampleVolume(volume), isPct(pct) {
      update();
   }

   virtual ~AggregateStat() { }

   virtual void update(bool debug = false) {
      //measuredValue = runningTotal/sampleVolume;
      //measuredVariance = runningVariance/sampleVolume;
      StatItem::update();
      measuredFreq = IRutil::divifgt0(measuredValue,sampleVolume);
      measuredSigmaFreq = IRutil::divifgt0(measuredSigma,sampleVolume);
      left2SigmaFreq = measuredFreq - 2.0*measuredSigmaFreq;
      right2SigmaFreq = measuredFreq + 2.0*measuredSigmaFreq;
      left2SigmaFreq = (left2SigmaFreq < 0.0 ? 0.0 : left2SigmaFreq);
      right2SigmaFreq = (right2SigmaFreq > 99.99 ? 99.99 : right2SigmaFreq);
   }

   double getSampleVolume() const { return sampleVolume; }

   virtual void uptick(double addVolume, double addValue, //double addVariance,
                       bool updateNow = false) {
      double newVol = sampleVolume + addVolume;
      double newSum = measuredValue + addValue;
      measuredVariance += sampleVolume*IRutil::sqr(
            IRutil::divifgt0(newSum,newVol) - IRutil::divifgt0(measuredValue,sampleVolume));
      measuredVariance += IRutil::sqr(addValue - IRutil::divifgt0(newSum,newVol));
      sampleVolume = newVol;
      measuredValue = newSum;
      //measuredVariance += addVariance; //note: perhaps should update via E[(x - E[x])^2]
      if (updateNow) { update(); }
   }

   virtual operator string() const {
      ostringstream oss;
      string div = (isPct ? "%" : "");
      double mul = (isPct ? 100.0 : 1.0);
      double wd = 1 + numDecimals + maxOrderOfMagnitude;
      double prec = (isPct ? 2 : 4);
      oss << std::setiosflags(ios::left) << setw(18) << name.substr(0,18);
      oss << resetiosflags(ios::left) << setiosflags(ios::right)
          << setiosflags(ios::fixed) << showpoint << setprecision(numDecimals);
      oss << setw(wd) << measuredValue << setw(wd-3) << measuredSigma
          << "/" << setw(wd) << sampleVolume << " = ";
      oss << setprecision(prec) << setw(3+prec) << mul*measuredFreq << div << " " 
          << setw(3+prec) << mul*left2SigmaFreq << div << "--"
          << setw(3+prec) << mul*right2SigmaFreq << div;
      return oss.str();
   }
};


class AggregateTest : public TestItem, public AggregateStat {
 protected:
   double logpSum;     //uses projected probabilities
   double entropySum;
   bool showSums;

 public:    //no other "own" protected data
   double projectedFreq;
   double projectedSigmaFreq;
   double projected2SigmaLeftFreq;
   double projected2SigmaRightFreq;
   double projectedSigmaAdjFreq;
   double projected2SigmaLeftAdjFreq;
   double projected2SigmaRightAdjFreq;
   //static const string header;


   AggregateTest() : StatItem(), AggregateStat(), TestItem() 
    , logpSum(0.0), entropySum(0.0), showSums(false) { 
      update();
   }

   AggregateTest(string gname, size_t maxOM, int numPlaces, double value,
                 double variance, double volume, bool pct,
                 double projValue, double projVariance,
                 int gsign = 1, double af = 1.0, bool sa = false, bool ss = false)
    : StatItem(gname, maxOM, numPlaces, value, variance)
    , AggregateStat(gname, maxOM, numPlaces, value, variance, volume, pct)
    , TestItem(gname, maxOM, numPlaces, value, variance,
               projValue, projVariance, gsign, af, sa)
    , logpSum(0.0), entropySum(0.0), showSums(ss) {
      update();
   }

   static const string header() { return string(
"Name                 ProjVal  St.Dev    Actual;   Proj% Actual%  2sigma range   z-score");
   }

   virtual void update(bool debug = false) {
if (debug) { cerr << string(*this) << " is now " << endl; }
      AggregateStat::update();
      TestItem::update();  //re-does base class but that's OK
if (debug) { cerr << string(*this) << endl; }
      projectedFreq = IRutil::divifgt0(projectedValue, sampleVolume);
      projectedSigmaFreq = IRutil::divifgt0(projectedSigma, sampleVolume);
      projected2SigmaLeftFreq = projectedFreq - 2.0*projectedSigmaFreq;
      projected2SigmaRightFreq = projectedFreq + 2.0*projectedSigmaFreq;
      projectedSigmaAdjFreq = projectedSigmaFreq*adjFactor;
      projected2SigmaLeftAdjFreq = projectedFreq - 2.0*projectedSigmaAdjFreq;
      projected2SigmaRightAdjFreq = projectedFreq + 2.0*projectedSigmaAdjFreq;
   }

   virtual void uptick(double addVolume, double addValue, //double addVariance, 
                       double addProjectedValue, double addProjectedVariance,
                       double addLogSum, double addEntropySum, bool updateNow = false) {
      AggregateStat::uptick(addVolume, addValue, false);  //addVariance, false);
      projectedValue += addProjectedValue;
      projectedVariance += addProjectedVariance;
      logpSum += addLogSum;
      entropySum += addEntropySum;  //!!!need projected variance add...
      if (updateNow) { update(); }
   }

   virtual void setProjectedVariance(double newVariance) {
//cerr << "setting newVariance = " << newVariance << endl;
      projectedVariance = newVariance;
      //update(true);
      //update(false);
   }



   virtual operator string() const {
      ostringstream oss;
      double l2f = projected2SigmaLeftFreq;  //(showAdj ? projected2SigmaLeftFreq : projected2SigmaLeftAdjFreq);
      double r2f = projected2SigmaRightFreq; //(showAdj ? projected2SigmaRightFreq : projected2SigmaRightAdjFreq);
      double myz = zScore;  //(showAdj ? zScore : zScoreAdj);
      
      string div = (isPct ? "%" : "");
      double mul = (isPct ? 100.0 : 1.0);
      string divcolon = div+(mul*measuredFreq >= 100.0 ? ":" : ": ");
      double wd = 1 + numDecimals + maxOrderOfMagnitude;
      double prec = (isPct ? 2 : 4);
      oss << std::setiosflags(ios::left) << setw(18) << name.substr(0,18);
      oss << resetiosflags(ios::left) << setiosflags(ios::right) 
          << setiosflags(ios::fixed) << showpoint << setprecision(numDecimals);
      oss << setw(wd) << projectedValue << setw(wd-3) << projectedSigma << ": "
          << setw(wd) << measuredValue << "  ";
      oss << setprecision(prec) << setw(2+prec) << mul*projectedFreq << divcolon 
          << setw(2+prec) << mul*measuredFreq << div << " "
          << setw(2+prec) << mul*l2f << div << "--" << setw(2+prec) << mul*r2f << div
          << ", z = " << showpos << setw(5) << myz;
      if (showAdj) { oss << ", adj " << setw(5) << zScoreAdj; }
      if (showSums) {
         oss << endl << noshowpos << "Log(1/p) sum: " << logpSum << ", p*log(1/p) sum: " << entropySum;
      }
      return oss.str();
   }
};

/*
const string AggregateTest::header = string(
"Name              ProjVal  St.Dev    Actual;   Proj% Actual%  2sigma range   z-score");
*/


class MoveIndexTest : public AggregateTest {
 protected:
   size_t index;
   double deltaSum;
   double swingFixedSum;
   double swingUsedSum;
   double swingRelSum;

 public:
   double meanDelta;
   double meanSwingFixed;
   double meanSwingUsed;
   double meanSwingRel;
   //static const string header;

   MoveIndexTest() : AggregateTest(), index(0), deltaSum(0.0),
                     swingFixedSum(0.0), swingUsedSum(0.0), swingRelSum(0.0) { 
      update();
   }

   MoveIndexTest(int ind, size_t maxOM, int numPlaces, double value,
                 double variance, double volume, bool pct, double projValue,
                 double projVariance, double ds, double sfs, double sus, double srs,
                 int gsign, double af, bool sa, bool ss)
    : StatItem(IRutil::itoa(ind), maxOM, numPlaces, value, variance) 
    , AggregateTest(IRutil::itoa(ind), maxOM, numPlaces, value, variance, volume, pct,
                    projValue, projVariance, gsign, af, sa, ss)
    , index(ind), deltaSum(ds), swingFixedSum(sfs), swingUsedSum(sus), swingRelSum(srs) { 
      update();
   }

   virtual void update(bool debug = false) {
      AggregateTest::update(debug);
      meanDelta = IRutil::divifgt0(deltaSum, sampleVolume);
      meanSwingFixed = IRutil::divifgt0(swingFixedSum, sampleVolume);
      meanSwingUsed = IRutil::divifgt0(swingUsedSum, sampleVolume);
      meanSwingRel = IRutil::divifgt0(swingRelSum, sampleVolume);
   }

   virtual void uptick(double addVolume, double addValue, //double addVariance,
                       double addProjectedValue, double addProjectedVariance,
                       double addLogSum, double addEntropySum, double addDelta,
                       double addSwingFixed, double addSwingUsed, double addSwingRel,
                       bool updateNow = false) {
      AggregateTest::uptick(addVolume, addValue, //addVariance, 
                            addProjectedValue, addProjectedVariance, addLogSum, 
                            addEntropySum, false);
      deltaSum += addDelta;
      swingFixedSum += addSwingFixed;
      swingUsedSum += addSwingUsed;
      swingRelSum += addSwingRel;
      if (updateNow) { update(); }  //updates the parent too
   }

   operator string() const {
      ostringstream oss;
      double l2f = (showAdj ? projected2SigmaLeftFreq : projected2SigmaLeftAdjFreq);
      double r2f = (showAdj ? projected2SigmaRightFreq : projected2SigmaRightAdjFreq);
      double myz = (showAdj ? zScore : zScoreAdj);
      string div = (isPct ? "%" : "");
      double mul = (isPct ? 100.0 : 1.0);
      size_t wd = 1 + numDecimals + maxOrderOfMagnitude;
      double prec = (isPct ? 2 : 4);
      oss << resetiosflags(ios::left) << setiosflags(ios::right) << showpoint;
      oss << setw(2) << setiosflags(ios::fixed) << index
          << setprecision(2) << setw(6) << meanDelta 
          << setprecision(4) << setw(8) << meanSwingFixed 
          << setprecision(4) << setw(8) << meanSwingUsed 
          << setprecision(4) << setw(8) << meanSwingRel;
      oss << setiosflags(ios::fixed) << setprecision(numDecimals);
      oss << setw(wd) << projectedValue << setw(wd-3) << projectedSigma << ": "
          << setw(wd) << measuredValue << "  ";
      oss << setprecision(prec) << setw(3+prec) << mul*projectedFreq << div << ": "
          << setw(3+prec) << mul*measuredFreq << div << " "
          << setw(3+prec) << mul*l2f << div << "--" << setw(3+prec) << mul*r2f << div
          << ", z = " << showpos << setw(6) << myz;
      if (showAdj) { oss << ", adj " << setw(6) << zScoreAdj; }
      if (showSums) {
         oss << endl << noshowpos << "Log(1/p) sum: " << logpSum << ", p*log(1/p) sum: " << entropySum;
      }
      return oss.str();
   }

   static const string header() { return string(
"i  mDelta SwNotDD SwingDD SwRel    ProjVal  Sigma      Actual   Proj% Actual%  2sigma range   z-score");
   }
};

/*
const string MoveIndexTest::header = string(
"i  mDelta SwFixed SwUsed  SwRel    ProjVal  Sigma      Actual   Proj% Actual%  2sigma range   z-score");
*/


class SelectionTest : public AggregateTest {
 public:
   double engineMatches;  //measuredValue refers to played-move matches
   double engineMatchFreq;
   //static const string header;

   SelectionTest() : AggregateTest(), engineMatches(0.0), engineMatchFreq(0.0) {
      update();
   }

   SelectionTest(string gname, size_t maxOM, int numPlaces, double value,
                 double variance, double volume, bool pct, double projValue,
                 double projVariance, double runningEngineMatches,
                 int gsign = 1, double af = 1.0, bool sa = false, bool ss = false)
    : StatItem(gname, maxOM, numPlaces, value, variance)
    , AggregateTest(gname, maxOM, numPlaces, value, variance, volume, pct,
                    projValue, projVariance, gsign, af, sa, ss)
    , engineMatches(runningEngineMatches) {
      update();
   }

   virtual void update(bool debug = false) {
      AggregateTest::update();
      engineMatchFreq = (sampleVolume > 0 ? engineMatches / sampleVolume : 0.0);
   }

   virtual void uptick(double addVolume, double addValue, //double addVariance,
                       double addProjectedValue, double addProjectedVariance,
                       double addLogSum, double addEntropySum, double addEngineMatches,
                       bool updateNow = false) {
      AggregateTest::uptick(addVolume, addValue, //addVariance, 
                            addProjectedValue, addProjectedVariance, 
                            addLogSum, addEntropySum, false);
      engineMatches += addEngineMatches;
      if (updateNow) { update(); }
   }

   virtual operator string() const {
      ostringstream oss;
      double l2f = projected2SigmaLeftFreq;  //(showAdj ? projected2SigmaLeftFreq : projected2SigmaLeftAdjFreq);
      double r2f = projected2SigmaRightFreq; //(showAdj ? projected2SigmaRightFreq : projected2SigmaRightAdjFreq);
      double myz = zScore;  //(showAdj ? zScore : zScoreAdj);
      string div = (isPct ? "%" : " ");
      double mul = (isPct ? 100.0 : 1.0);
      string divcolon = div+(mul*measuredFreq >= 100.0 ? ":" : ": ");
      size_t wd = 1 + numDecimals + maxOrderOfMagnitude;
      double prec = (isPct ? 2 : 4);
      oss << std::setiosflags(ios::left) << setw(18) << name.substr(0,18);
      oss << resetiosflags(ios::left) << setiosflags(ios::right)
          << setiosflags(ios::fixed) << setprecision(numDecimals) << showpoint;
      oss << setw(wd) << projectedValue << setw(wd-3) << projectedSigma << ": "
          << setw(wd) << measuredValue << " ";
      oss << setprecision(prec) << setw(3+prec) << mul*projectedFreq << divcolon
          << setw(3+prec) << mul*measuredFreq << div << " "
          << setw(3+prec) << mul*l2f << div << "--" << setw(3+prec) << mul*r2f << div
          << ", z = " << showpos << setw(6) << myz << noshowpos;
      oss << ", engm% = " << noshowpos << mul*engineMatchFreq;
      if (showSums) {
         oss << endl << "Log(1/p) sum: " << logpSum << ", p*log(1/p) sum: " << entropySum;
      }
      //oss << endl << "Engine matches: " << engineMatches << "/" << sampleVolume
          //<< " = " << mul*engineMatchFreq << div;
      return oss.str();
   }

   static const string header() { return string(
"Selection Test       ProjVal  St.Dev    Actual;  Proj%  Actual%  2sigma range  z-score");
   }

};

/*
const string SelectionTest::header = string(
"Selection Test    ProjVal  St.Dev    Actual;  Proj%  Actual%  2sigma range  z-score");
*/


class BootstrappedItem {  //uses wrapping not templates
 protected:
   StatItem* original;
   StatItem* bootcopy;
   size_t numBootTrials; //optional

 public:
   BootstrappedItem(StatItem* orig, double bootValue, double bootVariance, size_t numTrials)
    : original(orig)
    , bootcopy(new StatItem("boot"+IRutil::itoa(numTrials), original->maxOrderOfMagnitude,
                                 original->numDecimals, bootValue, bootVariance))
    , numBootTrials(numTrials) {
      bootcopy->update();
   }

   virtual ~BootstrappedItem() { delete(bootcopy); }

   operator string() const {
      ostringstream oss;
      oss << string(*original) << endl << string(*bootcopy);
      return oss.str();
   }
};


 
/** Performance data and statistics, including ones for other regressions 
    besides the main "Percentile Fitting" method. 
    [Can use some suggestions for more stats to include, and for how to 
    weight different kinds of fit stats for an "Omni Regression".] 
 */ 
class PerfData { 
 public: 
   bool weighted;   //Now controls whether unweighted items are filled
   double deltaCap; 
 
   //Fields filled in by perfTest(...) from class Trial---now by calls to uptick
   int numTurns;           // actual number of MoveProjection items
   int totalBootItems;     // \sum_i bootWeight(i)
   double accumWeight;     // \sum_i wt(i)*bootWeight(i)  //in case of carryover
   //Otherwise == sampleVolume field on individual AggregateTest items (duplicated)

   //Vector of length totalBootItems, not numTurns
   vector<Models::MoveProjection*>* turnsData;
 
   vector<MoveIndexTest> moveIndexTests;
   vector<MoveIndexTest> moveIndexTestsWtd;

   AggregateTest scaledFalloff;
   AggregateTest scaledFalloffWtd;
   AggregateTest unscaledFalloff;
   AggregateTest unscaledFalloffWtd;

   AggregateStat scaledFalloffNextTurnCapped;
   AggregateStat scaledFalloffNextTurnCappedWtd;
   AggregateStat unscaledFalloffNextTurnCapped;
   AggregateStat unscaledFalloffNextTurnCappedWtd;

   AggregateTest moveMatch;   //duplicates moveIndexTests[0]
   AggregateTest equalValueMatch;
   AggregateTest playedMoveMatch; //100% on actual but pred is relevant
   

   AggregateTest moveMatchWtd;   //duplicates moveIndexTestsWtd[0]
   AggregateTest equalValueMatchWtd;
   AggregateTest playedMoveMatchWtd;

   vector<SelectionTest> selectionTests;
   vector<SelectionTest> selectionTestsWtd;
   

//-----------Other performance statistics---------------------- 
 
   double indexFit; 
   double indexFitMass; 
   double indexFitInvVar; 
   double indexFitProp; 
   double indexDiff;
   double indexDiffMass;
   double indexFitWtd; 
   double indexFitMassWtd; 
   double indexFitInvVarWtd; 
   double indexFitPropWtd; 
   double indexDiffWtd;
   double indexDiffMassWtd;
 
 
//------------------Constructors etc.--------------------------- 
 
   explicit PerfData(double cap, size_t etvl = IRutil::NCUTOFF,
                     int gNumTurns = 0, double gaccumWeight = 0.0) 
    : deltaCap(cap), numTurns(gNumTurns), totalBootItems(0), accumWeight(gaccumWeight)
    , turnsData(new vector<Models::MoveProjection*>())   //dim numDecisions filled by class Trial`
    , moveIndexTests(vector<MoveIndexTest>())   //IRutil::NCUTOFF + 1))  //dim Ncutoff
    , moveIndexTestsWtd(vector<MoveIndexTest>()) //IRutil::NCUTOFF + 1))

    , scaledFalloff(AggregateTest("AvgScaledDiff",7,2,0.0,0.0,0.0,false,0.0,0.0,-1,1.4,true,false))
    , scaledFalloffWtd(AggregateTest("AvgScaledDiffW",7,2,0.0,0.0,0.0,false,0.0,0.0,-1,1.4,true,false))
    , unscaledFalloff(AggregateTest("UnscaledFalloff",7,2,0.0,0.0,0.0,false,0.0,0.0,-1,1.4,true,false))
    , unscaledFalloffWtd(AggregateTest("UnscaledFalloffW",7,2,0.0,0.0,0.0,false,0.0,0.0,-1,1.4,true,false))
    , scaledFalloffNextTurnCapped(AggregateStat("NextTurnFalloff",7,2,0.0,0.0,0.0,false))
    , scaledFalloffNextTurnCappedWtd(AggregateStat("NextTurnFalloffW",7,2,0.0,0.0,0.0,false))
    , unscaledFalloffNextTurnCapped(AggregateStat("NextTurnFalloffU",7,2,0.0,0.0,0.0,false))
    , unscaledFalloffNextTurnCappedWtd(AggregateStat("NextTurnFalloffUW",7,2,0.0,0.0,0.0,false))

    , moveMatch(AggregateTest("MoveMatch", 7, 2, 0.0, 0.0, 0.0, true, 0.0, 0.0, +1, 1.15, true, false))
    , equalValueMatch(AggregateTest("EqValueMatch["+IRutil::itoa(etvl)+"]", 7, 2, 0.0, 0.0, 0.0, true, 0.0, 0.0, +1, 1.2, true, false))
    , playedMoveMatch(AggregateTest("PlayedMoveMatch", 7, 2, 0.0, 0.0, 0.0, true, 0.0, 0.0, +1, 1.0, false, false))
    , moveMatchWtd(AggregateTest("MoveMatchWtd", 7, 2, 0.0, 0.0, 0.0, true, 0.0, 0.0, +1, 1.15, true, false))
    , equalValueMatchWtd(AggregateTest("EqValueMatchW["+IRutil::itoa(etvl)+"]", 7, 2, 0.0, 0.0, 0.0, true, 0.0, 0.0, +1, 1.2, true, false))
    , playedMoveMatchWtd(AggregateTest("PlayedMoveMatchW", 7, 2, 0.0, 0.0, 0.0, true, 0.0, 0.0, +1, 1.0, false, false))

    , selectionTests(vector<SelectionTest>())
    , selectionTestsWtd(vector<SelectionTest>())

    , indexFit(0.0)
    , indexFitMass(0.0)
    , indexFitInvVar(0.0)
    , indexFitProp(0.0)
    , indexDiff(0.0)
    , indexDiffMass(0.0)
    , indexFitWtd(0.0)
    , indexFitMassWtd(0.0)
    , indexFitInvVarWtd(0.0)
    , indexFitPropWtd(0.0)
    , indexDiffWtd(0.0)
    , indexDiffMassWtd(0.0)

   { } 
 
   virtual ~PerfData() { 
      vector<Models::MoveProjection*>::iterator itr = turnsData->begin();
      vector<Models::MoveProjection*>::iterator itre = turnsData->end();
      while (itr != itre) {
         delete(*itr++);
      }
      delete(turnsData);
   }
/*
      delete(playedMoveIndexHistogram);
      delete(playedMoveIndexHistogramWtd);
      delete(predMoveIndices);
      delete(predMoveVariances);
      delete(predMoveIndicesWtd);
      delete(predMoveVariancesWtd);
      delete(meanDeltas);
      delete(meanDeltasWtd);
      IRutil::perfDataDeleted++;
      if (IRutil::perfDataDeleted % IRutil::TURNSMODULUS == 0) {
         cerr << "PerfData made: " << IRutil::perfDataMade
              << ", deleted: " << IRutil::perfDataDeleted << endl;
      }
   }

*/
   static string perfHeader(bool flm) { 
      const string s = flm ? "1stLM %" : "Top-M %"; 
      const string st = 
    "Category  #Turns   Act. - Pred "+ s +"   PM %   Predic. / Actual Falloff"; 
   //cccccccc: dddddd   dd.d - dd.d = +dd.d   dd.d   ddddd.d / ddddd.d = d.ddd 
   //scaled, weighted falloff only here 
      return st; 
   } 

   string perfLine(const string& leader, bool flm, int dw = 7) const { 
      ostringstream ost; 
      double actFreq = (flm ? moveMatch.measuredFreq : equalValueMatch.measuredFreq);
      double predFreq = (flm ? moveMatch.projectedFreq : equalValueMatch.projectedFreq);
      //double predFreq = flm ? predFirstMoveFreq : predTopFreq; 
      ost << fixed << setw(8) << left << leader << ": " 
          << setw(6) << right << int(accumWeight + 0.5) << "   " 
          << setprecision(1) << showpoint 
          << setw(4) << right << actFreq << " - " 
          << setw(4) << left << predFreq << " = " 
          << setw(5) << right << showpos << actFreq-predFreq << "   " 
          << setw(4) << right << noshowpos << playedMoveMatch.projectedFreq << "   " 

          << setw(dw) << right << scaledFalloffWtd.projectedFreq << " / " 
          << setw(dw) << right << scaledFalloffWtd.measuredValue << " = " 
          << setprecision(2) 
          << setw(4) << right << (scaledFalloffWtd.projectedFreq)/(scaledFalloffWtd.measuredValue); 
       return ost.str(); 
   } 
 
   string moveHeader() const { 
      ostringstream ost; 
      ost << fixed << "  " << setw(14) << " Played Move  " << setw(3) 
          << "PMI" << "  " << setw(11) << "Engine Move" 
          << "  " << setprecision(3) << setw(6) << "ProbEM" 
          << "  " << setw(6) << "ProbPM" << "  " 
             << setprecision(2) << setw(5) << "Delta"; 
      return ost.str(); 
   } 
 
   /** playedMove playedMoveIndex firstMove firstMoveProb playedMoveProb delta 
    */ 
   string moveLine(const Models::MoveProjection* const mp, bool flm = true) const { 
      ostringstream ost; 
      string em = (mp->indexPlayedMove == mp->indexFirstMove) ? "   MATCH   " : mp->firstMove; 
      ost << fixed << "  " << setw(14) << left << mp->playedMove  
          << setw(4) << right << mp->indexPlayedMove
          << "  " << setw(11) << left << em 
          << "  " << right << setprecision(3) << setw(6) << mp->probs->at(mp->indexFirstMove); 
      if (em != " MATCH ") { 
         ost << "  " << right << setw(6) << mp->probs->at(mp->indexPlayedMove) << "  " 
             << setprecision(2) << setw(5) << right << mp->playedMoveDeltaScaled; 
      } 
      return ost.str(); 
   } 
 
   string dStats(const string& leader, int dw, bool wtd, 
                 double pred, double predf, double p2sl, double p2sr, 
                 double pf2sl, double pf2sr, double act, double actf) const { 
      ostringstream ost; 
      string adj = (wtd && fabs(accumWeight - numTurns) 
                        > IRutil::MINGTZERO) ? "Wtd." : "Unwtd."; 
      ost << fixed << setprecision(dw-4) << showpoint 
          << setw(7) << left << leader << ": " 
          << setw(dw) << right << numTurns << "  " 
          << adj << " filtered turns, total weight " << accumWeight << endl 
          << setw(7) << left << "Predic." << ": " 
          << setw(dw) << right << pred << ", " << setprecision(2) 
          << setw(5) << right << predf << "%, two-sigma range: " 
          << setprecision(dw-4) << setw(dw) << right << p2sl << "--" 
          << setw(dw) << left << p2sr << ", " 
          << setprecision(2) << setw(5) << right << pf2sl << "--" 
          << setw(5) << left << pf2sr << "%" << endl 
          << setprecision(dw-4) << setw(7) << left << "Actual" << ": " 
          << setw(dw) << right << act << ", " 
          << setprecision(2) << setw(5) << right << actf << "%"; 
      return ost.str(); 
   } 
 
 
 
   string firstMoveMatchStats(const string& leader, int dw, bool wtd = true) const { 
      double pfm = wtd ? moveMatchWtd.projectedValue : moveMatch.projectedValue; 
      double pfmf = wtd ? moveMatchWtd.projectedFreq : moveMatch.projectedFreq; 
      double fm2sl = wtd ? moveMatchWtd.projected2SigmaLeft : moveMatch.projected2SigmaLeft; 
      double fm2sr = wtd ? moveMatchWtd.projected2SigmaRight : moveMatch.projected2SigmaRight; 
      double fm2slf = wtd ? moveMatchWtd.projected2SigmaLeftFreq : moveMatch.projected2SigmaLeftFreq;
      double fm2srf = wtd ? moveMatchWtd.projected2SigmaRightFreq : moveMatch.projected2SigmaRightFreq;
      double fma = wtd ? moveMatchWtd.measuredValue : moveMatch.measuredValue; 
      double fmaf = wtd ? moveMatchWtd.measuredFreq : moveMatch.measuredFreq; 
      return dStats(leader,dw,wtd,pfm,pfmf,fm2sl,fm2sr,fm2slf,fm2srf,fma,fmaf); 
   } 

   string topMatchStats(const string& leader, int dw, bool wtd = true) const { 
      double ptm = wtd ? equalValueMatchWtd.projectedValue : equalValueMatch.projectedValue;
      double ptmf = wtd ? equalValueMatchWtd.projectedFreq : equalValueMatch.projectedFreq;
      double tm2sl = wtd ? equalValueMatchWtd.projected2SigmaLeft : equalValueMatch.projected2SigmaLeft;
      double tm2sr = wtd ? equalValueMatchWtd.projected2SigmaRight : equalValueMatch.projected2SigmaRight;
      double tm2slf = wtd ? equalValueMatchWtd.projected2SigmaLeftFreq : equalValueMatch.projected2SigmaLeftFreq;
      double tm2srf = wtd ? equalValueMatchWtd.projected2SigmaRightFreq : equalValueMatch.projected2SigmaRightFreq;
      double tma = wtd ? equalValueMatchWtd.measuredValue : equalValueMatch.measuredValue;
      double tmaf = wtd ? equalValueMatchWtd.measuredFreq : equalValueMatch.measuredFreq;
      return dStats(leader,dw,wtd,ptm,ptmf,tm2sl,tm2sr,tm2slf,tm2srf,tma,tmaf); 
   }       
        
   string matchStats(const string& leader, bool flm, int dw, bool wtd = true) const { 
      if (flm) { 
         return firstMoveMatchStats(leader,dw,wtd); 
      } else { 
         return topMatchStats(leader,dw,wtd); 
      } 
   //return (flm ? firstMoveMatchStats(leader,dw) : topMatchStats(leader,dw)); 
   //causes SegFault on CC -fast on "nussex" and "castor", not "pegasus"... 
   } 
       
   /** Call with unweighted PerfData object to get Unwtd stats 
 *     to-do (??) !!!
    */ 
   string falloffStats(const string& hl, bool scaled, int dw, bool wtd = true) 
   const { 
      string headline = hl + (scaled ? ", scaled" : ", not scaled"); 
      double pe = scaled ? (wtd ? scaledFalloffWtd.projectedValue : scaledFalloff.projectedValue) 
                         : (wtd ? unscaledFalloffWtd.projectedValue : unscaledFalloff.projectedValue); 
      double pef = scaled ? (wtd ? scaledFalloffWtd.projectedFreq 
                                 : scaledFalloff.projectedFreq) 
                          : (wtd ? unscaledFalloffWtd.projectedFreq  
                                 : unscaledFalloff.projectedFreq); 
      double pe2sl = scaled ? (wtd ? scaledFalloffWtd.projected2SigmaLeft 
                                   : scaledFalloff.projected2SigmaLeft) 
                            : (wtd ? unscaledFalloffWtd.projected2SigmaLeft 
                                   : unscaledFalloff.projected2SigmaLeft); 
      double pe2sr = scaled ? (wtd ? scaledFalloffWtd.projected2SigmaRight 
                                   : scaledFalloff.projected2SigmaRight) 
                            : (wtd ? unscaledFalloffWtd.projected2SigmaRight 
                                   : unscaledFalloff.projected2SigmaRight); 
      double pe2slf= scaled ? (wtd ? scaledFalloffWtd.projected2SigmaLeftFreq 
                                   : scaledFalloff.projected2SigmaLeftFreq) 
                            : (wtd ? unscaledFalloffWtd.projected2SigmaLeftFreq 
                                   : unscaledFalloff.projected2SigmaLeftFreq); 
      double pe2srf= scaled ? (wtd ? scaledFalloffWtd.projected2SigmaRightFreq 
                                   : scaledFalloff.projected2SigmaRightFreq) 
                            : (wtd ? unscaledFalloffWtd.projected2SigmaRightFreq 
                                   : unscaledFalloff.projected2SigmaRightFreq); 
      double ae = scaled ? (wtd ? scaledFalloffWtd.measuredValue : scaledFalloff.measuredValue) 
                         : (wtd ? unscaledFalloffWtd.measuredValue : unscaledFalloff.measuredValue); 
      double aef = scaled ? (wtd ? scaledFalloffWtd.measuredFreq : scaledFalloff.measuredFreq) 
                        : (wtd ? unscaledFalloffWtd.measuredFreq : unscaledFalloff.measuredFreq); 
      return dStats(headline,dw,wtd,pe,pef,pe2sl,pe2sr,pe2slf,pe2srf,ae,aef); 
   } 
 
   string fullReport(size_t numIndices = 15, bool clumpRest = false) const; 
   string fullReportOld() const;
 
   string movesReport(bool flm = true) const { 
      string out = moveHeader() + "\n"; 
      for (int i = 0; i < turnsData->size(); i++) { 
         out += moveLine(turnsData->at(i),flm); 
         out += "\n"; 
      } 
      return out; 
   } 
}; 
 

struct IPRstats {    //Note: IPR uses the /projected/ freq from pfElo
   TrialSpec ts;
   TestItem ipr;    //Use projected variance as measured variance
   TestItem iprAdj;
   TestItem iprAuto;
   TestItem iprAdjByAuto;
   double autoRatio;
   double ownSigma;
   IPRstats(const PerfData& pfElo, const PerfData& pfSigmas, const TrialSpec& gts)
    : ts(gts)
    , ipr(TestItem("IPR", 4, 0, 
            IRfun::ipr(pfElo.scaledFalloffWtd.projectedFreq, gts.weightMethodChoice),
            IRutil::sqr(IRfun::ipr(pfSigmas.scaledFalloffWtd.projectedFreq, gts.weightMethodChoice)
                        - IRfun::ipr(pfSigmas.scaledFalloffWtd.projected2SigmaLeftFreq, gts.weightMethodChoice))/4.0,
            IRfun::ipr(pfElo.scaledFalloffWtd.projectedFreq, gts.weightMethodChoice),
            IRutil::sqr(IRfun::ipr(pfSigmas.scaledFalloffWtd.projectedFreq, gts.weightMethodChoice)
                        - IRfun::ipr(pfSigmas.scaledFalloffWtd.projected2SigmaLeftFreq, gts.weightMethodChoice))/4.0,
      1.0, 1.0, false))
    , iprAdj(TestItem("IPRadj", 4, 0,
            IRfun::ipr(pfElo.scaledFalloffWtd.projectedFreq, gts.weightMethodChoice),
            IRutil::sqr(IRfun::ipr(pfSigmas.scaledFalloffWtd.projectedFreq, gts.weightMethodChoice)
                        - IRfun::ipr(pfSigmas.scaledFalloffWtd.projected2SigmaLeftAdjFreq,gts.weightMethodChoice))/4.0,
            IRfun::ipr(pfElo.scaledFalloffWtd.projectedFreq,gts.weightMethodChoice),
            IRutil::sqr(IRfun::ipr(pfSigmas.scaledFalloffWtd.projectedFreq,gts.weightMethodChoice)
                        - IRfun::ipr(pfSigmas.scaledFalloffWtd.projected2SigmaLeftAdjFreq,gts.weightMethodChoice))/4.0,
      1.0, 1.4, true))

    , iprAuto(TestItem("IPRauto", 4, 0,
            //IRfun::ipr(pfSigmas.scaledFalloffWtd.measuredFreq,gts.weightMethodChoice),
            //Doesn't matter: projected = actual-measured on the person's own games
            IRfun::ipr(pfSigmas.scaledFalloffWtd.projectedFreq,gts.weightMethodChoice),
            IRutil::sqr(IRfun::ipr(pfSigmas.scaledFalloffWtd.projectedFreq,gts.weightMethodChoice)
                        - IRfun::ipr(pfSigmas.scaledFalloffWtd.projected2SigmaLeftFreq,gts.weightMethodChoice))/4.0,
            IRfun::ipr(pfSigmas.scaledFalloffWtd.projectedFreq,gts.weightMethodChoice),
            IRutil::sqr(IRfun::ipr(pfSigmas.scaledFalloffWtd.projectedFreq,gts.weightMethodChoice)
                        - IRfun::ipr(pfSigmas.scaledFalloffWtd.projected2SigmaLeftFreq,gts.weightMethodChoice))/4.0,
      1.0, 1.0, false))

    , autoRatio(IRutil::divifgt0(pfSigmas.scaledFalloffWtd.measuredFreq, pfSigmas.scaledFalloffWtd.projectedFreq))
    , ownSigma(pfSigmas.scaledFalloffWtd.measuredSigmaFreq)
   {
      iprAdjByAuto = TestItem("IPRadjbyauto", 4, 0,
            IRfun::ipr(pfElo.scaledFalloffWtd.projectedFreq*autoRatio,gts.weightMethodChoice),
            iprAuto.measuredVariance,
            IRfun::ipr(pfElo.scaledFalloffWtd.projectedFreq*autoRatio,gts.weightMethodChoice),
            iprAuto.projectedVariance,
      1.0, 1.0, false);
   }

   ~IPRstats() {
      //delete(ipr);
      //delete(iprAdj);
      //delete(iprAuto);
      //delete(iprAdjByAuto);
   }
};


#endif   //end of #ifndef __IR_PERFDATA_H__ 
 
 
 
//File---------------------PerfData.cpp---------------------------------- 
 
#ifndef __IR_PERFDATA_CPP__ 
#define __IR_PERFDATA_CPP__ 

#ifndef __IR_PERFDATA_H__
#include "PerfData.h"
#endif   //end of #ifndef __IR_PERFDATA_H__


string PerfData::fullReport(size_t numIndices, bool clumpRest) const {

   if (numTurns == 0) { return "No turns---nothing to see."; }
   if (numIndices > moveIndexTestsWtd.size()) { numIndices = moveIndexTestsWtd.size(); }

   ostringstream o;
   string adj = weighted ? "Wtd." : "Unwtd.";
   o << "From " << numTurns << " turns with total weight " << accumWeight 
     << ", move indices first:" << endl << endl;

   o << MoveIndexTest::header() << endl;
   for (int i = 0; i < numIndices; i++) {
      o << string(moveIndexTestsWtd.at(i)) << endl;
   }
   o << "Index fits, x10,000: "
          << setprecision(4) << 10000.0*indexFit << ", wtd. "
          << 10000.0*indexFitWtd << ", diff " << indexDiffWtd << "; mass " << 10000.0*indexFitMass
          << ", wtd. " << 10000.0*indexFitMassWtd << "; diff " << indexDiffMassWtd << endl;

   o << endl << AggregateTest::header() << endl;
   o << string(scaledFalloffWtd) << endl;
   o << string(moveMatchWtd) << endl;
   o << string(equalValueMatchWtd) << endl;
   o << string(playedMoveMatchWtd) << endl;

   size_t numST = selectionTestsWtd.size();
   if (numST > 0) {
      o << endl << SelectionTest::header() << endl;
      for (int j = 0; j < numST; j++) {
         o << string(selectionTests.at(j)) << endl;
      }
   }

   ofstream zscoref("zMM.txt", ios::app);
   zscoref << fixed << showpoint << setprecision(4) << setw(7) << right
           << moveMatchWtd.zScore << endl;
   zscoref.close();

   ofstream zscorev("zEV.txt", ios::app);
   zscorev << fixed << showpoint << setprecision(4) << setw(7) << right
           << equalValueMatchWtd.zScore << endl;
   zscorev.close();

   ofstream zscoread("zASD.txt", ios::app);
   zscoread << fixed << showpoint << setprecision(4) << setw(7) << right
           << scaledFalloffWtd.zScore << endl;
   zscoread.close();


   return(o.str());
}
 
string PerfData::fullReportOld() const { 
 
   if (numTurns == 0) { return "No turns---nothing to see."; } 
 
   ostringstream o; 
   string adj = weighted ? "Wtd." : "Unwtd."; 
 
   //IMPT: "Test using" and "total turns" are searched for in demos. 
 
   o << "From " << numTurns << " total turns (" << fixed << setprecision(2) 
   << accumWeight << " weighted), it is consistent to expect\n" 
   << "the level of players sampled to have the following stats:\n\n" 
   << adj << "  first-move matches: " 
   << fixed << setprecision(2) << right 
   << setw(8) 
   << moveMatchWtd.projectedValue << ", stdev " << moveMatchWtd.projectedSigma << ", " 
   << setw(5) 
   << 100.0*moveMatchWtd.projectedFreq << "%" << endl 
   << "Two-sigma range: " 
   << setw(8) 
   << moveMatchWtd.projected2SigmaLeft << "--" << moveMatchWtd.projected2SigmaRight << ", " 
   << setw(5) 
   << 100*moveMatchWtd.projected2SigmaLeftFreq << "%--" << 100*moveMatchWtd.projected2SigmaRightFreq << "%"  
   << endl << endl 

   << adj << " eq.top-move matches: " 
   << setw(8) 
   << equalValueMatchWtd.projectedValue << ", stdev " << equalValueMatchWtd.projectedSigma << ", " 
   << setw(5) 
   << 100.0*equalValueMatchWtd.projectedFreq << "%" << endl 
   << "Two-sigma range: " 
   << setw(8) 
   << equalValueMatchWtd.projected2SigmaLeft << "--" << equalValueMatchWtd.projected2SigmaRight << ", " 
   << setw(5) 
   << (100.0*equalValueMatchWtd.projected2SigmaLeftFreq) << "%--" << (100.0*equalValueMatchWtd.projected2SigmaRightFreq) << "%" 
   << endl << endl 

   << adj << " played-move matches: " 
   << setw(8) 
   << playedMoveMatchWtd.projectedValue << ", stdev " << playedMoveMatchWtd.projectedSigma << ", " 
   << setw(5) << (100.0*playedMoveMatchWtd.projectedFreq) << "%" << endl 
   << "Two-sigma range: " 
   << setw(8) 
   << playedMoveMatchWtd.projected2SigmaLeft << "--" << playedMoveMatchWtd.projected2SigmaRight << ", " 
   << setw(5) 
   << (100.0*playedMoveMatchWtd.projected2SigmaLeftFreq) << "%--" << (100.0*playedMoveMatchWtd.projected2SigmaRightFreq) << "%"  
   << endl << endl;

 
 if (weighted) { 
   adj = "Unwtd."; 
   o << "From " << numTurns << " total turns (" << fixed << setprecision(2)
   << accumWeight << " weighted), it is consistent to expect\n"
   << "the level of players sampled to have the following stats:\n\n"
   << adj << "  first-move matches: "
   << fixed << setprecision(2) << right
   << setw(8)
   << moveMatch.projectedValue << ", stdev " << moveMatch.projectedSigma << ", "
   << setw(5)
   << 100.0*moveMatch.projectedFreq << "%" << endl
   << "Two-sigma range: "
   << setw(8)
   << moveMatch.projected2SigmaLeft << "--" << moveMatch.projected2SigmaRight << ", "
   << setw(5)
   << 100*moveMatch.projected2SigmaLeftFreq << "%--" << 100*moveMatch.projected2SigmaRightFreq << "%"
   << endl << endl

   << adj << " eq.top-move matches: "
   << setw(8)
   << equalValueMatch.projectedValue << ", stdev " << equalValueMatch.projectedSigma << ", "
   << setw(5)
   << 100.0*equalValueMatch.projectedFreq << "%" << endl
   << "Two-sigma range: "
   << setw(8)
   << equalValueMatch.projected2SigmaLeft << "--" << equalValueMatch.projected2SigmaRight << ", "
   << setw(5)
   << (100.0*equalValueMatch.projected2SigmaLeftFreq) << "%--" << (100.0*equalValueMatch.projected2SigmaRightFreq) << "%"
   << endl << endl

   << adj << " played-move matches: "
   << setw(8)
   << playedMoveMatch.projectedValue << ", stdev " << playedMoveMatch.projectedSigma << ", "
   << setw(5) << (100.0*playedMoveMatch.projectedFreq) << "%" << endl
   << "Two-sigma range: "
   << setw(8)
   << playedMoveMatch.projected2SigmaLeft << "--" << playedMoveMatch.projected2SigmaRight << ", "
   << setw(5)
   << (100.0*playedMoveMatch.projected2SigmaLeftFreq) << "%--" << (100.0*playedMoveMatch.projected2SigmaRightFreq) << "%"
   << endl << endl;

 } //end of parenthetical if (weighted) 
 
   o << endl << "Predicted Unweighted and Weighted"  
          << " played-move index freqs; wtd. 2-sigma range:" << endl; 
   for (int i = 0; i <= IRutil::NCUTOFF; i++) { 
      double expi = moveIndexTests.at(i).projectedValue; // predMoveIndices.at(i); 
      double expiw = moveIndexTestsWtd.at(i).projectedValue; //predMoveIndicesWtd.at(i); 
      double sigi = moveIndexTests.at(i).projectedSigma;  //sqrt(predMoveVariances.at(i)); 
      double sigiw = moveIndexTestsWtd.at(i).projectedSigma;  //sqrt(predMoveVariancesWtd.at(i)); 
      o << setw(2) << right << i << ":" << fixed << setprecision(2) 
             << setw(9) << right << expi << ", " 
	     << setw(5) << right << 100.0*expi/numTurns << "%;" 
             << setw(9) << right << expiw << ", " 
             << setw(5) << right << 100.0*expiw/accumWeight << "%; " 
	     << "2sr:" 
	     << setw(9) << right << expiw-2*sigiw << "--" 
             << setw(9) << left << expiw+2*sigiw << ", " 
             << setw(5) << right << 100.0*(expiw-2*sigiw)/accumWeight 
             << "%--" << setw(5) << right << 100.0*(expiw+2*sigiw)/accumWeight 
             << "%" << endl; 
   } 
   o << "(Last line covers all moves not in the top N.)" << endl; 
 
   o << endl << "Histogram of indexes of played moves, " 
          << "capping blunder deltas at " << deltaCap << ":" << endl; 
   for (int i = 0; i <= IRutil::NCUTOFF; i++) { 
      o << setw(3) << right << i << ": " << fixed << setprecision(2) 
             << setw(5) << right << moveIndexTests.at(i).measuredValue  //playedMoveIndexHistogram.at(i)
             << ", " << setw(5) << right 
             << 100.0*moveIndexTests.at(i).measuredFreq  //playedMoveIndexHistogram.at(i)/numTurns
             << "%,  wtd. " << setw(8) << right 
             << moveIndexTestsWtd.at(i).measuredValue  //playedMoveIndexHistogramWtd.at(i) 
             << ", " << setw(5) << right 
             << 100*moveIndexTestsWtd.at(i).measuredFreq  //playedMoveIndexHistogramWtd.at(i) / accumWeight 
             << "%;  wtd. mean delta = " << setw(5) << right 
             << moveIndexTestsWtd.at(i).meanDelta   
             << endl; 
   } 
   o << "Index fits, x10,000: " 
          << setprecision(4) << 10000.0*indexFit << ", wtd. "  
          << 10000.0*indexFitWtd << "; mass " << 10000.0*indexFitMass 
          << ", wtd. " << 10000.0*indexFitMassWtd << endl << endl 
          << setprecision(2) 
          << "Number of first-line matches: " 
          << moveIndexTests.at(0).measuredValue   //playedMoveIndexHistogram.at(0)
          << ", " << (100.0*moveIndexTests.at(0).measuredFreq)  //playedMoveIndexHistogram.at(0)/numTurns) 
          << "%; wtd. " << moveIndexTestsWtd.at(0).measuredValue //    playedMoveIndexHistogramWtd.at(0) 
          << ", " << (100.0*moveIndexTestsWtd.at(0).measuredFreq) //playedMoveIndexHistogramWtd.at(0)/accumWeight) 
          << "%" << endl 
          << "Number of equal-top matches:  " << equalValueMatch.measuredValue //topMatches 
          << ", " << (100.0*equalValueMatch.measuredFreq)  //topFreq) 
          << "%" << "; wtd. " << equalValueMatchWtd.measuredValue  //topMatchesWtd 
          << ", " << (100.0*equalValueMatchWtd.measuredFreq)   //topFreqWtd) 
          << "%" << endl;

   o << endl << "Selection Tests" << endl << SelectionTest::header() << endl;
   vector<SelectionTest>::const_iterator vsti = selectionTestsWtd.begin();
   vector<SelectionTest>::const_iterator vste = selectionTestsWtd.end();
   while (vsti != vste) {
      o << string(*vsti++) << endl;
   }
 
   o << endl << "Finally, expected and actual falloff, " 
      << "with blunder cap as set at " << deltaCap << ":" << endl 
      << setprecision(2) << setw(8) << right 
      << "Expected scaled weighted:   " << setw(8) << scaledFalloffWtd.projectedValue  
      << ", 2-sigma range: " << scaledFalloffWtd.projected2SigmaLeft 
      << "--"  << scaledFalloffWtd.projected2SigmaRight << endl 
      << "Actual scaled weighted:     " << setw(8) << scaledFalloffWtd.measuredValue << endl 
      << "Expected unscaled weighted: " << setw(8) << unscaledFalloffWtd.projectedValue 
      << ", 2-sigma range: " << unscaledFalloffWtd.projected2SigmaLeft << "--" 
      << unscaledFalloffWtd.projected2SigmaRight << endl 
      << "Actual unscaled weighted:   " << setw(8) << unscaledFalloffWtd.measuredValue << endl 
      << "Per-move figures:" << endl 
      << setprecision(4) << setw(5) << right 
      << "Expected scaled weighted:    " << scaledFalloffWtd.projectedFreq  
      << ",   2-sigma range: " << scaledFalloffWtd.projected2SigmaLeftFreq << "--" 
      << scaledFalloffWtd.projected2SigmaRightFreq << endl 
      << "Actual scaled weighted:       " << scaledFalloffWtd.measuredFreq << endl 
      << "Expected unscaled weighted:  " << unscaledFalloffWtd.projectedFreq  
      << ",   2-sigma range: " << unscaledFalloffWtd.projected2SigmaLeftFreq << "--" 
      << unscaledFalloffWtd.projected2SigmaRightFreq << endl 
      << "Actual unscaled weighted:     " << unscaledFalloffWtd.measuredFreq << endl 
      << endl 
 
      << "Unweighted versions:" << endl 
      << setprecision(2) << setw(8) << right 
      << "Expected scaled:   " << setw(8) << scaledFalloff.projectedValue << ", " 
      << "2-sigma range: " << scaledFalloff.projected2SigmaLeft << "--" 
      << scaledFalloff.projected2SigmaRight << endl 
      << "Actual scaled:     " << setw(8) << scaledFalloffWtd.measuredValue << endl 
      << "Expected unscaled: " << setw(8) << unscaledFalloff.projectedValue << ", " 
      << "2-sigma range: " << unscaledFalloff.projected2SigmaLeft << "--" 
      << unscaledFalloff.projected2SigmaRight << endl 
      << "Actual unscaled:   " << setw(8) << unscaledFalloff.measuredValue << endl 
      << "Per-move figures:" << endl 
      << setprecision(4) << setw(5) << right 
      << "Expected scaled:    " << scaledFalloff.projectedFreq << ",   " 
      << "2-sigma range: " << scaledFalloff.projected2SigmaLeftFreq << "--" 
      << scaledFalloff.projected2SigmaRightFreq << endl 
      << "Actual scaled:      " << scaledFalloff.measuredFreq << endl 
      << "Expected unscaled:  " << unscaledFalloff.projectedFreq << ",   " 
      << "2-sigma range: " << unscaledFalloff.projected2SigmaLeftFreq << "--" 
      << unscaledFalloff.projected2SigmaRightFreq << endl 
      << "Actual unscaled:    " << unscaledFalloff.measuredFreq << endl 
      << endl 
 
      << "------" << endl 
      << setprecision(2) << setw(8) 
      << "Actual capped unweighted:   " << unscaledFalloff.measuredValue << ", " 
      << setprecision(4) << setw(5) 
      << (unscaledFalloff.measuredFreq) << " per move;" << endl 
      << setprecision(2) << setw(8) 
      << "Figured by next turns:      " << scaledFalloffNextTurnCapped.measuredValue << ", " 
      << setprecision(4) << setw(5) 
      << (scaledFalloffNextTurnCapped.measuredFreq) << " per move;" << endl << endl; 
 
   double zscoreFirst = moveMatch.zScore;
   double zscoreTop = equalValueMatch.zScore;
   //double zscoreSelection = (selectionMatches - predSelectionMatches)/selectionSigma;
   double zscoreFalloff = unscaledFalloff.zScore;
   double zscoreScaledFalloff = scaledFalloff.zScore;

   double zscoreFirstWtd = moveMatchWtd.zScore;
   double zscoreTopWtd = equalValueMatchWtd.zScore;
   //double zscoreSelectionWtd = (selectionMatchesWtd - predSelectionMatchesWtd)/selectionSigmaWtd;
   double zscoreFalloffWtd = unscaledFalloffWtd.zScore;
   double zscoreScaledFalloffWtd = scaledFalloffWtd.zScore;

 
 
   o << endl 
      << "Matching Z-scores: firstMM = " << zscoreFirst  
      << ", topMM  = " << zscoreTop << endl  //", selection = " << zscoreSelection << endl 
      << "Falloff Z-scores: unscaled = " << zscoreFalloff 
      << ", scaled = " << zscoreScaledFalloff << endl; 
 
   o //<< endl 
      << "Matching Z-scores weighted: firstMM = " << zscoreFirstWtd 
      << ", topMM  = " << zscoreTopWtd << endl   //", selection = " << zscoreSelectionWtd << endl 
      << "Falloff Z-scores weighted: unscaled = " << zscoreFalloffWtd 
      << ", scaled = " << zscoreScaledFalloffWtd << endl; 
 
   ofstream zscoref("zMM.txt", ios::app); 
   zscoref << fixed << showpoint << setprecision(4) << setw(7) << right 
           << zscoreFirst << endl; 
   zscoref.close(); 

   ofstream zscorev("zEV.txt", ios::app);
   zscorev << fixed << showpoint << setprecision(4) << setw(7) << right
           << zscoreTop << endl;
   zscorev.close();
 
   ofstream zscoread("zASD.txt", ios::app); 
   zscoread << fixed << showpoint << setprecision(4) << setw(7) << right 
           << -zscoreScaledFalloff << endl; 
   zscoread.close(); 
 
 
       
 
   o << endl; 
 
   return o.str(); 
}                
 
#endif    //end of #ifndef __IR_PERFDATA_CPP__ 
 
 
 
//File----------------------Shuffle.h------------------------------------- 
 
#ifndef __IR_SHUFFLE_H__
#define __IR_SHUFFLE_H__
#endif

enum SHUFFLES { 
   NO_SHUFFLE, 
   SWAP_FIRST_TWO, 
   FLIP, 
   SWAP_HALVES, 
   CYCLE_LEFT, 
   CYCLE_RIGHT, 
   CYCLE_BY_TURN_NO, 
   CYCLE_FLIP_TURN_NO, 
   NUM_TWEAKS, 
   APPLY_ALL_TURNS, 
   APPLY_ODD_TURNS, 
   APPLY_EVEN_TURNS, 
   APPLY_IF_RANDOM, 
   APPLY_RANDOM_TWEAK, 
   FULLY_RANDOMIZE, 
   NUM_SHUFFLES 
}; 
 
/** Abstract class representing a permutation of the list of moves 
    returned by the engine---more precisely, of /the way that list is read/ 
    during percentile-fitting in particular. 
    N stands for NCUTOFF (== 10 or 20), NN for N+1. 
 
    Design philosophy: Each class (not object) fixes a pre-computed list PP  
    of permutations to use for each possible tuple length 1..N or 1..NN.   
    The abstract base class constructs PP as identity permutations, then 
    derived classes modify them---the redundant computation does not affect 
    the main loop.   
 */ 
class Shuffle : public Catalogable { 
 protected: 
   vector<vector<int>* >* permutations; //one perm for each tuple length 1..NN 
   vector<int>* permNNFixed;  //to use when fixing element NN regardless. 
 private: 
  // int fixDistortion; //if <= 0, permutations go to N only 
   bool includeMoveNN; //can decide 'no' even if fixDistortion is true 
   string name; 
   int tupleNumber; 
   bool adaptsToTurn;  //false => same permutation for all turns, so we need 
                       //only return a pointer to a pre-computed permutation 
    
  /** Return a permutation indexing the probability array that will be  
      derived from the turn's delta array, 1 larger if includeMoveNN. 
      If (adaptsToTurn), then the permutation to return is pre-computed, 
      else we may assume that the permutation is initially the identity. 
 
      Private so that the public method guarantees incrementing tupleNumber. 
      CSE703: Is there a better way to represent this kind of *behavioral* 
      property, a-la my proposal for *static* properties in the type system? 
   */ 
  // virtual vector<int>* makePerm(const TurnInfo* const pTurn) const = 0; 
 
 public: 
   Shuffle(const string& gname, bool imNN, bool a)  
      : name(gname), includeMoveNN(imNN), tupleNumber(0), adaptsToTurn(a), 
        permutations(new vector<vector<int>* >(IRutil::MAXNUMLEGALMOVES)), 
	permNNFixed(new vector<int>(IRutil::MAXNUMLEGALMOVES)) { 
      for (int i = 0; i < IRutil::NCUTOFF + 1; i++) { 
         permutations->at(i) = new vector<int>(i); 
         for (int j = 0; j < i; j++) { 
             permutations->at(i)->at(j) = j; 
         } 
         permNNFixed->at(i) = i; 
      } 
   } 
   virtual ~Shuffle() {
      for (int i = 0; i < IRutil::NCUTOFF + 1; i++) {
         delete(permutations->at(i));
      }
      delete(permutations);
      delete(permNNFixed);
   } 
 
   /** Return a permutation indexing the probability array that will be  
       derived from the turn's delta array.  Static binding, do not shadow! 
    */ 
   //vector<int>* makePermutation(const TurnInfo* const pTurn ) { 
   //   tupleNumber++;  //so we index tuples from 1 not 0 
   //   return makePerm(turn); 
   //} 
   int numProbs(const TurnInfo* const pTurn) { 
	   int s = pTurn->depthEvalsCP->size(); 
      if (s == IRutil::NCUTOFF && includeMoveNN) { s++; } 
      return s; 
   } 
   int getTupleNumber() { return tupleNumber; } 
   void resetTupleNumber() { tupleNumber = 0; } 
   void incTupleNumber() { tupleNumber++; } 
   bool includesMoveNN() { return includeMoveNN; } 
   string getName() const { return name; } 
   virtual string getDescription() const = 0; 
   virtual operator string() const { 
      return getName() + ": " + getDescription(); 
   } 
}; 
 
//class IdentityPerm : public Shuffle { 
// public: 
//   IdentityPerm(bool imNN) : Shuffle("Id", imNN, false) { } 
//   virtual vector<int>* makePerm(const TurnInfo* turn const) const { 
//      return permutations 
//    
// 
//class ApplyOddTurns : public Shuffle { 
//   Shuffle* shuffle; 
//   virtual vector<int>* makePerm(const TurnInfo* turn const) const { 
//      if (getTupleNumber() % 2) { 
//         return  
// public: 
//   ApplyOddTurns 
//    
// 
// 
//   /** Permutation generator, used by translateTurn 
//       Assumes arr has correct size, but does not assume it's initialized. 
//    */ 
//   void makePermutation(vector<int>* arr, const TurnInfo* const pTurn) const { 
//      static int tnum; 
//      tnum++; 
//      int psize = arr->size(); 
//      int start; 
//      int permEnd = psize; 
//      int huffle = shuffle; 
//      if (psize == 1 + IRutil::NCUTOFF && (!includeMoveNN)) { 
//         permEnd--; 
//         arr->at(permEnd) = permEnd; 
//      } 
//      switch(when) { 
//       case APPLY_ALL_TURNS: 
//         break; 
//       case APPLY_ODD_TURNS: 
//         if (tnum % 2 == 0) { return; } 
//         break; 
//       case APPLY_EVEN_TURNS: 
//         if (tnum % 2 == 1) { return; } 
//         break; 
//       case APPLY_IF_RANDOM: 
//         srand(pTurn->srandSeed); 
//         if (IRutil::myRand(0,2) % 2 == 0) { return; } 
//         break; 
//       case APPLY_RANDOM_TWEAK: 
//         srand(pTurn->srandSeed); 
//         huffle = IRutil::myRand(0,NUM_TWEAKS); 
//         break; 
//       case FULLY_RANDOMIZE: 
//         srand(pTurn->srandSeed); 
//         IRutil::randShuffle(arr, 0, permEnd); 
//         return;  //nothing more to do 
//       default: 
//         break; 
//      } 
//      switch(huffle) { 
//       case NO_SHUFFLE: 
//         for (int i = 0; i < permEnd; i++) { 
//            arr->at(i) = i; 
//         } 
//         break; 
//       case SWAP_FIRST_TWO: 
//         if (permEnd >= 2) { 
//            arr->at(0) = 1; 
//            arr->at(1) = 0; 
//         } 
//         for (int i = 2; i < permEnd; i++) { 
//            arr->at(i) = i; 
//         } 
//         break; 
//       case FLIP: 
//         for (int i = 0; i < permEnd; i++) { 
//            arr->at(i) = psize - i - 1; 
//         } 
//         break; 
//       case SWAP_HALVES: 
//         start = (permEnd + 1) / 2;  // = 6 when permEnd = 11 
//         for (int i = 0; i < permEnd; i++) { 
//            arr->at(i) = (i + start) % permEnd; 
//         } 
//         break; 
//       case CYCLE_LEFT: 
//         for (int i = 0; i < permEnd - 1; i++) { 
//            arr->at(i) = i + 1; 
//         } 
//         arr->at(permEnd - 1) = 0; 
//         break; 
//       case CYCLE_RIGHT: 
//         arr->at(0) = permEnd - 1; 
//         for (int i = 1; i < permEnd; i++) { 
//            arr->at(i) = i - 1; 
//         } 
//         break; 
//       case CYCLE_BY_TURN_NO: 
//         for (int i = 0; i < permEnd; i++) { 
//            arr->at(i) = (i + pTurn->turnNumber) % permEnd; 
//         } 
//         break; 
//       case CYCLE_FLIP_TURN_NO: 
//         for (int i = 0; i < permEnd; i++) { 
//            arr->at(i) = (pTurn->turnNumber % 2 == 0) ? i : permEnd - i - 1; 
//         } 
//         for (int i = 0; i < permEnd; i ++) { 
//            arr->at(i) = (arr->at(i) + (pTurn->turnNumber / 2)) % permEnd; 
//         } 
//         break; 
//       default:  //do nothing 
//         break; 
//      } 
//   } 
// 
 
 
 
 
//File----------------------Trial.h--------------------------------------- 
 
#ifndef __IR_TRIAL_H__ 
#define __IR_TRIAL_H__ 


#ifndef __IR_INCLUDES_H__
#include "IRincludes.h"
#endif

#ifndef __IR_UTIL_H__ 
#include "IRutil.h" 
#endif                      //end of #ifndef __IR_UTIL_H__ 
 
#ifndef __IR_FUNCTIONS_H__ 
#include "IRfunctions.h" 
#endif                      //end of #ifndef __IR_FUNCTIONS_H__ 
 
#ifndef __IR_MISC_GLOBAL_H__ 
#include "IRmiscGlobal.h" 
#endif	 //end of #ifndef __IR_MISC_GLOBAL_H__ 
 
#ifndef __IR_POSITION_H__
#include "Position.h"
#endif

#ifndef __IR_GAME_INFO_H__
#include "GameInfo.h"
#endif

#ifndef __IR_TRIAL_SPEC_H__ 
#include "TrialSpec.h" 
#endif	  //end of #ifndef __IR_TRIAL_SPEC_H__ 
 
#ifndef __IR_TURN_INFO_H__ 
#include "TurnInfo.h" 
#endif	  //end of #ifndef __IR_TURN_INFO_H__ 
 
#ifndef __IR_TUPLE_INFO_H__
#include "TupleInfo.h"
#endif 

#ifndef __IR_TURN_CONTEXT_H__
#include "TurnContext.h"
#endif

#ifndef __IR_FILTERS_H__ 
#include "Filters.h" 
#endif	  //end of #ifndef __IR_FILTERS_H__ 

#ifndef __IR_DELTA_SCALES_H__
#include "DeltaScales.h"
#endif    //end of #ifndef __IR_DELTA_SCALES_H__

 
#ifndef __IR_PERFDATA_H__ 
#include "PerfData.h" 
#endif	 //end of #ifndef __IR_PERFDATA_H__ 
 
#ifndef __IR_SHUFFLE_H__
#include "Shuffle.h"
#endif

#ifndef __IR_DECISION_INFO_H__
#include "DecisionInfo.h"
#endif
 
#ifndef __IR_MODELS_H__
#include "IRmodels.h"
#endif

#ifndef __IR_MOVESELECTION_H__
#include "MoveSelector.h"
#endif

#ifndef __IR_TRIAL_H__ 
#include "Trial.h" 
#endif	  //end of #ifndef __IR_TRIAL_H__ 
 
 
//----------------------STATISTICAL TRIALS----------------------------- 
 

 
/** Trial class works with a List<TurnInfo*>, and filters it into 
    a List<TupleInfo*>, on which statistical runs are performed. 
 */ 
 
class Trial : public Catalogable { 
   string name; 
   vector<vector<int> >* evalSwap;   //should be large enough for any turn.

   TrialSpec theSpec;                       //IMPT: own copy, settable here. 
   Models::MODEL model; 
   bool usePerceivedEvals;    //temp kludge: will allow setting from fit menu

   list<TurnInfo*>* pTurns;   //must be alias of Ensemble's turns
   list<TurnFilter*> filters; 
   MoveSelector* theSelector;
   vector<MoveSelector*>* theSelectors;
   bool scaleDeltas;
   DeltaScale* theScale;
   //Filters and scale determine next items
   vector<DecisionInfo*>* theDecisions;   //all use lo..hi from theScale
   vector<string> filteredGameIDs;
   //theSpec also determines:
   vector<double> poissonWeights;   //INV: has bounds 0..hi-z from theScale
   vector<double>* pwv;             //dilates Poisson weights according to v,d
                                    //and has bounds 0..hi-lo instead (IMPT)
   vector<double>* swv;             //Swing vector, bounds 0..userSwingHigh-userSwingLow
   bool fixDistortion; 
   bool treatMissAsMoveNN; 
   const SHUFFLES shuffle; 
   const SHUFFLES when; 
   const bool includeMoveNN; 
   const bool isReferenceTrial;
    
   IRfun::Dist dist; 
 
   //---------Private Methods----------------------------------------- 
 
   Trial(const Trial& arg);              //disabled copy constructor 
   Trial& operator=(const Trial& arg);   //disabled assignment 

   void setUPV(bool policy) { usePerceivedEvals = policy; }
 
   static bool deleteTurn(TurnInfo* const& tp) { delete(tp); return true; } 
   //void deleteAllTurns() { pTurns->remove_if(deleteTurn); } 
   void deleteAllTurns() {
      list<TurnInfo*>::iterator it = pTurns->begin();
      list<TurnInfo*>::iterator ite = pTurns->end();
      while (it != ite) {
         TurnInfo* tp = *it++;
         delete(tp);
      }
   }
      
 
   /** Modifies whichV, which is either the "pwv" or "swv" field above.
       REQ: whichV has /already/ been initialized and has size numWeights.
       This enables whichV to be accumulated in successive calls weighted
       by factor.  The accumulated sum is NOT multiplied by "factor"---so
       only the last value in a succession of calls should be tested versus 1.
    */
   double makeSum(size_t g, size_t relDepth, size_t numWeights, 
                  const vector<double>& accWts,
                  vector<double>* whichV, const double factor) {   
      double sum = 0.0;
      double prev = 0.0;
      double next;
      size_t i;
      //double relDepth = theSpec.d - theScale->getLowDepth() + 1;
      //size_t g = size_t(theSpec.d + 0.5);  //rounds
      size_t g0 = size_t(relDepth);
      size_t g1 = g0 + 1;
      double r1 = relDepth - g0;
      double r0 = 1.0 - r1;

      if (theSpec.v > 1.0/IRutil::CVTOLERANCE) {  //treat v as inf
         g = min(g, numWeights-1);
         g1 = min(g1, numWeights-1);  //upper bound is >= 0
         g0 = (g1 == 0 ? 0 : g1 - 1);
         whichV->at(g0) += factor*r0;
         if (g1 != g0) {
            whichV->at(g1) += factor*r1;
         }
         sum += 1.0;
      } else if (g >= numWeights) {  //ignore d in spec
         for (i = 0; i < numWeights; i++) {
            next = numWeights*pow(IRutil::divifgt0((i+1.0),numWeights), theSpec.v);
                                  //IRutil::divifgt0(1.0,theSpec.v));
            whichV->at(i) += factor*IRutil::fracsum(accWts,prev,next);
            prev = next;
            sum += whichV->at(i);  //relevant only in last of series of calls
         }
      } else {
         for (i = 0; i < g; i++) {
            next = (relDepth)*pow(IRutil::divifgt0((i+1.0), relDepth), theSpec.v);
                                  //IRutil::divifgt0(1.0, theSpec.v));
            whichV->at(i) += factor*IRutil::fracsum(accWts,prev,next);
            prev = next;
            sum += whichV->at(i);
         }
         next = pow(IRutil::divifgt0((numWeights - (g + 1.0)), (numWeights - relDepth)),
                    theSpec.v);
                    //IRutil::divifgt0(1.0,theSpec.v));
         next = numWeights - next*(numWeights - relDepth);
         whichV->at(g) += factor*IRutil::fracsum(accWts,prev,next);
         prev = next;
         sum += whichV->at(g);
         for (i = g+1; i < numWeights; i++) {
            next = pow(IRutil::divifgt0((numWeights - (i + 1.0)),(numWeights - relDepth)),
                       theSpec.v);
                       //IRutil::divifgt0(1.0,theSpec.v));
            next = numWeights - next*(numWeights - relDepth);
            whichV->at(i) += factor*IRutil::fracsum(accWts,prev,next);
            prev = next;
            sum += whichV->at(i);
         }
      }
      return sum;
   }

   void makeLWs(double dpeak, double slope, size_t numWeights, //caller ensures slope > 0
                  vector<double>* whichV, const double factor) {
      bool normalize = false;
      int m = numWeights - 1;  //indexed 0 .. m 
      size_t e = (slope < IRutil::CVTOLERANCE ? 0 
                  : max(0, int(1.0 - IRutil::MINGTZERO + dpeak - 1.0/slope)));
      size_t f = (slope < IRutil::CVTOLERANCE ? m : min(m, int(dpeak + 1.0/slope)));
      size_t b = size_t(dpeak);
      if (b > m) {
         normalize = true;
         b = m;
         if (e > b) { e = b; }
      }
      double sum = f - e + 1.0 + slope*dpeak*(f - 2.0*b + e - 1.0)
                     + slope*(b*(b + 1.0) - 0.5*(e*(e - 1.0) + f*(f + 1.0)));
      size_t i;
      if (whichV->size() == 1) {
         whichV->at(0) += 1.0;
         return;
      } //else
      for (i = e; i <= b; i++) {
         whichV->at(i) += (1.0 - slope*(dpeak - i))*factor/sum;
      }
      for (i = b+1; i <= f; i++) {
         whichV->at(i) += (1.0 - slope*(i - dpeak))*factor/sum;
      }
      if (normalize) { IRutil::normalizeP(whichV); }
   }



   void setLWs() {   //sets up linear weights for pwv and swv vectors.
      //size_t numLWs = 1 + theScale->getHighDepth() - theScale->getZeroDepth();
      size_t numLWs = 1 + theScale->getHighDepth() - theScale->getLowDepth();
      size_t numSWs = 1 + theScale->getSwingHigh() - theScale->getSwingLow();

      if (pwv) { delete(pwv); }
      if (swv) { delete(swv); }

      pwv = new vector<double>(numLWs, 0.0);
      double relZDepth = max(0.0, theSpec.d - theScale->getZeroDepth());
      makeLWs(relZDepth, theSpec.v, numLWs, pwv, 1.0);
      if (numSWs < 0.5) {
         swv = new vector<double>();
         return;
      } //else
      swv = new vector<double>(numSWs, 0.0);
      double relDepth = max(0.0, theSpec.d - theScale->getSwingLow());
      makeLWs(relDepth, theSpec.v, numSWs, swv, 1.0);
   }


   void setPWs() {   //must be called after any change to spec d or v

      size_t numPWs = 1 + theScale->getHighDepth() - theScale->getZeroDepth();
      poissonWeights.resize(numPWs);
      double relZDepth = max(0.0, theSpec.d - theScale->getZeroDepth());
      IRutil::genPoissonWeights(relZDepth, numPWs, poissonWeights);

      double sum = 0.0;
      for (size_t i = 0; i < numPWs; i++) {
         sum += poissonWeights.at(i);
      }
      if (fabs(1.0 - sum) > IRutil::SUMPROBSTOLERANCE) {
         cerr << "Bad normalization in poissonWeights vector: sum = " << sum << endl;
         //IRutil::normalize(poissonWeights);
      }

      size_t numWeights = 1 + theScale->getHighDepth() - theScale->getLowDepth();

      vector<double> accWts(numWeights,0.0);
      size_t ii = 0;
      size_t diff = numPWs - numWeights;
      for (ii = 0; ii < diff; ii++) { accWts.at(0) += poissonWeights.at(ii); }
      for (ii = diff; ii < numPWs; ii++) {
         accWts.at(ii - diff) += poissonWeights.at(ii);
      }

/*
cerr << "AccWts: ";
for (int z = 0; z < accWts.size(); z++) {
   cerr << z << "-" << IRutil::ftoa(accWts.at(z), 3) << " ";
}
cerr << endl;
*/

      //pwv->clear();
      //pwv->resize(numWeights,0.0);
      delete(pwv);
      pwv = new vector<double>(numWeights,0.0);
      double relDepth = max(0.0, theSpec.d - theScale->getLowDepth() + 1);
      size_t g0 = size_t(relDepth);
      size_t g1 = g0 + 1;
      double r1 = relDepth - g0;
      double r0 = 1.0 - r1;

      sum = makeSum(g0,relDepth,numWeights,accWts,pwv,r0);  //result discarded
      sum = makeSum(g1,relDepth,numWeights,accWts,pwv,r1);

      //cerr << "First sum: " << sum << endl;
      sum = 0.0;

//cerr << "PWV: " << strPWV() << endl;

      for (int k = 0; k < pwv->size(); k++) {
         sum += pwv->at(k);
         //cerr << k << "-" << IRutil::round(sum,3) << " ";
      }
      //cerr << endl;

      if (fabs(1.0 - sum) > IRutil::SUMPROBSTOLERANCE) {
         cerr << "Bad normalization in PWV vector: sum = " << sum << endl;
         cerr << string(theSpec) << endl;
         for (int m = 0; m < pwv->size(); m++) {
            cerr << m << "-" << IRutil::round(pwv->at(m),4) << " ";
         }
         cerr << endl;
         IRutil::normalizeP(pwv);
      }

      size_t numSWs = 1 + theScale->getSwingHigh() - theScale->getSwingLow();
      relDepth = max(0.0, theSpec.d - theScale->getSwingLow());
      if (numSWs < 0.5) { 
         delete(swv);
         swv = new vector<double>();
         return; 
      }  //else
       
      //poissonWeights.resize(numSWs);
      vector<double> poissonWeights2(numSWs,0.0);
//cerr << "PW2: ";
      IRutil::genPoissonWeights(relDepth, numSWs, poissonWeights2);

      sum = 0.0;
      for (size_t i = 0; i < numSWs; i++) {
         sum += poissonWeights2.at(i);
      }
      if (fabs(1.0 - sum) > IRutil::SUMPROBSTOLERANCE) {
         cerr << "Bad normalization in PW vector for SW: sum = " << sum << endl;
      }  //no need to differentiate accWts and poissonWeights now

      //swv->clear();
      //swv->resize(numSWs,0.0);
      delete(swv);
      swv = new vector<double>(numSWs,0.0);

      g0 = size_t(relDepth);
      g1 = g0 + 1;
      r1 = relDepth - g0;
      r0 = 1.0 - r1;

    
      sum = makeSum(g0,relDepth,numSWs,poissonWeights2,swv,r0);
      sum = makeSum(g1,relDepth,numSWs,poissonWeights2,swv,r1);

//cerr << "SWV: " << strSWV() << endl;

      if (fabs(1.0 - sum) > IRutil::SUMPROBSTOLERANCE) {
         cerr << "Bad normalization in SWV vector: sum = " << sum << endl;
         cerr << string(theSpec) << endl;
         IRutil::normalizeP(swv);
      }
      //delete(poissonWeights2);
   }
 
   bool filterOne(TurnInfo* turn) const { 
      for (list<TurnFilter*>::const_iterator it = filters.begin(); 
           it != filters.end(); it++) { 
         if (!(*it)->apply(turn)) { return false; } 
      } 
      return true; 
   } 
 
   /** Permutation generator, used by translateTurn 
       Assumes arr has correct size, but does not assume it's initialized. 
    */ 
   void makePermutation(vector<int>* arr, const TurnInfo* const pTurn) const { 
      static int tnum; 
      tnum++; 
      int psize = arr->size(); 
      int start; 
      int permEnd = psize; 
      int huffle = shuffle; 
      if (psize == 1 + IRutil::NCUTOFF && (!includeMoveNN)) { 
         permEnd--; 
         arr->at(permEnd) = permEnd; 
      } 
      switch(when) { 
       case APPLY_ALL_TURNS: 
         break; 
       case APPLY_ODD_TURNS: 
         if (tnum % 2 == 0) { return; } 
         break; 
       case APPLY_EVEN_TURNS: 
         if (tnum % 2 == 1) { return; } 
         break; 
       case APPLY_IF_RANDOM: 
         srand(pTurn->srandSeed); 
         if (IRutil::myRand(0,2) % 2 == 0) { return; } 
         break; 
       case APPLY_RANDOM_TWEAK: 
         srand(pTurn->srandSeed); 
         huffle = IRutil::myRand(0,NUM_TWEAKS); 
         break; 
       case FULLY_RANDOMIZE: 
         srand(pTurn->srandSeed); 
         IRutil::randShuffle(arr, 0, permEnd); 
         return;  //nothing more to do 
       default: 
         break; 
      } 
      switch(huffle) { 
       case NO_SHUFFLE: 
         for (int i = 0; i < permEnd; i++) { 
            arr->at(i) = i; 
         } 
         break; 
       case SWAP_FIRST_TWO: 
         if (permEnd >= 2) { 
            arr->at(0) = 1; 
            arr->at(1) = 0; 
         } 
         for (int i = 2; i < permEnd; i++) { 
            arr->at(i) = i; 
         } 
         break; 
       case FLIP: 
         for (int i = 0; i < permEnd; i++) { 
            arr->at(i) = psize - i - 1; 
         } 
         break; 
       case SWAP_HALVES: 
         start = (permEnd + 1) / 2;  // = 6 when permEnd = 11 
         for (int i = 0; i < permEnd; i++) { 
            arr->at(i) = (i + start) % permEnd; 
         } 
         break; 
       case CYCLE_LEFT: 
         for (int i = 0; i < permEnd - 1; i++) { 
            arr->at(i) = i + 1; 
         } 
         arr->at(permEnd - 1) = 0; 
         break; 
       case CYCLE_RIGHT: 
         arr->at(0) = permEnd - 1; 
         for (int i = 1; i < permEnd; i++) { 
            arr->at(i) = i - 1; 
         } 
         break; 
       case CYCLE_BY_TURN_NO: 
         for (int i = 0; i < permEnd; i++) { 
            arr->at(i) = (i + pTurn->turnNumber) % permEnd; 
         } 
         break; 
       case CYCLE_FLIP_TURN_NO: 
         for (int i = 0; i < permEnd; i++) { 
            arr->at(i) = (pTurn->turnNumber % 2 == 0) ? i : permEnd - i - 1; 
         } 
         for (int i = 0; i < permEnd; i ++) { 
            arr->at(i) = (arr->at(i) + (pTurn->turnNumber / 2)) % permEnd; 
         } 
         break; 
       default:  //do nothing 
         break; 
      } 
   } 
 
 public: 
   Trial(const string& gname, list<TurnInfo*>* gturns, TrialSpec spec, 
         Models::MODEL gmodel = Models::POWER_SHARES, bool fd = false, 
         bool adjustDeltas = false, 
         DeltaScale* ds = new UnitScale(false,
            new SwingInfo(map<APPLICATION_POLICIES, double>(), true, false, true,
                          false, false, 0, false, false, 0.0),
            NO_PATCH, IRutil::CENTRALPATCHPOWER, 0.00, map<string,double>(), 
            1, 30, 30, 6, 20, 0, IRutil::DELTACAP),
                                        //!!! todo: elim defaults on these params
         bool tmamNN = true,  
         SHUFFLES gshuffle = NO_SHUFFLE, SHUFFLES gwhen = APPLY_ALL_TURNS, 
         bool imNN = true, bool isRefTrial = false) 
      : theDecisions(new vector<DecisionInfo*>()), 
        filteredGameIDs(vector<string>()), theSpec(spec), 
        evalSwap(new vector<vector<int> >(IRutil::MAXDEPTH,
                 vector<int>(IRutil::MAXNUMLEGALMOVES,0))),
        model(gmodel), usePerceivedEvals(false),
        fixDistortion(fd), 
        dist(IRfun::leastSquares), 
        pTurns(gturns), filters(list<TurnFilter*>(0)),
        theSelector(new EqualTopMoveSelector()),
        theSelectors(new vector<MoveSelector*>()),
        name(gname), scaleDeltas(adjustDeltas), theScale(ds), 
        treatMissAsMoveNN(tmamNN), shuffle(gshuffle), when(gwhen), 
        includeMoveNN(imNN), isReferenceTrial(isRefTrial),
        pwv(NULL), swv(NULL) 
   {  
      reset();  //sets pwv and swv
   } 
 
   virtual ~Trial() { 
      clearFilteredDecisions();
      deleteAllTurns(); 
      //delete(pTurns);
      list<TurnFilter*>::iterator citr = filters.begin();
      list<TurnFilter*>::iterator cite = filters.end();
      while (citr != cite) {
         TurnFilter* tf = *citr++;
         delete(tf);
      }
      //delete(theScale);   //since new in all constructors
      vector<MoveSelector*>::iterator sitr = theSelectors->begin();
      vector<MoveSelector*>::iterator site = theSelectors->end();
      while (sitr != site) {
         MoveSelector* ms = *sitr++;
         delete(ms);
      }
      delete(theSelectors);
      delete(evalSwap);
      delete(pwv);
      delete(swv);
   } 
 
   virtual string getName() const { return name; }  //virtual for Catalogable 
 
   bool scalesDeltas() const { return scaleDeltas; } 
 
   void setDist(IRfun::Dist newDist) { 
      dist = newDist; 
   } 

   string strPWV() const {
      ostringstream oss;
      size_t offset = theScale->getLowDepth();
      for (size_t i = 0; i < pwv->size(); i++) {
         oss << (i+offset) << "-" << IRutil::ftoa(pwv->at(i), 3) << " ";
      }
      return oss.str();
   }

   string strSWV() const {
      ostringstream oss;
      size_t offset = theScale->getSwingLow();
      for (size_t i = 0; i < swv->size(); i++) {
         oss << (i+offset) << "-" << IRutil::ftoa(swv->at(i), 3) << " ";
      }
      return oss.str();
   }

   void setSelector(MoveSelector* selector) {
      theSelector = selector;
   }

   void addSelector(MoveSelector* selector) {
      theSelectors->push_back(selector);
   }

   void clearSelectors() {
      theSelectors->clear();
   }

   size_t numSelectors() const { return theSelectors->size(); }

   vector<MoveSelector*>* exportSelectors() { return theSelectors; }

   void setScale(DeltaScale* ds) {   //Should be followed by reset()
      scaleDeltas = true; 
      theScale = ds; 
cerr << "resetting after setScale..." << endl;
      reset(); 
cerr << "done." << endl;
   } 
   DeltaScale* getScale() const { 
      return theScale; 
   } 

   void setSpec(const TrialSpec& spec) { 
      theSpec = spec; 
      //setPWs();
      setLWs();
      size_t numArgs = (theScale->getSwingPolicy()->separates() ? 1 : 3);
      theSpec.memoize(numArgs);
   } 

   TrialSpec getSpec() const { 
      return theSpec; 
   } 
 
   void setS(double s) { 
      theSpec.s = s; 
      size_t numArgs = (theScale->getSwingPolicy()->separates() ? 1 : 3);
      theSpec.memoize(numArgs); 
   } 
   void setC(double c) { 
      theSpec.c = c; 
      size_t numArgs = (theScale->getSwingPolicy()->separates() ? 1 : 3);
      theSpec.memoize(numArgs); 
   }
   void setD(double d) { theSpec.d = d; setLWs(); } 
   void setV(double v) { theSpec.v = v; setLWs(); }
   void setA(double a) { theSpec.a = a; }
   void setHM(double hm) { theSpec.hm = hm; }
   void setHP(double hp) { theSpec.hp = hp; }
   void setB(double b) { theSpec.b = b; }

   void setParams(double s, double c, double d, double v, double a,
                  double hm, double hp, double b) {
      theSpec.s = s; 
      theSpec.c = c;
      theSpec.d = d;
      theSpec.v = v; 
      theSpec.a = a;
      theSpec.hm = hm;
      theSpec.hp = hp;
      theSpec.b = b;
      //setPWs();
      setLWs();
      size_t numArgs = (theScale->getSwingPolicy()->separates() ? 1 : 3);
      theSpec.memoize(numArgs);
   } 
   void setWhichParams(size_t paramsCode, size_t n, const double* params) {
      //paramsCode is (s,c,d,v,w,em,ep,a) from 00000000 to 11111111 = 255
      bool pwflag = false;
      bool memoflag = false;
      size_t paramUsed = 0;
      if ((paramsCode >> 7) % 2) {
         theSpec.s = params[paramUsed++];
         memoflag = true;
      }
      if ((paramsCode >> 6) % 2) {
         theSpec.c = params[paramUsed++];
         memoflag = true;
      }
      if ((paramsCode >> 5) % 2) {
         theSpec.d = params[paramUsed++];
         pwflag = true;
         memoflag = true;
      }
      if ((paramsCode >> 4) % 2) {
         theSpec.v = params[paramUsed++];
         pwflag = true;
      }
      if ((paramsCode >> 3) % 2) {
         theSpec.a = params[paramUsed++];
         //pwflag = true;
      }
      if ((paramsCode >> 2) % 2) {
         theSpec.hm = params[paramUsed++];
         //pwflag = true;
      }
      if ((paramsCode >> 1) % 2) {
         theSpec.hp = params[paramUsed++];
      }
      if (paramsCode % 2) {
         theSpec.b = params[paramUsed++];
         //pwflag = true;
      }

      if (pwflag) { setLWs(); }   //{ setPWs(); }
      if (memoflag) { 
         size_t numArgs = (theScale->getSwingPolicy()->separates() ? 1 : 3);
         theSpec.memoize(numArgs); 
      }
   }
         
      
   //void setDeltaCap(double newCap) { deltaCap = newCap; } 
 
   double getS() const { return theSpec.s; } 
   double getC() const { return theSpec.c; } 
   double getD() const { return theSpec.d; }
   double getV() const { return theSpec.v; }
   double getA() const { return theSpec.a; }
   double getHM() const { return theSpec.hm; }
   double getHP() const { return theSpec.hp; }
   double getB() const { return theSpec.b; }

   double getDeltaCap() { return theScale->getDeltaCap(); } //{ return deltaCap; } 
   TrialSpec getTrialSpec() const { return theSpec; } 
   //vector<DecisionInfo*>* getDecisions() const { return theDecisions; } 
   size_t numDecisions() const { return theDecisions->size(); }
   list<TurnInfo*>* getTurns() { return pTurns; } //!!! used only by Ensemble ctor
   Models::MODEL getModel() const { return model; } 
   void setModel(Models::MODEL newModel) { model = newModel; }
   bool getFixPolicy() const { return fixDistortion; } 
   void setFixPolicy(bool newFix) { fixDistortion = newFix; }
   bool getMoveNNPolicy() const { return treatMissAsMoveNN; }
   void setMoveNNPolicy(bool newNN) { treatMissAsMoveNN = newNN; }
 
   void attachFilter(TurnFilter* filter) { 
      filters.push_back(filter); 
      //this and detachFilter do not force a reset (yet)---caller should do. 
   } 
 
   void detachFilter(TurnFilter* filter) {  //does not delete filter itself 
      list<TurnFilter*>::iterator it = filters.begin(); 
      while (it != filters.end() && (*it) != filter) { it++; } 
      if (it != filters.end()) { 
         filters.erase(it); 
      } else { 
         cout << "Uncaught attempt to detach unattached filter." << endl; 
      } 
   } 
 
   void clearFilters() { 
      filters.clear(); 
      //filters = list<TurnFilter*>(); 
      reset(); 
   } 
 
   void clearFilteredDecisions() const { 
      vector<DecisionInfo*>::const_iterator it = theDecisions->begin();
      vector<DecisionInfo*>::const_iterator ite = theDecisions->end();
      while (it != ite) {
         DecisionInfo* dp = (*it++);
         delete(dp); 
      } 
      theDecisions->clear(); 
   } 

   void zapBootWeights() {
      int n = numDecisions();
      for (int i = 0; i < n; i++) {
         theDecisions->at(i)->setBootWeight(0.0);
      }
   }
   void resetBootWeights() {
      int n = numDecisions();
      for (int i = 0; i < n; i++) {
         theDecisions->at(i)->setBootWeight(1.0);
      }
   }

   void resample(size_t numItems, bool replace) {
      int n = numDecisions();
      if (replace) {
         zapBootWeights();
         for (int i = 0; i < numItems; i++) {
            int j = IRutil::myRand(0, n);
            theDecisions->at(j)->incBootWeight();
         }
      } else if (numItems > 0.9*double(n)) {
         cout << "Request of " << numItems << " close to " << n
              << " so returning full set." << endl;
         resetBootWeights();
         return;
      } else {
         zapBootWeights();
         int i = 0;
         while (i < numItems) {
            int j = IRutil::myRand(0, n);
            if (theDecisions->at(j)->getBootWeight() < IRutil::MINPROB) {
               theDecisions->at(j)->incBootWeight();
               i++;  //success
            }
         }
      }
   }

   void resampleGames(size_t numGames, bool replace, bool oneSide) {
      int n = numDecisions();
      if (n == 0) { 
         cout << "Please add filtered turns..." << endl;
         return;
      }
      resetGameIDs();
      size_t numFilteredGames = filteredGameIDs.size();
      if (numGames > 0.9*numFilteredGames && (!replace)) {
         cout << "Request of " << numGames << " close to " << numFilteredGames
              << " so returning full set." << endl;
         resetBootWeights();
         return;
      } else {
         zapBootWeights();
         vector<double> gameBootWts(numFilteredGames,0.0);
         int i = 0;
         while (i < numGames) {
            int j = IRutil::myRand(0, numFilteredGames);
            if (gameBootWts.at(j) < IRutil::MINPROB || replace) {
               gameBootWts.at(j) += 1.0;  //no weights for games?
               i++;  //success'
            }
         }
         int n = numDecisions();
         int currGame = 0;
         int currTurn = 0;
         while (currGame < numFilteredGames) {
            if (gameBootWts.at(currGame) >= 1.0) {
               string currGameID = filteredGameIDs.at(currGame);
               string gameID = theDecisions->at(currTurn)->pParent->pGameInfo->gameID;
               while (currTurn < n-1 && gameID != currGameID) {
                  currTurn++;
                  gameID = theDecisions->at(currTurn)->pParent->pGameInfo->gameID;
               }
               bool whichSide = (IRutil::myRand(0,2) == 0);
               while (currTurn < n-1 && gameID == currGameID) {
                  if ((!oneSide) || (whichSide == theDecisions->at(currTurn)->pParent->whiteToMove)) {
                     theDecisions->at(currTurn)->incBootWeight();
                  }
                  currTurn++;
                  gameID = theDecisions->at(currTurn)->pParent->pGameInfo->gameID;
               }
            }
            currGame++;
         }
      }
   }
                  

      


 
   /** Only (non-debugging) place in the program where a DecisionInfo is 
       constructed, and only place where deltas can be adjusted. 
       Note that scaleDeltas is usually assumed to be true. 
        
       In the background is a permutation whose size "psize" is the same as that
       of the  "probs" array that will be computed by the TupleInfo's methods.   
       () if dsize (= pTurn->deltas->size) == NCUTOFF && fixDistortion, 
          then psize = dsize, else psize = NCUTOFF+1. 
       () if (! randomize) then the permutation is the identity 
       () if (randomize && !includeMoveNN && dsize == NCUTOFF) the permutation  
          randomizes 0..NCUTOFF-1 but fixes NCUTOFF, 
       () else, it randomizes 0..psize-1. 
    */ 
   DecisionInfo* translateTurn(const TurnInfo* const pTurn) const { 
      bool pp = (theScale->getPatchPolicy() == MATCH_PROBS); 
      bool ua = (theScale->getPatchPolicy() == BALANCE_TIES); 
      return new DecisionInfo(pTurn,scaleDeltas,theScale,pp,ua,evalSwap);
   } 
 
   void addFilteredTuples() const { 
       //static counters
       IRutil::numResets++;

       for (list<TurnInfo*>::const_iterator tu = pTurns->begin(); 
               tu != pTurns->end(); tu++) { 
           TurnInfo* ti = *tu;
           if (filterOne(ti)) { 
               IRutil::DIcount++;
               DecisionInfo* di = translateTurn(ti);

               theDecisions->push_back(di);
           }
       } 
   }  

   void resetGameIDs() {
      filteredGameIDs.clear();
      string lastGameID = "";
      vector<DecisionInfo*>::const_iterator dit = theDecisions->begin();
      vector<DecisionInfo*>::const_iterator dite = theDecisions->end();
      while (dit != dite) {
         DecisionInfo* dec = *dit++;
         string gameID = dec->pParent->pGameInfo->gameID;
         if (gameID != lastGameID) {
            filteredGameIDs.push_back(gameID);
            lastGameID = gameID;
         }
      }
   }
 
   bool isReady() const { return (!theDecisions->empty()); } 

   void reset(bool isRefTrial = false, bool onExit = false) { 
      clearFilteredDecisions(); 
      //setPWs();
      setLWs();
      if (!onExit) { addFilteredTuples(); }
   } 
 
   string speakFit(const double score, const vector<double>& up, 
                   const vector<double>& scores, const double totalWeight, 
                   const int tupleCount) const; 
   string speakFitNew(const double score,const double result2,const double totalWeight, 
                   const int tupleCount) const; 
 
   double percFit(vector<ostream*>* outs = new vector<ostream*>()); 
 
   double percFitOld(vector<ostream*>* outs = new vector<ostream*>()); 
   double percFitOldL1(vector<ostream*>* outs = new vector<ostream*>()); 
 
   /** Test expected number of first-line matches and top-matches for the 
       moves in "theDecisions", based on the curve specification in "theSpec". 
       Uses spec's weighting only if third argument is "false". 
       Assumes theDecisions have already been filtered. 
       Also reports actual matches *to the MLM data used to compute shares*, 
       but this might not be relevant to tests with another engine. 
       perfTest(uw,tn,suw,sun,numIndices,silent,dump);

       The judgment depth is taken from the TrialSpec and so is not a
       parameter of this method.
    */ 

   PerfData perfTest(bool unitWeights = false, bool tmaNN = true,
                     bool showUnitWeights = false, bool showUnscaled = true,
                     size_t numIndices = 15, size_t equalTopIndexLimit = IRutil::NCUTOFF,
                     bool silent = true, string dump = "", size_t movesLimit = 1000) const; 
 
   /** Return sum_t log(1/p_t), where p_t is the probability of the played 
       move at turn t---as estimated from *this* spec on *these* tuples. 
       Used by "Minimizer" class for Max-Likelihood fitting. 
    */ 
   double logSumPlayedMoves() const; 

   SimpleStats perfTestSimple(size_t numIndices, size_t numSelectors,
                              vector<MoveSelector*>* mySelectors, size_t equalValueIndexLimit,
                              bool unitWeights = false, bool tmaNN = true, bool giveFreq = true) const;


   double firstL1a() { 
      setDist(IRfun::L1a); 
      double value = percFit(NULL); 
      PerfData pf = perfTest(false, fixDistortion); 
      setDist(IRfun::leastSquares); 
      return 0.5*(IRutil::sqr(value/10000.0) 
            + IRutil::sqr(pf.moveMatchWtd.measuredValue - pf.moveMatchWtd.projectedValue)); 
   } 
 
   double topL1a() { 
      setDist(IRfun::L1a); 
      double value = percFit(NULL); 
      PerfData pf = perfTest(false, fixDistortion); 
      setDist(IRfun::leastSquares); 
      return 0.5*(IRutil::sqr(value/10000.0) 
                  + IRutil::sqr(pf.equalValueMatchWtd.measuredValue 
                                - pf.equalValueMatchWtd.projectedValue)); 
   } 
 
   double probabilityBins(); 
 
   string getModelName() const { 
      string modelKind; 
      switch(model) { 
       case Models::SHARES: 
         modelKind = "Shares"; 
         break; 
       case Models::POWER_SHARES: 
         modelKind = "PowerShares"; 
         break; 
       default: 
         modelKind = "Kind?"; 
         break; 
      } 
      return modelKind; 
   } 
 
   virtual string getDescription() const { 
      const int c = pTurns->size(); 
      string res = getModelName() + " trial, " //+ IRutil::itoa(numScores) 
         //+ " pts. in " + IRutil::ftoa(percentilePoints->at(0)) + ".." 
         //+ IRutil::ftoa(percentilePoints->at(numScores-1)) + ",\n      " 
         + IRutil::itoa(c) + "-->" + IRutil::itoa(theDecisions->size())  
         + " turns, " + IRutil::itoa(filters.size()) + " filters, " 
         + (scalesDeltas() ? "modified" : "unit") + " delta scale, cap " 
         + IRutil::ftoa(getScale()->getDeltaCap(),2); 
      //res += "\nSpec: " + string(theSpec); 
      return res; 
   } 
 
   virtual operator string() const { 
      const int c = pTurns->size(); 
      string res = getModelName() + " trial " + getName() + ": " 
         + IRutil::itoa(c) + " turns, " 
         + IRutil::itoa(theDecisions->size()) + " filtered by "  
         + IRutil::itoa(filters.size()) + " filters; delta cap " 
         //+ IRutil::ftoa(deltaCap,2) + "\n"  
         + IRutil::ftoa(getScale()->getDeltaCap(),2) + "\n"
         + "Spec " + string(theSpec) + ";\n" ; 
/*
      if (numScores > 0) { 
         res += "Percentile range " + IRutil::ftoa(percentilePoints->at(0))  
             + ".." + IRutil::ftoa(percentilePoints->at(numScores-1))  
             + ", " + IRutil::itoa(numScores) + " points, "; 
      } 
*/
      string pre = (theScale->getPatchPolicy() == MATCH_PROBS) ? 
             "patching probabilities" : "using raw probabilities"; 
      if (fixDistortion) { pre += ", fixing distortion"; } 
      //res += pre + ", delta cap " + IRutil::ftoa(deltaCap,2) + ";\n"; 
      if (scaleDeltas) { 
         res += string(*theScale) + "\n"; 
      }
      res += "Filters:\n"; 
      for (list<TurnFilter*>::const_iterator it = filters.begin(); 
           it != filters.end(); it++) { 
         res += string(**it) + "\n"; 
      } 
      return res;
   }

   virtual string saySelectors() const {
      string res = "Selector(s):\n";
      for (int m = 0; m < theSelectors->size(); m++) {
         res += theSelectors->at(m)->getName() + ": " + theSelectors->at(m)->getDescription() + "\n";
      }
      //res += theSelector->getName() + ": " + theSelector->getDescription() + "\n";
      return res; 
   } 
 
   string tuplesToString() const { 
      string res = ""; 
      double scaledFalloff = 0.0; 
      double cappedFalloff = 0.0; 
      double uncappedFalloff = 0.0; 
      int i = 1; 

      return res + "Total falloff: scaled " + IRutil::ftoa(scaledFalloff,2) 
                 + ", capped " + IRutil::ftoa(cappedFalloff,2) 
                 + ", uncapped " + IRutil::ftoa(uncappedFalloff,2) + "\n"; 
   } 


   string turnsToString() const {
      string res = "";
      int i = 1;
      for (list<TurnInfo*>::const_iterator it = pTurns->begin();
           it != pTurns->end(); it++) {
         res += IRutil::itoa(i) + ". " + (*it)->gameID + "\n"
             + string(**it) + "\n\n";
         i++;
      }
      return res;
   }

   string decisionsToString() const {
      string res = "";
      int i = 1;
      for (vector<DecisionInfo*>::const_iterator it = theDecisions->begin();
           it != theDecisions->end(); it++) {
         res += IRutil::itoa(i) + ". ";
         res += string((*it)->pParent->gameID) + "\n";
         res += string(**it) + "\n\n";
         i++;
      }
      return res;
   }

   void dumpDeltas(const string& name) const {  //for debugging
      ofstream* file = new ofstream(name.c_str(), ios::app);
      if(!file->is_open()) {
         cerr << "Cannot stat the output file, returning..." << endl;
         return;
      } //else
      for(vector<DecisionInfo*>::const_iterator tu = theDecisions->begin();
             tu != theDecisions->end(); tu++) {
         (*file) << (*tu)->operator string() << endl;
      }
   }


 
}; //end of class Trial. 
 
 
#endif    //end of #ifndef __IR_TRIAL_H__ 
 
 
 
//File-----------------------Trial.cpp------------------------------------ 
 
#ifndef __IR_TRIAL_CPP__ 
#define __IR_TRIAL_CPP__ 

#ifndef __IR_TRIAL_H__
#include "Trial.h"
#endif
 
//---------------IMPLEMENTATION OF CLASS TRIAL-------------------------- 
 
/** Return sum_t log(1/p_t), where p_t is the probability of the played 
    move at turn t---as estimated from *this* spec on *these* tuples. 
    Weights are taken from this spec, while distortion fixing and 
    lumping all moves outside the top N as "move N+1" are /recommended/. 
    Making this a zero-parameter method enables its direct use by the 
    "Minimizer" class---minimizing the sum equates to maximizing the 
    probability of the sequence of played moves, assuming independence. 
 */ 
double Trial::logSumPlayedMoves() const { 
   //if (!isReady()) { reset(); } 
   double logSumPlayed = 0.0; 
   double accumWeight = 0.0; 
   //vector<double> probs; 
   for (vector<DecisionInfo*>::const_iterator it = theDecisions->begin(); 
        it != theDecisions->end(); it++) { 
      DecisionInfo* dec = *it; 
      const double bw = dec->getBootWeight();

      if (bw < IRutil::MINPROB) { continue; } //Else---!!

      //probs = Models::getProbs(dec,theSpec,pwv,swv,model);
      Models::MoveProjection* mp = Models::getProjection(dec,theSpec,pwv,swv,model);
      //double weight = (unitWeights ? 1.0 : Models::getWeight(*it,theSpec,probs));
      //double bweight = bw*weight;
      //double bweight = bw*Models::getDecWeight(*it,theSpec,probs);
      double bweight = bw*mp->weight;

      accumWeight += bweight; 
      int pmi = dec->getPlayedMoveIndex();
      mp->indexPlayedMove = pmi;

      size_t jd = theScale->getJudgmentDepth();
      size_t useDepth = ((jd == 0 || jd >= dec->dataHighDepth) ? dec->dataHighDepth
                             : (jd <= dec->dataLowDepth ? dec->dataLowDepth : jd));
      size_t playedRank = (useDepth >= dec->dataHighDepth ? pmi 
                            : dec->getRankAtDepth(pmi,useDepth));

      //size_t useDepth = (theScale->getJudgmentDepth() == 0 ? dec->dataHighDepth : theScale->getJudgmentDepth());
      //int playedRank = (theScale->getJudgmentDepth() == 0 ? pmi
                           //: dec->getRankAtDepth(pmi,useDepth));
      //size_t indexFirstMove = (theScale->getJudgmentDepth() == 0 ? 0
                           //: dec->getIndexFirstMoveAtDepth(useDepth));

      //double pj = probs.at(dec->getPlayedMoveIndex()); 
      double pj = mp->probs->at(playedRank);
      if (pj < IRutil::MINPROB) { pj = IRutil::MINPROB; }
      logSumPlayed += bweight * IRutil::log2(1/pj); 
      delete(mp);
   } 
   double r = IRutil::divifgt0(logSumPlayed,accumWeight); 
 
   return r; 
} 
 
 
string Trial::speakFitNew(const double score,const double result2, const double totalWeight, 
                   const int tupleCount) const 
{ 
   ostringstream o; 
 
   o << "Overall fit score: " << IRutil::ftoa(score,3) << endl; 
   o << "Without Normalizing: " << IRutil::ftoa(result2,3) << endl; 
   o << "Number of filtered turns: " << tupleCount << endl; 
   o << "Average weight per turn : " 
          << IRutil::ftoa(totalWeight/tupleCount, 3) << endl; 
   o << theSpec.showCurvePoints(0.05,1.00); 
 
   return o.str(); 
} 
string Trial::speakFit(const double score, const vector<double>& up, 
                       const vector<double>& scores, const double totalWeight, 
                       const int tupleCount) const { 
 
   ostringstream o; 
 
/*
   o << "Differences (percentilePoint - result), x 100:" << endl; 
   for (int i = 0; i < numScores; i++) { 
      const double a = percentilePoints->at(i); 
      o << a << ": " << IRutil::ftoa(100.0*(a - up[i]/totalWeight), 3) 
             << endl; 
   } 
*/
   o << "Overall fit score: " << IRutil::ftoa(score,3) << endl; 
   o << "Number of filtered turns: " << tupleCount << endl; 
   o << "Average weight per turn : " 
          << IRutil::ftoa(totalWeight/tupleCount, 3) << endl; 
   o << "Curve points:" << endl; 
   o << theSpec.showCurvePoints(0.05,1.00); 
 
   return o.str(); 
} 
 
/** New Percentile-Fit Model using piecewise integral 
    Code designed by Tamal Biswas, edited by KWR 
*/ 
double Trial::percFit(vector<ostream*>* outs) { 
 
   if (!isReady()) { reset(); } 
   double totalWeight = 0.00;   
   int tupleCount = 0; 
 
   vector<IRutil::Endpt> endpts; 
 
   for(vector<DecisionInfo*>::const_iterator tu = theDecisions->begin(); 
      tu != theDecisions->end(); tu++) { 
         IRutil::Endpt u = Models::getProbEndpt(*tu,theSpec,pwv,swv,model); 
         // Generate second endpt to use as r_i ( end range for current move ) 
         IRutil::Endpt v(u.partner, u.val, u.weight); 
         endpts.push_back(u); 
         endpts.push_back(v); 
         tupleCount++; 
         totalWeight += u.weight; 
   } 
   //Sorting all the tuples 
   std::sort(endpts.begin(), endpts.end(), IRutil::endPtLT); 
   endpts.push_back(IRutil::Endpt(1.0,1.0,0.0));  //target for last piece 
   int T = tupleCount; 
   //Running Sum 
   double a = -totalWeight; 
   double b = 0.0; 
   double il2dist = 0.0;   //accumulated piecewise integral value 
   IRutil::Endpt nextPt = endpts.at(0); 
   if (nextPt.val > 0.0) { 
      il2dist += IRutil::cube(nextPt.val)/3.0; 
   } 
   int numPieces = endpts.size() - 1; 
   for(int i = 0; i < numPieces; i++) { 
      IRutil::Endpt currPt(nextPt.val,nextPt.partner,nextPt.weight); 
      nextPt = endpts.at(i+1); 
      double val = currPt.val; 
      double part = currPt.partner; 
      if (currPt.isP()) { 
         //Updating the Running Sum 
         a += currPt.weight/(part - val);		 
         b -= val*currPt.weight/(part - val); 
      } else { 
         //Here val=r_i and part=p_i 
         a -= currPt.weight/(val - part); 
         // Incrementing b. b stores info about full-hit+ extra. 
         b += currPt.weight + part*currPt.weight/(val - part); 
      } 
      double nextVal = nextPt.val;  //can be 1.0 at the end 
      if(val == nextPt.val) { 
         //skip: We have updated the running sum. That's all we need. 
      } else { 
         /*------------ 
         il2dist += IRutil::sqr(A)*(IRutil::cube(nextVal) - IRutil::cube(val))/3 
                       + A*B*(IRutil::sqr(nextVal) - IRutil::sqr(val)) 
                       + IRutil::sqr(B)*(nextVal - val); 
         ------------*/ 
         //il2dist += IRutil::sqr(a)*(IRutil::cube(nextVal) - IRutil::cube(val))/3 
         il2dist += (nextVal - val)* 
            (    a*(nextVal + val)*(a*nextVal/3.0 + b) 
               + IRutil::sqr(a*val)/3.0 
               + IRutil::sqr(b) 
            ); 
      } 
   } 
   //double result = il2dist/IRutil::sqr(T); 
   //double result = il2dist/T; 
   double result = IRutil::divifgt0(il2dist,totalWeight); 
 
   if (outs && (!outs->empty())) { 
      string st = speakFitNew(result, il2dist, totalWeight, tupleCount); 
      for (vector<ostream*>::iterator it = outs->begin(); 
         it != outs->end(); it++) { 
            (**it) << st; 
      } 
   } 
   return result; 
} 
 
 
double Trial::probabilityBins() { 
   vector<double> allProbs; 
   vector<double> hitProbs; 
   if (!isReady()) { reset(); } 
   double totalWeight = 0.00;  //class field incremented by percOne() 
   int decCount = 0; 
   int probsCount = 0; 
   double score = 0; 
 
   //First read all the derived probabilities 
   for(vector<DecisionInfo*>::const_iterator tu = theDecisions->begin(); 
       tu != theDecisions->end(); tu++) { 
 
      DecisionInfo* dec = *tu; 
      decCount++; 
 
      int numDeltas = dec->getNumberOfMovesAnalyzed(); 
      Models::MoveProjection* mp = Models::getProjection(dec,theSpec,pwv,swv,model);
      //vector<double> probs = Models::getProbs(dec,theSpec,pwv,swv,model); 
      const int numProbs = mp->probs->size(); 
 
      probsCount += numProbs; 
 
      //double weight = Models::getDecWeight(dec,theSpec,probs); 
      //totalWeight += weight; 
      totalWeight += mp->weight;
      int playedMoveIndex = dec->playedMoveIndex; 
      int iplayedMoveIndex = dec->getPlayedMoveIndex(); 
       
      if (playedMoveIndex == IRutil::playedMoveNotInTopN) { 
         if (numDeltas < IRutil::NCUTOFF) { 
            cout << "Data glitch: short tuple with no played move." << endl; 
            decCount--;  //it will already have been incremented 
            continue;  //skips tuple 
         } else { 
            playedMoveIndex = iplayedMoveIndex = numDeltas;//== index last share 
         } 
      } 
      allProbs.insert(allProbs.end(),mp->probs->begin(),mp->probs->end()); 
      hitProbs.push_back(mp->probs->at(iplayedMoveIndex)); 
   } 
 
   //Amazingly, we don't need to associate hits to tuples anymore. 
 
   sort(allProbs.begin(),allProbs.end()); 
   sort(hitProbs.begin(),hitProbs.end()); 
   allProbs.push_back(2.0);  //sentinel 
   hitProbs.push_back(2.0); 
 
   //vector<double> pp = *percentilePoints;  //always low-to-high 
   //Thus we treat blunders first, since sort begins with low values. 
   vector<double> pp;
   for (int ell = 1; ell < 101; ell++) {
      pp.push_back(ell/100.0);
   }
 
   //if (pp.at(pp.size()-1) < 1.0) { pp.push_back(1.0); } 
   size_t binNo = (pp.at(0) > 0.0) ? 0 : 1; 
   double hiProb = 0.0; 
   size_t api = 0; 
   size_t hpi = 0; 
   while (binNo < pp.size()) { 
      double loProb = hiProb; 
      hiProb = pp.at(binNo); 
      //LOOP INV: loProb < allProbs[api] <= hiProb, ditto hitProbs[hpi] 
      size_t abc = 0;  //allProbs bin count 
      size_t hbc = 0; 
      double probSum = 0.0; 
      while (allProbs.at(api) <= hiProb) { 
         abc++; 
         probSum += allProbs.at(api); 
         api++; 
      } 
      double binAvgProb = (abc > 0) ? probSum/abc : 0; 
      while (hitProbs.at(hpi) <= hiProb) { 
         hbc++; 
         hpi++; 
      } 
       
      //note: score is weighted by the bin size. 
      //score += (abc > 0) ? abc*(*dist)(binAvgProb, hbc/double(abc)) : 0.0; 
      score += (abc > 0) ? (*dist)(binAvgProb, hbc/double(abc)) : 0.0; 
      binNo++; 
   } 
 
   return 10000*score/probsCount; 
} 
   
 
    
/** Test expected number of first-line matches and top-matches for the 
    sequence of moves "tuples", based on the curve specification in "spec". 
    If none given, use those associated with the present trial. 
    Uses spec's weighting only if third argument is "false". 
    Assumes tuples have already been filtered. 
    Reports z-scores for various statistical tests on both:
    () the current MLM data used to compute shares, which could be a "panel composite"
    () the moves selected by theSelectors->at(j), which may come from other data.  This data
       need not be composite and can come from other engines.  
    The "silent" argument might be turned into a timesaver...
    The "verbose" argument prints to a MovesOutput file.

    An important procedural understanding is that the projected probabilities
    are not based on the depth used for judgment but on the turn data (as modified
    in DecisionInfo, scale settings, and other parts of the TrialSpec.
    Those probabilities are then applied to the moves and their ranks and values
    at the judgment depth in order to determine the projected quantities.
    The actual quantities on which the projections are judged are also taken
    from the judgment depth.  Thus it is possible to use the values at (say)
    depths 5..15 to predict results at depth 20.  Vice-versa is enabled,
    but its meaning is unclear.
 */ 
PerfData Trial::perfTest(bool unitWeights, bool tmaNN, bool showUnitWeights,
                         bool showUnscaled, size_t numIndices, size_t equalTopIndexLimit,
                         bool silent, string dump, size_t movesLimit) const {

   PerfData pf(theScale->getDeltaCap(), equalTopIndexLimit, theDecisions->size());  //initializes pf.numTurns 
   //if (!isReady()) { reset(); } 
   if (theDecisions->size() == 0) { return pf; } 
   //pf.numTurns = theDecisions->size(); 
   pf.accumWeight = 0.0; 
 
   pf.weighted = (!unitWeights)  
                       && theSpec.weightMethodChoice != IRfun::UNITWTS; 
   string adj = pf.weighted ? "Wtd." : "Unwtd."; 

   size_t numInd = 1 + IRutil::NCUTOFF;     //will use numFilledIndices for each turn later...
   vector<double> indexCumeProj(numInd,0.0);
   vector<double> indexCumeActual(numInd,0.0);

   for (int i = 1; i <= numInd; i++) {      //move indices print as 1-based
      MoveIndexTest mtest(i, 7, 2, 0.0, 0.0, 0.0, 
                          true, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1, 1.0, false, false);
      pf.moveIndexTests.push_back(mtest);
      pf.moveIndexTestsWtd.push_back(mtest);
   }

   size_t numSelectors = theSelectors->size();
   for (size_t m = 0; m < numSelectors; m++) {
      SelectionTest stest(theSelectors->at(m)->getName(), 7, 2, 0.0, 0.0, 0.0,
                          true, 0.0, 0.0, 0.0, 1, 1.0, false, false);
      pf.selectionTests.push_back(stest);
      pf.selectionTestsWtd.push_back(stest);  //a true copy
   }


   //vector<double> probs; 
 
   //pf.turnsData->clear();   //not needed?  !!!

   string dumpFile = (dump == "" ? "movesDump.txt" : dump);
   ofstream MOVESDUMP(dumpFile.c_str(), ios::app);

   for (vector<DecisionInfo*>::const_iterator it = theDecisions->begin(); 
        it != theDecisions->end(); it++) { 

      DecisionInfo* dec = *it; 
      const double bw = dec->getBootWeight();

      if (bw < IRutil::MINPROB) { continue; } //Else---!!

      //probs = Models::getProbs(dec,theSpec,pwv,swv,model); //this should not depend on judgment depth??
      Models::MoveProjection* mp = Models::getProjection(dec,theSpec,pwv,swv,model,equalTopIndexLimit);

      //double weight = (pf.weighted ? Models::getDecWeight(*it,theSpec,probs) : 1.0);
      //double bweight = bw*weight;
      double bweight = bw*mp->weight;
 
      size_t numDeltas = dec->getNumberOfMovesAnalyzed(); 
      //size_t pmi = dec->getPlayedMoveIndex();   //absolute, perhaps build into mp?  !!!
      size_t pmi = mp->indexPlayedMove;

      size_t jd = theScale->getJudgmentDepth();
      size_t useDepth = ((jd == 0 || jd >= dec->dataHighDepth) ? dec->dataHighDepth
                             : (jd <= dec->dataLowDepth ? dec->dataLowDepth : jd));
      size_t playedRank = (useDepth >= dec->dataHighDepth ? pmi 
                            : dec->getRankAtDepth(pmi,useDepth));
      if (playedRank != mp->rankPlayedMove) {
         cerr << "Rank Mismatch!" << endl;
      }

      size_t indexFirstMove = (useDepth >= dec->dataHighDepth ? 0 : dec->getIndexFirstMoveAtDepth(useDepth));
      //size_t useDepth = theScale->getJudgmentDepth() == 0 ? dec->dataHighDepth : theScale->getJudgmentDepth();
      //int playedRank = (theScale->getJudgmentDepth() == 0 ? pmi
                        //: dec->getRankAtDepth(pmi, useDepth));  
      //size_t indexFirstMove = (theScale->getJudgmentDepth() == 0 ? 0
                               //: dec->getIndexFirstMoveAtDepth(useDepth));

/*
      mp.firstMoveProb = mp->probs.at(indexFirstMove);
      mp.playedMoveProb = probs.at(pmi);   //not probs.at(playedRank), keyed to move not index
      mp.playedMoveIndex = playedRank; 
      mp.playedMoveDelta = (useDepth >= dec->dataHighDepth ?   //theScale->getJudgmentDepth() == 0 ?
		               dec->getHighestDepthMoveDeltaScaled(pmi) 
		               //: dec->getDeltaScaled(playedRank, theScale->getJudgmentDepth()));  // *no*
		               : dec->getDeltaScaled(pmi,useDepth)); //deltas use "i"-order
      int i = 1;
      mp.topMoveProb = 0.0;
      if (useDepth >= dec->dataHighDepth) {   //theScale->getJudgmentDepth() == 0) {
         mp.topMoveProb = mp.firstMoveProb;
         while (i < numDeltas  
             && dec->getEvalP(i,dec->dataHighDepth) == dec->getEvalP(0,dec->dataHighDepth)) {
            mp.topMoveProb += probs.at(i); 
            i++; 
         } 
      } else {
         for (i = 0; i < numDeltas; i++) {
            if (dec->getEvalP(i, useDepth) == dec->getBestEvalP(useDepth)) {
               mp.topMoveProb += probs.at(i);
            }
        }
      }
*/
      //pf.turnsData->push_back(mp);   //store pointer, will delete-all later
      //pf.numTurns++;
      pf.totalBootItems += bw;
      pf.accumWeight += bweight;

      const double p0 = mp->probFirstMove;
      const double topProb = mp->probEqualTopMove;
      double pj = (pmi != IRutil::playedMoveNotInTopN   //pmi, NOT playedRank
                   || (fixDistortion && treatMissAsMoveNN)) ? mp->probs->at(pmi) : 0.0;
      if (pj < IRutil::MINPROB) { pj = IRutil::MINPROB; }
      const double psf = mp->projFalloffScaled;  //Models::predScaledFalloff(dec, probs,useDepth);

      const double puf = mp->projFalloffUnscaled;  //Models::predUnscaledFalloff(dec, probs,useDepth);
      const double psfv = mp->projFalloffVarianceScaled;
      const double pufv = mp->projFalloffVarianceUnscaled;
      const double psls = mp->projLogSumScaled;
      const double puls = mp->projLogSumUnscaled;
      const double pses = mp->projEntropySumScaled;
      const double pues = mp->projEntropySumUnscaled;

      const double matchAdd = (playedRank == 0 ? 1.0 : 0.0);
      bool etvMatch = dec->getEvalP(pmi, useDepth) == dec->getBestEvalP(useDepth)
                         && playedRank <= equalTopIndexLimit;
      const double topAdd = (etvMatch ? 1.0 : 0.0);
      const double falloffAdd = mp->playedMoveDeltaScaled;
      const double usfAdd = mp->playedMoveDeltaUnscaled;
                       // = (useDepth >= dec->dataHighDepth ?   //theScale->getJudgmentDepth() == 0 ?
                  //         dec->getHighestDepthMoveDeltaUnscaled(pmi)
                     //      : dec->getDeltaUnscaled(playedRank,useDepth));
      //double topAdd = (dec->getEvalP(pmi,dec->dataHighDepth) == dec->getEvalP(0,dec->dataHighDepth) ? 1.0 : 0.0);

      pf.scaledFalloff.uptick(bw, bw*falloffAdd, bw*psf, bw*psfv,
                              bw*psls, bw*pses, false);
      pf.scaledFalloffWtd.uptick(bweight, bweight*falloffAdd,
                                 bweight*psf, bweight*psfv, bweight*psls, bweight*pses, false);
      pf.unscaledFalloff.uptick(bw, bw*usfAdd, bw*puf, bw*pufv,
                                bw*puls, bw*pues, false);
      pf.unscaledFalloffWtd.uptick(bweight, bweight*usfAdd,
                                   bweight*puf, bweight*pufv, bweight*puls, bweight*pues, false);
      pf.scaledFalloffNextTurnCapped.uptick(bw, bw*dec->turnFalloffCapped, false);
      pf.scaledFalloffNextTurnCappedWtd.uptick(bweight, bweight*dec->turnFalloffCapped, false);

      //pf.unscaledFalloffNextTurnCapped
      //pf.unscaledFalloffNextTurnCappedWtd;

      pf.moveMatch.uptick(bw, bw*matchAdd, bw*p0, bw*p0*(1.0-p0),
                          bw*IRutil::log2(1.0/p0), bw*p0*IRutil::log2(1.0/p0), false);
      pf.moveMatchWtd.uptick(bweight, bweight*matchAdd, bweight*p0, bweight*p0*(1.0-p0),
                             bweight*IRutil::log2(1.0/p0), bweight*p0*IRutil::log2(1.0/p0), false);
      pf.equalValueMatch.uptick(bw, bw*topAdd, bw*topProb, bw*topProb*(1.0-topProb),
                                bw*IRutil::log2(1.0/topProb), bw*topProb*IRutil::log2(1.0/topProb), false);
      pf.equalValueMatchWtd.uptick(bweight, bweight*topAdd, bweight*topProb, bweight*topProb*(1.0-topProb),
                                   bweight*IRutil::log2(1.0/topProb),
                                   bweight*topProb*IRutil::log2(1.0/topProb), false);
      pf.playedMoveMatch.uptick(bw, bw, bw*pj, bw*pj*(1.0-pj),
                                bw*IRutil::log2(1.0/pj), bw*pj*IRutil::log2(1.0/pj), false);
      pf.playedMoveMatchWtd.uptick(bweight, bweight, bweight*pj, bweight*pj*(1.0-pj),
                                   bweight*IRutil::log2(1.0/pj),
                                   bweight*pj*IRutil::log2(1.0/pj), false);

/*
cerr << "pf.moveMatchWtd after adding " << matchAdd << " times " << bw << "*" << weight << endl << string(pf.moveMatchWtd) << endl;
cerr << "pf.scaledFalloffWtd after adding " << falloffAdd << " times " << bweight << endl << string(pf.scaledFalloffWtd) << endl;
cerr << "Predicted falloff add was " << psf << ", sig^2 " << psfv << endl;
*/

      size_t numFilledIndices = (mp->probs->size() >= IRutil::NCUTOFF + 1 ? IRutil::NCUTOFF + 1 
                                                                          : mp->probs->size());

      bool hitFlag = false;
      double hitAdd = 0.0;
      double testProbs = 0.0;
      const TurnInfo* pTurn = dec->pParent;
      double moveSwing, swingUsed, swingDiff;
      Move pm = pTurn->movePlayed;
      Move em = pTurn->engineMove;

      if (dump != "" && theDecisions->size() <= movesLimit && (!silent)) {  
         MOVESDUMP << endl << pTurn->gameID << endl;
         MOVESDUMP << pTurn->getFEN() << "; " << pm.TAN2LAN()
                   << ", engine " << em.TAN2LAN() << endl;
         //MOVESDUMP << pf.moveHeader() << endl << pf.moveLine(mp, true) << endl;
         MOVESDUMP << string(*theScale) << endl;
         MOVESDUMP << setprecision(2) << fixed << "Eval " << (pTurn->currEvalCP/100.0)
                   << " at depth " << useDepth << "; swap index " << (1+mp->proxies->swapIndex)
                   << " and spec " << string(theSpec) << ":" << endl;
         MOVESDUMP << endl;
         MOVESDUMP << " M# Rk   Move  RwDelta  ScDelta  Swing  SwDDep  SwRel   ProxyValue   ProjProb'y" << endl;
      }     //true for first-line match

      //Important to bear in mind again that probs[i] is keyed to the top-depth index i,
      //whereas the moveIndexTests are keys to j at the judgment depth d.
      //Happily j = getRankAtDepth(i, d) is 1-to-1 except on non-analyzed indices, when its
      //projected probability should fall into a "...notInTopN" catchall anyway.
      //
      for (int i = 0; i < numFilledIndices; i++) {

         if (i >= dec->getNumMovesWithValues()) { continue; }

         //size_t j = (theScale->getJudgmentDepth() == 0 ? i : dec->getRankAtDepth(i,useDepth));
         size_t j = (useDepth >= dec->dataHighDepth ? i : dec->getRankAtDepth(i,useDepth));
         double dt = (useDepth >= dec->dataHighDepth ? dec->getHighestDepthMoveDeltaScaled(i)
                                                     : dec->getDeltaScaled(i,useDepth));
         double du = (useDepth >= dec->dataHighDepth ? dec->getHighestDepthMoveDeltaUnscaled(i)
                                                     : dec->getDeltaUnscaled(i,useDepth));
         //double dt = (theScale->getJudgmentDepth() == 0 ? dec->getHighestDepthMoveDeltaScaled(i)
                                                        //: dec->getDeltaScaled(i,useDepth));
         //if (dt > deltaCap) { dt = deltaCap; }  //change from before: not auto-applied to "miss".
         double pri = mp->probs->at(i);
         if (pri < IRutil::MINPROB) { 
            pri = IRutil::MINPROB; 
            //if (i < 4) { cerr << "Yelp! for i:pri = " << i << ":" << pri << endl << string(*dec) << endl; }
         }
         testProbs += pri;
         if (pmi == i) {   //the hit becomes one for test j
            hitAdd = 1.0;
            hitFlag = true;
         }
         //double hitAdd = (pmi == i ? 1.0 : 0.0);
         //Below we use the fixed non-depth-dependent swing values.  They are not tested for, just displayed

         moveSwing = dec->getDecMoveSwing(i);
         swingUsed = mp->swingsUsed->at(i);
         swingDiff = swingUsed - mp->swingsUsed->at(mp->indexFirstMove);

         pf.moveIndexTests.at(j).uptick(bw, bw*hitAdd, bw*pri, bw*pri*(1.0-pri), 
                                        bw*IRutil::log2(1.0/pri), bw*pri*IRutil::log2(1.0/pri), bw*dt, 
                                        bw*moveSwing,
					bw*swingUsed,
					bw*swingDiff,
                                        false);
                                        //bw*(dec->getSwingScaled(i, dec->userHighDepth, true)));
                                        //bw*dt, bw*(dec->getSwing(i, dec->userHighDepth, true)));
         pf.moveIndexTestsWtd.at(j).uptick(bweight, bweight*hitAdd, bweight*pri, bweight*pri*(1.0-pri),
                                           bweight*IRutil::log2(1.0/pri), bweight*pri*IRutil::log2(1.0/pri),
                                           bweight*dt, 
                                           bweight*moveSwing,
                                           bweight*swingUsed,
                                           bweight*swingDiff,
                                           false);
                                           //bweight*(dec->getSwingScaled(i, dec->userHighDepth, true)));
                                           //bweight*dt, bweight*(dec->getSwing(i, dec->userHighDepth, true)));

         if (dump != "" && theDecisions->size() <= movesLimit && (!silent)) {  //true for first-line match
            MOVESDUMP << right << setw(3) << (1+i) << setw(3) << (1+j) 
                      << setw(7) << pTurn->consideredMoves->at(i).TAN2LAN() << ": " 
                      << fixed << setprecision(2) << setw(6) << du
                      << setw(8) << setprecision(3) << dt 
                      << setprecision(3) << setw(8) << moveSwing
                      << setw(8) << swingUsed << setw(8) << swingDiff 
                      << setprecision(8) << setw(13) << mp->proxies->values.at(i)
                      << setw(13) << pri << endl;
         }

         //indexCumeProj.at(j) += bw*pri;
         //indexCumeActual.at(j) += bw*hitAdd;
         indexCumeProj.at(j) += bweight*pri;
         indexCumeActual.at(j) += bweight*hitAdd;
         hitAdd = 0.0;
      }
      if (!hitFlag) { cerr << "Turn not hit: " << string(*dec) << endl; }
      if (fabs(testProbs - 1.0) > IRutil::SUMPROBSTOLERANCE && !silent) {
         cerr << "Bad sum " << testProbs << " in turn " << dec->pParent->turnNumber
              << (dec->pParent->whiteToMove ? "w of " : "b of ") << dec->pParent->pGameInfo->gameID << endl;
         IRutil::PROBLEM_FENS.insert(dec->pParent->getFEN());
         IRutil::PROBLEM_GAMES.insert(dec->pParent->gameID + "\n" + dec->pParent->getFEN());
      }

      for (size_t k = 0; k < pf.selectionTests.size(); k++) {
         double playedMoveAdd = (theSelectors->at(k)->apply(pTurn, pm) ? 1.0 : 0.0);
         double engineMoveAdd = (theSelectors->at(k)->apply(pTurn, em) ? 1.0 : 0.0);
         double selectionProb = 0.0;
         size_t i = 0;
         while (i < numDeltas) {
            Move move = pTurn->consideredMoves->at(i);
            if (theSelectors->at(k)->apply(dec->pParent, move)) {
               selectionProb += mp->probs->at(i);  //no test for near-zero needed here
            }                                      //assumes selectors have any needed depth info already 
            i++;
         }
         if (selectionProb < IRutil::MINPROB) { selectionProb = IRutil::MINPROB; }
         if (selectionProb > 1.0) {
            if (selectionProb > 1.0 + pTurn->numConsideredMoves * IRutil::MINPROB) {
               cerr << "OOB selection prob " << setprecision(10) << selectionProb
                    << " in test " << theSelectors->at(k)->getName()
                    << " at turn " << dec->pParent->getFEN() << endl;
               for (int j = 0; j < numDeltas; j++) {
                  Move move = dec->pParent->consideredMoves->at(j);
                  string sel = (theSelectors->at(k)->apply(dec->pParent, move) ? "*" : " ");
                  cerr << string(move) << sel << " " << mp->probs->at(j) << endl;
               }
            }
            selectionProb = 1.0;
         }


         pf.selectionTests.at(k).uptick(bw, bw*playedMoveAdd, bw*selectionProb, 
                                        bw*selectionProb*(1.0-selectionProb),
                                        bw*IRutil::log2(1.0/selectionProb),
                                        bw*selectionProb*IRutil::log2(1.0/selectionProb),
                                        bw*engineMoveAdd, false);
         pf.selectionTestsWtd.at(k).uptick(bweight, bweight*playedMoveAdd, bweight*selectionProb,
                                           bweight*selectionProb*(1.0-selectionProb),
                                           bweight*IRutil::log2(1.0/selectionProb),
                                           bweight*selectionProb*IRutil::log2(1.0/selectionProb),
                                           bweight*engineMoveAdd, false);
      } 

      if (theDecisions->size() <= 1000) {
         pf.turnsData->push_back(mp);
      } else {
         delete mp;
      }
                                         
   } //end of loop over DecisionInfo. 

   pf.scaledFalloff.update();
   pf.scaledFalloffWtd.update();
   pf.unscaledFalloff.update();
   pf.unscaledFalloffWtd.update();

   pf.scaledFalloffNextTurnCapped.update();
   pf.scaledFalloffNextTurnCappedWtd.update();
   pf.unscaledFalloffNextTurnCapped.update();
   pf.unscaledFalloffNextTurnCappedWtd.update();


   pf.moveMatch.update();   //duplicates moveIndexTests[0]
   pf.equalValueMatch.update();
   pf.playedMoveMatch.update(); //100% on actual but pred is relevant


   pf.moveMatchWtd.update();   //duplicates moveIndexTestsWtd[0]
   pf.equalValueMatchWtd.update();
   pf.playedMoveMatchWtd.update();

   size_t k = 0;
   for (k = 0; k < pf.moveIndexTests.size(); k++) {
      pf.moveIndexTests.at(k).update();
      pf.moveIndexTestsWtd.at(k).update();
   }

   for (k = 0; k < pf.selectionTests.size(); k++) {
      pf.selectionTests.at(k).update();
      pf.selectionTestsWtd.at(k).update();
   }

   //debug
   if (!silent) {
   for (size_t n = 1; n < numInd; n++) {
      indexCumeProj.at(n) += indexCumeProj.at(n-1);
      indexCumeActual.at(n) += indexCumeActual.at(n-1);
   }
   for (size_t m = 0; m < numInd; m += 10) {
      cerr << (m+1) << ": " << indexCumeProj.at(m) << " vs. " << indexCumeActual.at(m) << endl;
   }
   cerr << numInd << ": " << indexCumeProj.at(numInd - 1) << " vs. " << indexCumeActual.at(numInd - 1) << endl;
   }



   //The following use of least-squares may run afoul of heteroskedasticity 
   double indexScore = 0.0; 
   double indexDiff = 0.0;
   double indexMass = 0.0; 
   double indexDiffMass = 0.0;
   double indexScoreInvVar = 0.0; 
   double indexScoreProp = 0.0; 
   double indexScoreWtd = 0.0; 
   double indexDiffWtd = 0.0;
   double indexMassWtd = 0.0; 
   double indexDiffMassWtd = 0.0;
   double indexScoreInvVarWtd = 0.0; 
   double indexScorePropWtd = 0.0; 
   double indexFitPt, indexDiffPt, indexFitPtWtd, indexDiffPtWtd; 
 
   for (int i = 0; i < IRutil::NCUTOFF; i++) { 
      indexFitPt = (*dist)(pf.moveIndexTests.at(i).measuredFreq,
                           pf.moveIndexTests.at(i).projectedFreq);
      indexFitPtWtd = (*dist)(pf.moveIndexTestsWtd.at(i).measuredFreq,
                              pf.moveIndexTestsWtd.at(i).projectedFreq);
      indexDiffPt = pf.moveIndexTests.at(i).measuredFreq - pf.moveIndexTests.at(i).projectedFreq;
      indexDiffPtWtd = pf.moveIndexTestsWtd.at(i).measuredFreq - pf.moveIndexTestsWtd.at(i).projectedFreq;


      indexScore += indexFitPt; 
      indexDiff += indexDiffPt;
      indexMass += indexFitPt*sqrt(pf.moveIndexTests.at(i).measuredFreq);
      indexDiffMass += indexDiffPt*sqrt(pf.moveIndexTests.at(i).measuredFreq * indexDiffPt);
      indexScoreInvVar += IRutil::divifgt0(indexFitPt * pf.totalBootItems,
                                           pf.moveIndexTests.at(i).projectedVariance);
      indexScoreProp += IRutil::divifgt0(indexFitPt * pf.moveIndexTests.at(i).projectedValue,
                                         sqrt(pf.moveIndexTests.at(i).projectedVariance));
      indexScoreWtd += indexFitPtWtd; 
      indexDiffWtd += indexDiffPtWtd;
      indexMassWtd += indexFitPtWtd*sqrt(pf.moveIndexTestsWtd.at(i).measuredFreq);
      indexDiffMassWtd += indexDiffPtWtd;
      indexScoreInvVarWtd += IRutil::divifgt0(indexFitPtWtd * pf.accumWeight, 
                                              pf.moveIndexTestsWtd.at(i).projectedVariance);
      indexScorePropWtd += IRutil::divifgt0(indexFitPtWtd*pf.moveIndexTestsWtd.at(i).projectedValue,
                                            sqrt(pf.moveIndexTestsWtd.at(i).projectedVariance));

   } 

   if (fixDistortion) { 
      indexFitPt = (*dist) 
         (pf.moveIndexTests.at(IRutil::NCUTOFF).projectedFreq,
          pf.moveIndexTests.at(IRutil::NCUTOFF).measuredFreq);
      indexDiffPt = pf.moveIndexTests.at(IRutil::NCUTOFF).measuredFreq
                        - pf.moveIndexTests.at(IRutil::NCUTOFF).projectedFreq;
      indexFitPtWtd = (*dist) 
         (pf.moveIndexTestsWtd.at(IRutil::NCUTOFF).projectedFreq,
          pf.moveIndexTestsWtd.at(IRutil::NCUTOFF).measuredFreq);
      indexDiffPtWtd = pf.moveIndexTestsWtd.at(IRutil::NCUTOFF).measuredFreq
                        - pf.moveIndexTestsWtd.at(IRutil::NCUTOFF).projectedFreq;
      indexScore += indexFitPt; 
      indexDiff += indexDiffPt;
      indexMass += indexFitPt*sqrt(pf.moveIndexTests.at(IRutil::NCUTOFF).measuredFreq);
      indexDiffMass += indexDiffPt*sqrt(pf.moveIndexTests.at(IRutil::NCUTOFF).measuredFreq);
      indexScoreInvVar += IRutil::divifgt0(indexFitPt * pf.totalBootItems, 
                                           pf.moveIndexTests.at(IRutil::NCUTOFF).projectedVariance); 
      indexScoreProp += IRutil::divifgt0(indexFitPt 
                           * pf.moveIndexTests.at(IRutil::NCUTOFF).projectedValue, 
                           sqrt(pf.moveIndexTests.at(IRutil::NCUTOFF).projectedVariance)); 
      indexScoreWtd += indexFitPtWtd; 
      indexDiffWtd += indexDiffPtWtd;
      indexMassWtd += indexFitPtWtd*sqrt(pf.moveIndexTestsWtd.at(IRutil::NCUTOFF).measuredFreq);
      indexDiffMassWtd += indexDiffPtWtd * sqrt(pf.moveIndexTestsWtd.at(IRutil::NCUTOFF).measuredFreq);
      indexScoreInvVarWtd += IRutil::divifgt0(indexFitPtWtd * pf.accumWeight,
                                              pf.moveIndexTestsWtd.at(IRutil::NCUTOFF).projectedVariance);
      indexScorePropWtd += IRutil::divifgt0(indexFitPtWtd
                           * pf.moveIndexTestsWtd.at(IRutil::NCUTOFF).projectedValue,
                             sqrt(pf.moveIndexTestsWtd.at(IRutil::NCUTOFF).projectedVariance));
      pf.indexFit = indexScore / (IRutil::NCUTOFF + 1); 
      pf.indexFitMass = indexMass; 
      pf.indexFitInvVar = indexScoreInvVar / (IRutil::NCUTOFF + 1); 
      pf.indexFitProp = indexScoreProp / (IRutil::NCUTOFF + 1); 
      pf.indexFitWtd = indexScoreWtd / (IRutil::NCUTOFF + 1); 
      pf.indexFitMassWtd = indexMassWtd; 
      pf.indexFitInvVarWtd = indexScoreInvVarWtd / (IRutil::NCUTOFF + 1); 
      pf.indexFitPropWtd = indexScorePropWtd / (IRutil::NCUTOFF + 1); 
   } else { 
      pf.indexFit = indexScore / IRutil::NCUTOFF; 
      pf.indexFitMass = indexMass; 
      pf.indexFitInvVar = indexScoreInvVar / IRutil::NCUTOFF; 
      pf.indexFitProp = indexScoreProp / IRutil::NCUTOFF; 
      pf.indexFitWtd = indexScoreWtd / IRutil::NCUTOFF; 
      pf.indexFitMassWtd = indexMassWtd; 
      pf.indexFitInvVarWtd = indexScoreInvVarWtd / IRutil::NCUTOFF; 
      pf.indexFitPropWtd = indexScorePropWtd / IRutil::NCUTOFF; 
 
   } 
   pf.indexDiff = indexDiff;   //no averaging
   pf.indexDiffMass = indexDiffMass;
   pf.indexDiffWtd = indexDiffWtd;
   pf.indexDiffMassWtd = indexDiffMassWtd;
 
   MOVESDUMP.close();
   return pf; 
} 
 



SimpleStats Trial::perfTestSimple(size_t numIndices, size_t numSelectors, 
                                  vector<MoveSelector*>* mySelectors,
                                  size_t equalTopIndexLimit,
                                  bool unitWeights, bool tmaNN, bool giveFreq) const {
   SimpleStats ss(numIndices, numSelectors);
   if (theDecisions->size() == 0) { return ss; } 
 
   bool weighted = (!unitWeights)  
                       && theSpec.weightMethodChoice != IRfun::UNITWTS; 

   size_t numInd = 1 + IRutil::NCUTOFF;     //will use numIndices later...

   vector<MoveIndexTest> mtv;  //although SimpleStats has indices, variances needed here too
   for (int i = 1; i <= numInd; i++) {      //move indices print as 1-based
      MoveIndexTest mtest(i, 7, 2, 0.0, 0.0, 0.0,    //not giving freq yet
                          true, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1, 1.0, false, false);
      mtv.push_back(mtest);
   }

   //vector<double> probs; 
 
   //Models::MoveProjection mp; 

   for (vector<DecisionInfo*>::const_iterator it = theDecisions->begin(); 
        it != theDecisions->end(); it++) { 

      DecisionInfo* dec = *it; 
      const double bw = dec->getBootWeight();

      if (bw < IRutil::MINPROB) { continue; } //Else---!!

      Models::MoveProjection* mp = Models::getProjection(dec,theSpec,pwv,swv,model,equalTopIndexLimit);
      //probs = Models::getProbs(dec,theSpec,pwv,swv,model); 
      double weight = (weighted ? mp->weight : 1.0);
      double bweight = bw*weight;

//if (bweight < 0.0) { cerr << "Negative weight at turn " << string(*dec) << endl; }
 
      size_t numDeltas = dec->getNumberOfMovesAnalyzed(); 
      size_t pmi = dec->getPlayedMoveIndex(); 

      size_t jd = theScale->getJudgmentDepth();
      size_t useDepth = ((jd == 0 || jd >= dec->dataHighDepth) ? dec->dataHighDepth
                             : (jd <= dec->dataLowDepth ? dec->dataLowDepth : jd));
      ss.accumWeight += bweight;
      const double p0 = mp->probFirstMove;
      const double topProb = mp->probEqualTopMove; 
      //double pj = (pmi != IRutil::playedMoveNotInTopN   //pmi, NOT playedRank
                   //|| (fixDistortion && treatMissAsMoveNN)) ? mp->probs->at(pmi) : 0.0;
      //if (pj < IRutil::MINPROB) { pj = IRutil::MINPROB; }
      const double psf = mp->projFalloffScaled;  //Models::predScaledFalloff(dec, probs,useDepth);

      const double matchAdd = (mp->rankPlayedMove == 0 ? 1.0 : 0.0);
      //const double topAdd = (dec->getEvalP(pmi,useDepth) == dec->getBestEvalP(useDepth) ? 1.0 : 0.0);
      bool etvMatch = dec->getEvalP(pmi, useDepth) == dec->getBestEvalP(useDepth)
                         && mp->rankPlayedMove <= equalTopIndexLimit;
      const double topAdd = (etvMatch ? 1.0 : 0.0);

      ss.scaledFalloffWtd += bweight*mp->playedMoveDeltaScaled;
      ss.scaledFalloffProjWtd += bweight*mp->projFalloffScaled;
      ss.scaledFalloffVarianceProjWtd += bweight*mp->projFalloffVarianceScaled;
      
      //pf.unscaledFalloffWtd.uptick(bweight, bweight*(dec->getUnscaledFalloffAtMaxDepth()), 
                                   //bweight*puf, bweight*pufv, bweight*puls, bweight*pues, false);

      size_t i = 0;
      size_t indexHits = 0;
      while (i < numDeltas && indexHits < numIndices) {
         size_t j = (useDepth >= dec->dataHighDepth ? i : dec->getRankAtDepth(i,useDepth));
                     //theScale->getJudgmentDepth() == 0 ? i : dec->getRankAtDepth(i,useDepth));
         if (j < numIndices) {
            double pri = (i < mp->probs->size() ? mp->probs->at(i) : 0.0);
            ss.indexAccume.at(j) += bweight;
            ss.indexMatchesWtd.at(j) += bweight * (pmi == i ? 1.0 : 0.0);
            ss.indexMatchesProjWtd.at(j) += bweight * pri;
            ss.indexMatchesVarianceProjWtd.at(j) += bweight * pri * (1.0 - pri);
            indexHits++;
         }
         i++;
      }

      ss.equalValueMatchWtd += bweight * topAdd;
      ss.equalValueMatchProjWtd += bweight * topProb;
      ss.equalValueMatchVarianceProjWtd += bweight * topProb * (1.0 - topProb);


      size_t numFilledIndices = (mp->probs->size() >= IRutil::NCUTOFF + 1 ? IRutil::NCUTOFF + 1
                                                                          : mp->probs->size());
      for (size_t k = 0; k < numFilledIndices; k++) {

         if (i >= dec->getNumMovesWithValues()) { continue; }

         double dt = (useDepth >= dec->dataHighDepth   //theScale->getJudgmentDepth() == 0 
                      ? dec->getHighestDepthMoveDeltaScaled(k)
                      : dec->getDeltaScaled(k,useDepth));

         //if (dt > deltaCap) { dt = deltaCap; }  //change from before: not auto-applied to "miss".
         double prk = mp->probs->at(k);
         if (prk < IRutil::MINPROB) { prk = IRutil::MINPROB; }
         double hitAdd = (pmi == k ? 1.0 : 0.0);
         mtv.at(k).uptick(bweight, bweight*hitAdd, bweight*prk, bweight*prk*(1.0-prk),
                          bweight*IRutil::log2(1.0/prk), bweight*prk*IRutil::log2(1.0/prk),
                          bweight*dt, 
                          bweight*dec->getDecMoveSwing(i),
                          bweight*mp->swingsUsed->at(i),
                          bweight*(mp->swingsUsed->at(i) - mp->swingsUsed->at(mp->indexFirstMove)));
                          //bweight*(dec->getSwingScaled(k, dec->userHighDepth, true)));
                          //bweight*dt, bweight*(dec->getSwing(k, dec->userHighDepth, true)));
      }

      const TurnInfo* pTurn = dec->pParent;
      Move pm = pTurn->movePlayed;
      Move em = pTurn->engineMove;
      for (size_t k = 0; k < numSelectors; k++) {
         double playedMoveAdd = (mySelectors->at(k)->apply(pTurn, pm) ? 1.0 : 0.0);
         double engineMoveAdd = (mySelectors->at(k)->apply(pTurn, em) ? 1.0 : 0.0);
         double selectionProb = 0.0;
         size_t i = 0;
         while (i < numDeltas) {
            Move move = pTurn->consideredMoves->at(i);
            if (mySelectors->at(k)->apply(dec->pParent, move)) {
               selectionProb += mp->probs->at(i);  //no test for near-zero needed here
            }
            i++;
         }
         if (selectionProb < IRutil::MINPROB) { selectionProb = IRutil::MINPROB; }
         if (selectionProb > 1.0) {
            if (selectionProb > 1.0 + pTurn->numConsideredMoves * IRutil::MINPROB) {
               cerr << "OOB selection prob " << setprecision(10) << selectionProb
                    << " in test " << mySelectors->at(k)->getName()
                    << " at turn " << dec->pParent->getFEN() << endl;
            }
            selectionProb = 1.0;
         }

         ss.selectorMatchesPlayerWtd.at(k) += bweight * playedMoveAdd;
         ss.selectorMatchesPlayerProjWtd.at(k) += bweight * selectionProb;
         ss.selectorMatchesPlayerProjVarianceWtd.at(k) += bweight * selectionProb * (1.0 - selectionProb);
         ss.selectorMatchesEngineWtd.at(k) += bweight * engineMoveAdd;
      }
      delete(mp);

   } //end of loop over DecisionInfo.  Now update all MoveTests

   size_t k = 0;
   for (k = 0; k < mtv.size(); k++) {
      mtv.at(k).update();
   }

   if (giveFreq) {
      for (size_t j = 0; j < numIndices; j++) {
         ss.indexMatchesWtd.at(j) /= ss.accumWeight;
         ss.indexMatchesProjWtd.at(j) /= ss.accumWeight;
         ss.indexMatchesVarianceProjWtd.at(j) /= (ss.accumWeight * ss.accumWeight);
      }
      ss.equalValueMatchWtd /= ss.accumWeight;
      ss.equalValueMatchProjWtd /= ss.accumWeight;
      ss.equalValueMatchVarianceProjWtd /= (ss.accumWeight * ss.accumWeight);
    
      ss.scaledFalloffWtd /= ss.accumWeight;
      ss.scaledFalloffProjWtd /= ss.accumWeight;
      ss.scaledFalloffVarianceProjWtd /= (ss.accumWeight * ss.accumWeight);
   
      for (k = 0; k < numSelectors; k++) {
         ss.selectorMatchesPlayerWtd.at(k) /= ss.accumWeight;
         ss.selectorMatchesPlayerProjWtd.at(k) /= ss.accumWeight;
         ss.selectorMatchesPlayerProjVarianceWtd.at(k) /= (ss.accumWeight * ss.accumWeight);
         ss.selectorMatchesEngineWtd.at(k) /= ss.accumWeight;
      }
   }


   double indexFitPtWtd; 
   double indexDiffPtWtd;
 
   for (int i = 0; i < IRutil::NCUTOFF; i++) { 
      indexFitPtWtd = (*dist)(mtv.at(i).measuredFreq, mtv.at(i).projectedFreq);
      indexDiffPtWtd = mtv.at(i).measuredFreq - mtv.at(i).projectedFreq;

      ss.indexScoreWtd += indexFitPtWtd; 
      ss.indexDiffWtd += indexDiffPtWtd;
      ss.indexMassWtd += indexFitPtWtd*sqrt(mtv.at(i).measuredFreq);
      ss.indexDiffMassWtd += indexDiffPtWtd*sqrt(mtv.at(i).measuredFreq);
      ss.indexScoreInvVarWtd += IRutil::divifgt0(indexFitPtWtd * ss.accumWeight, 
                                                 mtv.at(i).projectedVariance);
      ss.indexScorePropWtd += IRutil::divifgt0(indexFitPtWtd*mtv.at(i).projectedValue,
                                               sqrt(mtv.at(i).projectedVariance));


   } 

   if (fixDistortion) { 
      indexFitPtWtd = (*dist) 
         (mtv.at(IRutil::NCUTOFF).projectedFreq, mtv.at(IRutil::NCUTOFF).measuredFreq);
      indexDiffPtWtd = mtv.at(IRutil::NCUTOFF).measuredFreq - mtv.at(IRutil::NCUTOFF).projectedFreq;

      ss.indexScoreWtd += indexFitPtWtd; 
      ss.indexDiffWtd += indexDiffPtWtd;
      ss.indexMassWtd += indexFitPtWtd*sqrt(mtv.at(IRutil::NCUTOFF).measuredFreq);
      ss.indexDiffMassWtd += indexDiffPtWtd*sqrt(mtv.at(IRutil::NCUTOFF).measuredFreq);
      ss.indexScoreInvVarWtd += IRutil::divifgt0(indexFitPtWtd * ss.accumWeight,
                                              mtv.at(IRutil::NCUTOFF).projectedVariance);
      ss.indexScorePropWtd += IRutil::divifgt0(indexFitPtWtd
                                 * mtv.at(IRutil::NCUTOFF).projectedValue,
                                 sqrt(mtv.at(IRutil::NCUTOFF).projectedVariance));
      ss.indexFitWtd = ss.indexScoreWtd / (IRutil::NCUTOFF + 1); 
      ss.indexScoreInvVarWtd /= (IRutil::NCUTOFF + 1); 
      ss.indexScorePropWtd /= (IRutil::NCUTOFF + 1);
   } else { 
      ss.indexFitWtd = ss.indexScoreWtd / IRutil::NCUTOFF; 
      ss.indexScoreInvVarWtd /= IRutil::NCUTOFF; 
      ss.indexScorePropWtd /= IRutil::NCUTOFF; 
 
   } 
   
 
   return ss; 
} 

#endif   //end of #ifndef __IR_TRIAL_CPP__ 
 
 
 
//File-------------------TrialFilters.h------------------------------- 
 
#ifndef __IR_TRIAL_FILTERS_H__ 
#define __IR_TRIAL_FILTERS_H__ 
 
 
/** Parent class for all filters that depend on a certain Trial and its spec. 
    Logically abstract, but must have constructor to handle "name" field, 
    since "protected" is 1 level only in C++ and friending would be 
    kludgey here. 
 */ 
class TrialFilter : public virtual TurnFilter { 
 protected: 
   const Trial* theTrial; 
   const bool fixDistortion; 
 public: 
   TrialFilter(const Trial* trial, const int fd, const string& gname) 
         : TurnFilter(gname), theTrial(trial), fixDistortion(fd) { 
      name = gname; 
   } 
   virtual ~TrialFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const = 0; 
   virtual string getDescription() const { 
      return "TrialFilter"; 
   } 
}; 
 
class WeightFilter : public CompareFilter, TrialFilter { 
   const Models::MODEL model; 
 public: 
   WeightFilter(const Trial* trial, const int fd, const Models::MODEL gmodel, 
                const COMPARE comp, const double threshold, const string& name) 
      : TurnFilter(name)
      , CompareFilter(comp, threshold, name)
      , TrialFilter(trial, fd, name)
      , model(gmodel)
     { } 
   virtual ~WeightFilter() { } 
   virtual bool apply(const TurnInfo* const pTurn) const { 
      DecisionInfo* decision = theTrial->translateTurn(pTurn);  //not stored 
      TrialSpec ts = theTrial->getSpec(); 
      double weight=1; 
      //double weight = Models::getWeight(tuple,ts, Models::getProbs(tuple,ts,model)); 
      delete(decision);
      return test(weight); 
   } 
   virtual string getDescription() const { 
      return "Weight " + CompareFilter::getDescription(); 
   } 
}; 
 
class ProbIFilter : public CompareFilter, TrialFilter { 
   const Models::MODEL model; 
   const int index; 
 public: 
   ProbIFilter(const Trial* trial, const int fd, const Models::MODEL gmodel, 
               const COMPARE comp, const double threshold, const int gindex, 
               string name) 
      : TurnFilter(name)
      , CompareFilter(comp, threshold, name)
      , TrialFilter(trial, fd, name)
      , model(gmodel)
      , index(gindex) 
     { } 
   virtual ~ProbIFilter() { } 
   bool apply(const TurnInfo* const pTurn) const { 
      DecisionInfo* decision = theTrial->translateTurn(pTurn);  //not stored 
      TrialSpec ts = theTrial->getSpec(); 
	  //TAMAL: REDO 
      vector<double> probs;  // = Models::getProbs(tuple,ts,model); 
      bool ans; 
      if (probs.size() <= index) { 
         ans = false; 
      } else { 
         ans = test(probs.at(index)); 
      } 
      delete(decision);
      return ans; 
   } 
   virtual string getDescription() const { 
      return "Prob " + IRutil::itoa(index) + " "  
                     + CompareFilter::getDescription(); 
   } 
}; 

class TrialSelector : public virtual MoveSelector {
 protected:
   const Trial* theTrial;
public:
   TrialSelector(const Trial* trial, const bool nullExcludes, const string& gname)
         : MoveSelector(gname,nullExcludes), theTrial(trial) {
      //name = gname;
   }
   virtual ~TrialSelector() { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const = 0;
   virtual string getDescription() const {
      return "TrialSelector";
   }
};



class SwingNegativeSelector : public TrialSelector {
 public:
   SwingNegativeSelector(const Trial* trial, const bool excludeIfNull)
    : MoveSelector("SwingNegative", excludeIfNull)  //any derived of virtual must construct it first
    , TrialSelector(trial, excludeIfNull, "SwingNegative") 
   { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      bool ans = false;
      DecisionInfo* dec = theTrial->translateTurn(pTurn);
      for (int i = 0; i < pTurn->numConsideredMoves; i++) {
         if (pTurn->consideredMoves->at(i) == move) {
            ans = (dec->getSwing(i) < 0);
            break;
         }
      }
      delete(dec);
      return ans;
   }
   virtual string getDescription() const {
      return "Move has negative swing";
   }
};

class SwingNonNegativeSelector : public TrialSelector {
 public:
   SwingNonNegativeSelector(const Trial* trial, const bool excludeIfNull)
    : MoveSelector("SwingNonNegative", excludeIfNull)  //any derived of virtual must construct it first
    , TrialSelector(trial, excludeIfNull, "SwingNonNegative")
   { }
   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      bool ans = false;
      DecisionInfo* dec = theTrial->translateTurn(pTurn);
      for (int i = 0; i < pTurn->numConsideredMoves; i++) {
         if (pTurn->consideredMoves->at(i) == move) {
            ans = (dec->getSwing(i) >= 0);
            break;
         }
      }
      delete(dec);
      return ans;
   }
   virtual string getDescription() const {
      return "Move that has zero or positive swing";
   }
};


class MoveScaledSwingSelector : public CompareSelector, TrialSelector {
   double thresholdSwing;  //can be negative
   size_t targetDepth;     //D in definition of swing, 0 for max
   bool normalize;
 public:
   MoveScaledSwingSelector(const Trial* trial, const COMPARE comp,
                           const double gdelta, const size_t gdepth,
                           const bool norm, bool nullExcludes, const string& name)
    : MoveSelector(name, nullExcludes)
    , CompareSelector(comp, gdelta, nullExcludes, name)
    , TrialSelector(trial, nullExcludes, name)
    , thresholdSwing(gdelta)
    , targetDepth(gdepth)
    , normalize(norm)
   { }
   virtual ~MoveScaledSwingSelector() { }

   virtual bool apply(const TurnInfo* const pTurn, const Move& move) const {
      bool ans = false;
      DecisionInfo* dec = theTrial->translateTurn(pTurn);
      size_t i = 0;
      size_t useDepth = targetDepth;
      while (i < pTurn->numConsideredMoves) {
         if (pTurn->consideredMoves->at(i) == move) {
            if (targetDepth == 0 || targetDepth > pTurn->turnHighestDepth) {
               useDepth = pTurn->turnHighestDepth;
            } else if (targetDepth < pTurn->turnLowestDepth) {
               useDepth = pTurn->turnLowestDepth; //will return 0 for swing
            }
            //double swingToTest = dec->getSwingScaled(i, useDepth, normalize);
            double swingToTest = dec->getDecMoveSwing(i);
            ans = test(swingToTest);
            break;
         }
         i++;
      }
      delete(dec);
      return ans;
   }

   virtual string getDescription() const {
      string dstr = (targetDepth == 0 ? "max" : IRutil::itoa(targetDepth));
      string normstr = (normalize ? "normalized is " : "is ");
      return "Scaled swing " + normstr + relation() + " " + IRutil::ftoa(thresholdSwing)
            + " targeting depth " + dstr;
   }
};

 
#endif    //end of #ifndef __TRIAL_FILTERS_H__ 
 

//File--------------------------multimin.h--------------------------------------

#ifndef __IR_MULTIMIN_H__
#define __IR_MULTIMIN_H__

//By Giulio Bottazzi---see note in "multimin.c"

/*insert GNU extensions*/
//#ifndef _GNU_SOURCE
//#define _GNU_SOURCE
/*in particular, use of NAN extension*/

/* used by <errno.h> */
extern int errno;

/* GSL ----------- */
#include <gsl/gsl_vector.h>
#include <gsl/gsl_multimin.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_blas.h>

/* --------------- */

#define GET(x,i) gsl_vector_get(x,i)
#define SET(x,i,y) gsl_vector_set(x,i,y)

struct multimin_params {
  double step_size;
  double tol;
  unsigned maxiter;
  double epsabs;
  double maxsize;
  unsigned method;
  unsigned verbosity;
};

void
multimin(size_t,double *,double *,
	 const unsigned *,const double *,const double *,
	 void (*) (const size_t,const double *,void *,double *),
	 void (*) (const size_t,const double *, void *,double *),
	 void (*) (const size_t,const double *, void *,double *,double *),
	 void *,
	 const struct multimin_params);

//#endif  //in case of GNU extensions

#endif  //end of multimin.h

//File-------------------multimin.c-------------------------------------

#ifndef __IR_MULTIMIN_H__
#include "multimin.h"
#endif

#ifndef __IR_MULTIMIN_C__
#define __IR_MULTIMIN_C__


/*
  multimin.c (ver. 1.2) -- Interface to GSL multidim. minimization
  Copyright (C) 2002-2014 Giulio Bottazzi

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  (version 2) as published by the Free Software Foundation;
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/ 


/*

multimin is an interface to the various GSL minimization
routines. When invoked, all the information necessary to perform the
minimization are passed as formal parameters. This generate a pretty
long, FORTRAN-like, list of parameters. This approach allows, however,
to black-box, as far as possible, the interior functioning of the
routine from the rest of the program.

Let's analyse the calling convention in details:

multimin(size_t n,double *x,double *fun,
	 unsigned *type,double *xmin,double *xmax,
	 void (*f) (const size_t,const double *,void *,double *),
	 void (* df) (const size_t,const double *, void *,double *),
	 void (* fdf) (const size_t,const double *, void *,double *,double *),
	 void *fparams,
	 const struct multimin_params oparams)

where

--------------------------------------------------------------------
n

INPUT: dimension of the problem, number of independent variables of
the function.

--------------------------------------------------------------------
x

INPUT: pointer to an array of n values x[0],...x[n-1] containing the
initial estimate of the minimum point
OUTPUT: contains the final estimation of the minimum position

--------------------------------------------------------------------
type

a pointer to an array of integer type[1],...,type[n-1] describing the
boundary conditions for the different variables. The problem is solved
as an unconstrained one on a suitably transformed variable y. Possible
values are:

  Interval:                                       Transformation:
  0 unconstrained                                 x=y
  1 semi-closed right half line [ xmin,+infty )   x=xmin+y^2
  2 semi-closed left  half line ( -infty,xmax ]   x=xmax-y^2
  3 closed interval              [ xmin,xmax ]    x=SS+SD*sin(y)
  4 open right half line        ( xmin,+infty )   x=xmin+exp(y)
  5 open left  half line        ( -infty,xmax )   x=xmax-exp(y)
  6 open interval                ( xmin,xmax )    x=SS+SD*tanh(y)

where SS=.5(xmin+xmax) SD=.5(xmax-xmin)

There are also other UNSUPPORTED transformations used in various test
  7 open interval                ( xmin,xmax )    x=SS+SD*(1+y/sqrt(1+y^2))
  8 open right half line        ( xmin,+infty )   x=xmin+.5*(y+sqrt(1+y^2))
  9 open left  half line        ( -infty,xmax )   x=xmax+.5*(y-sqrt(1+y^2))
--------------------------------------------------------------------
xmin 
xmax

pointers to arrays of double containing respectively the lower and
upper boundaries of the different variables. For a given variable,
only the values that are implied by the type of constraints, defined
as in *type, are actually inspected.

--------------------------------------------------------------------
f		 

f calculates the objective function at a specified point x. Its
specification is

void (*f) (const size_t n, const double *x,void *fparams,double *fval)

      n
      INPUT: the number of variables

      x
      INPUT:the point at which the function is required

      fparams
      pointer to a structure containing parameters required by the
      function. If no external parameter are required it can be set to
      NULL.

      fval 
      OUTPUT: the value of the objective function at the current point
      x.

--------------------------------------------------------------------
df		 

df calculates the gradient of the objective function at a specified
point x. Its specification is

void (*df) (const size_t n, const double *x,void *fparams,double *grad)

      n
      INPUT: the number of variables

      x
      INPUT:the point at which the function is required

      fparams
      pointer to a structure containing parameters required by the
      function. If no external parameter are required it can be set to
      NULL.

      grad
      OUTPUT: the values of the gradient of the objective function at
      the current point x are stored in grad[0],...,grad[n-1].

--------------------------------------------------------------------
fdf		 

fdf calculates the value and the gradient of the objective function at
a specified point x. Its specification is

void (*fdf) (const size_t n, const double *x,void *fparams,double *fval,double *grad)

      n
      INPUT: the number of variables

      x
      INPUT:the point at which the function is required

      fparams
      pointer to a structure containing parameters required by the
      function. If no external parameter are required it can be set to
      NULL.

      fval 
      OUTPUT: the value of the objective function at the current point
      x.

      grad
      OUTPUT: the values of the gradient of the objective function at
      the current point x are stored in grad[0],...,grad[n-1].

--------------------------------------------------------------------
fparams

pointer to a structure containing parameters required by the
function. If no external parameter are required it can be set to NULL.

--------------------------------------------------------------------

oparams

structure of the type "multimin_params" containing the optimization
parameters. The members are

      double step_size
          size of the first trial step 

      double tol
          accuracy of the line minimization

      unsigned maxiter
          maximum number of iterations 

      double epsabs
          accuracy of the minimization

      double maxsize;
          final size of the simplex

      unsigned method
          method to use. Possible values are:

          0: Fletcher-Reeves conjugate gradient
          1: Polak-Ribiere conjugate gradient
	  2: Vector Broyden-Fletcher-Goldfarb-Shanno method
	  3: Steepest descent algorithm
          4: Nelder-Mead simplex
	  5: Vector Broyden-Fletcher-Goldfarb-Shanno method ver. 2
	  6: Simplex algorithm of Nelder and Mead ver. 2
	  7: Simplex algorithm of Nelder and Mead: random initialization

      unsigned verbosity
          if greater then 0 print info on intermediate steps

*/

struct g_params {
  size_t n;
  const unsigned *type;
  const double *xmin;
  const double *xmax;
  void (*f) (const size_t,const double *,void *,double *);
  void (* df) (const size_t,const double *, void *,double *);
  void (* fdf) (const size_t,const double *, void *,double *,double *);
  void *fparams;
};


void *multimin_alloc(size_t size){
    void *temp;
    if(!(temp = malloc(size))){
	perror("malloc, memory allocation failed");
	exit(1);
    }
    return temp;
}

static double g(const gsl_vector *y,void *gparams){

  struct g_params *p= (struct g_params *) gparams;
  
  size_t i;
  double dtmp1;
  double res=GSL_NAN;/* the function is forced to return a value */
  

  /* dereference useful stuff */
  const size_t n = p->n;
  const unsigned *type = p->type;
  const double * xmin = p->xmin;
  const double * xmax = p->xmax;

  double *x = (double *) multimin_alloc(sizeof(double)*n);

  /* compute values of x and of dx/dy */
  for(i=0;i<n;i++){
    if(type==NULL)
      x[i]= GET(y,i);
    else
      switch(type[i]){
      case 0:/* (-inf,+inf) */
	x[i]= GET(y,i);
	break;
      case 1:/* [a,+inf) */
	x[i]= xmin[i]+GET(y,i)*GET(y,i);
	break;
      case 2:/* (-inf,a] */
	x[i]= xmax[i]-GET(y,i)*GET(y,i);
	break;
      case 3:/* [a,b] */
	dtmp1 = sin( GET(y,i) );
	x[i]= .5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	break;
      case 4:/* (a,+inf) */
	dtmp1 = exp( GET(y,i) );
	x[i]= xmin[i]+dtmp1;
	break;
      case 5:/* (-inf,a) */
	dtmp1 = -exp( GET(y,i) );
	x[i]= xmax[i]+dtmp1;
	break;
      case 6:/* (a,b) */
	dtmp1 = tanh( GET(y,i) );
	x[i]= .5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	break;
      case 7:/* (a,b) second approach */
	dtmp1 = GET(y,i)/sqrt(1.+GET(y,i)*GET(y,i));
	x[i]= .5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	break;
      case 8:/* (a,+inf) second approach */
	dtmp1 = sqrt(1.+GET(y,i)*GET(y,i));
	x[i]= xmin[i] + .5*(GET(y,i)+dtmp1);
	break;
      case 9:/* (-inf,a) second approach */
	dtmp1 = sqrt(1.+GET(y,i)*GET(y,i));
	x[i]= xmax[i] + .5*(GET(y,i)-dtmp1);
	break;
      }
  }

  p->f(n,x,p->fparams,&res) ;
  free (x);
  return(res);

}

static void dg(const gsl_vector *y,void *gparams,gsl_vector *dg){

  struct g_params *p= (struct g_params *) gparams;
  
  size_t i;
  double dtmp1,dtmp2;
  
  /* dereference useful stuff */
  const size_t n = p->n;
  const unsigned *type = p->type;
  const double * xmin = p->xmin;
  const double * xmax = p->xmax;

  double *x = (double *) multimin_alloc(sizeof(double)*n);
  double *dx = (double *) multimin_alloc(sizeof(double)*n);
  double *df = (double *) multimin_alloc(sizeof(double)*n);
  
  /* compute values of x and of dx/dy */
  for(i=0;i<n;i++){
    if(type==NULL){
      x[i]= GET(y,i);
      dx[i]= 1;
    }
    else
      switch(type[i]){
      case 0:/* (-inf,+inf) */
	x[i]= GET(y,i);
	dx[i]= 1;
	break;
      case 1:/* [a,+inf) */
	x[i]= xmin[i]+GET(y,i)*GET(y,i);
	dx[i]= 2.*GET(y,i);
	break;
      case 2:/* (-inf,a] */
	x[i]= xmax[i]-GET(y,i)*GET(y,i);
	dx[i]= -2.*GET(y,i);
	break;
      case 3:/* [a,b] */
	dtmp1 = sin( GET(y,i) );
	x[i]= .5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	dx[i]= .5*(xmax[i]-xmin[i])*cos(GET(y,i));
	break;
      case 4:/* (a,+inf) */
	dtmp1 = exp( GET(y,i) );
	x[i]= xmin[i]+dtmp1;
	dx[i]= dtmp1;
	break;
      case 5:/* (-inf,a) */
	dtmp1 = -exp( GET(y,i) );
	x[i]= xmax[i]+dtmp1;
	dx[i]= dtmp1;
	break;
      case 6:/* (a,b) */
	dtmp1 = tanh( GET(y,i) );
	dtmp2 = cosh( GET(y,i) );
	x[i]= .5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	dx[i]= .5*(xmax[i]-xmin[i])/(dtmp2*dtmp2);
	break;
      case 7:/* (a,b) second approach */
	dtmp1 = GET(y,i)/sqrt(1.+GET(y,i)*GET(y,i));
	dtmp2 = (1.+GET(y,i)*GET(y,i))*sqrt(1.+GET(y,i)*GET(y,i)) ;
	x[i]= .5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	dx[i]= .5*(xmax[i]-xmin[i])/dtmp2;
	break;
      case 8:/* (a,+inf) second approach */
	dtmp1 = GET(y,i);
	dtmp2 = sqrt(1.+dtmp1*dtmp1);
	x[i]= xmin[i] + .5*(dtmp1+dtmp2);
	dx[i]= .5*(dtmp1+dtmp2)/dtmp2;
	break;
      case 9:/* (-inf,a) second approach */
	dtmp1 = GET(y,i);
	dtmp2 = sqrt(1.+dtmp1*dtmp1);
	x[i]= xmax[i] + .5*(dtmp1-dtmp2);
	dx[i]= .5*(dtmp2-dtmp1)/dtmp2;
	break;
      }
  }
  
  p->df(n,x,p->fparams,df);

  /* debug output; comment out if necessary */
  /*   fprintf(stderr,"#dg: x=( "); */
  /*   for(i=0;i<n;i++) */
  /*     fprintf(stderr,"%f ",GET(x,i)); */
  /*   fprintf(stderr,") dx=( "); */
  /*   for(i=0;i<n;i++) */
  /*     fprintf(stderr,"%f ",GET(dx,i)); */
  /*   fprintf(stderr,") df=( "); */
  /*   for(i=0;i<n;i++) */
  /*     fprintf(stderr,"%f ",GET(dg,i)); */

  for(i=0;i<n;i++){
    SET(dg,i,df[i]*dx[i]);
  }

  /* debug output; comment out if necessary */
  /*   fprintf(stderr,") dg=( "); */
  /*   for(i=0;i<n;i++) */
  /*     fprintf(stderr,"%f ",GET(dg,i)); */
  /*   fprintf(stderr,")\n"); */

  free (x);
  free (dx);
  free (df);

}


static void gdg(const gsl_vector *y,void *gparams,double *g,gsl_vector *dg){

  struct g_params *p= (struct g_params *) gparams;
  
  size_t i;
  double dtmp1,dtmp2;


  /* dereference useful stuff */
  const size_t n = p->n;
  const unsigned *type = p->type;
  const double * xmin = p->xmin;
  const double * xmax = p->xmax;

  double *x = (double *) multimin_alloc(sizeof(double)*n);
  double *dx = (double *) multimin_alloc(sizeof(double)*n);
  double *df = (double *) multimin_alloc(sizeof(double)*n);
  
  /* compute values of x and of dx/dy */
  for(i=0;i<n;i++){
    if(type==NULL){
      x[i]= GET(y,i);
      dx[i]= 1;
    }
    else 
      switch(type[i]){
      case 0:/* (-inf,+inf) */
	x[i]= GET(y,i);
	dx[i]= 1;
	break;
      case 1:/* [a,+inf) */
	x[i]= xmin[i]+GET(y,i)*GET(y,i);
	dx[i]= 2.*GET(y,i);
	break;
      case 2:/* (-inf,a] */
	x[i]= xmax[i]-GET(y,i)*GET(y,i);
	dx[i]= -2.*GET(y,i);
	break;
      case 3:/* [a,b] */
	dtmp1 = sin( GET(y,i) );
	x[i]= .5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	dx[i]= .5*(xmax[i]-xmin[i])*cos(GET(y,i));
	break;
      case 4:/* (a,+inf) */
	dtmp1 = exp( GET(y,i) );
	x[i]= xmin[i]+dtmp1;
	dx[i]= dtmp1;
	break;
      case 5:/* (-inf,a) */
	dtmp1 = -exp( GET(y,i) );
	x[i]= xmax[i]+dtmp1;
	dx[i]= dtmp1;
	break;
      case 6:/* (a,b) */
	dtmp1 = tanh( GET(y,i) );
	dtmp2 = cosh( GET(y,i) );
	x[i]= .5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	dx[i]= .5*(xmax[i]-xmin[i])/(dtmp2*dtmp2);
	break;
      case 7:/* (a,b) second approach */
	dtmp1 = GET(y,i)/sqrt(1.+GET(y,i)*GET(y,i));
	dtmp2 = (1.+GET(y,i)*GET(y,i))*sqrt(1.+GET(y,i)*GET(y,i)) ;
	x[i]= .5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	dx[i]= .5*(xmax[i]-xmin[i])/dtmp2;
	break;
      case 8:/* (a,+inf) second approach */
	dtmp1 = GET(y,i);
	dtmp2 = sqrt(1.+dtmp1*dtmp1);
	x[i]= xmin[i] + .5*(dtmp1+dtmp2);
	dx[i]= .5*(dtmp1+dtmp2)/dtmp2;
	break;
      case 9:/* (-inf,a) second approach */
	dtmp1 = GET(y,i);
	dtmp2 = sqrt(1.+dtmp1*dtmp1);
	x[i]= xmax[i] + .5*(dtmp1-dtmp2);
	dx[i]= .5*(dtmp2-dtmp1)/dtmp2;
	break;
      }
  }

  p->fdf(n,x,p->fparams,g,df);

  /* debug output; comment out if necessary */    
  /*   fprintf(stderr,"#gdg: f=%f x=( ",g); */
  /*   for(i=0;i<n;i++) */
  /*     fprintf(stderr,"%f ",GET(x,i)); */
  /*   fprintf(stderr,") dx=( "); */
  /*   for(i=0;i<n;i++) */
  /*     fprintf(stderr,"%f ",GET(dx,i)); */
  /*   fprintf(stderr,") df=( "); */
  /*   for(i=0;i<n;i++) */
  /*     fprintf(stderr,"%f ",GET(dg,i)); */
  /*   fprintf(stderr,")\n"); */
  
  for(i=0;i<n;i++){
    SET(dg,i,df[i]*dx[i]);
  }
  
  free (x);
  free (dx);
  free (df);
}


/*

n         the dimension of the problem
x         INPUT: initial guess OUTPUT:  minimum point
fun       INPUT: ------------- OUTPUT:  minimum value
type      the types of the boundaries
xmin      the minimum values
xmax      the maximum values
f         the structure of a function
fparams   the parameters of the provided function
oparams   parameters of the optimization

*/


void
multimin(size_t n,double *x,double *fun,
	 const unsigned *type, const double *xmin,const double *xmax,
	 void (*f) (const size_t,const double *,void *,double *),
	 void (* df) (const size_t,const double *, void *,double *),
	 void (* fdf) (const size_t,const double *, void *,double *,double *),
	 void *fparams,
	 const struct multimin_params oparams)
{

  size_t i;
  double dtmp1;

  const gsl_multimin_fdfminimizer_type *Tfdf;
  const gsl_multimin_fminimizer_type *Tf;
  const char *Tname;
  
  gsl_vector * y  = gsl_vector_alloc (n);

  /* set the algorithm */
  switch(oparams.method){
  case 0:/* Fletcher-Reeves conjugate gradient */
    Tfdf = gsl_multimin_fdfminimizer_conjugate_fr;
    Tname = Tfdf->name;
    break;
  case 1:/* Polak-Ribiere conjugate gradient */
    Tfdf = gsl_multimin_fdfminimizer_conjugate_pr;
    Tname = Tfdf->name;
    break;
  case 2:/* Vector Broyden-Fletcher-Goldfarb-Shanno method */
    Tfdf = gsl_multimin_fdfminimizer_vector_bfgs;
    Tname = Tfdf->name;
    break;
  case 3:/* Steepest descent algorithm */
    Tfdf =gsl_multimin_fdfminimizer_steepest_descent;
    Tname = Tfdf->name;
    break;
  case 4:/* Simplex algorithm of Nelder and Mead */
    Tf = gsl_multimin_fminimizer_nmsimplex;
    Tname = Tf->name;
    break;
  case 5:/*  Vector Broyden-Fletcher-Goldfarb-Shanno2 method */
    Tfdf = gsl_multimin_fdfminimizer_vector_bfgs2;
    Tname = Tfdf->name;
    break;
  case 6:/* Simplex algorithm of Nelder and Mead version 2 */
    Tf = gsl_multimin_fminimizer_nmsimplex2;
    Tname = Tf->name;
    break;
  case 7:/* Simplex algorithm of Nelder and Mead: random initialization */
    Tf = gsl_multimin_fminimizer_nmsimplex2rand;
    Tname = Tf->name;
   break;
   
  default:
    fprintf(stderr,"Optimization method not recognized. Specify one of the following:\n\n");

    fprintf(stderr,"0: Fletcher-Reeves conjugate gradient\n");
    fprintf(stderr,"1: Polak-Ribiere conjugate gradient\n");
    fprintf(stderr,"2: Vector Broyden-Fletcher-Goldfarb-Shanno method\n");
    fprintf(stderr,"3: Steepest descent algorithm\n");
    fprintf(stderr,"4: Nelder-Mead simplex\n");
    fprintf(stderr,"5: Vector Broyden-Fletcher-Goldfarb-Shanno method ver. 2\n");
    fprintf(stderr,"6: Simplex algorithm of Nelder and Mead ver. 2\n");
    fprintf(stderr,"7: Simplex algorithm of Nelder and Mead: random initialization\n");
    fprintf(stderr,"or try -h\n");

    exit(EXIT_FAILURE);
  }

  /* --- OUPUT ---------------------------------- */
  if(oparams.verbosity>0){
    fprintf(stderr,"#--- MULTIMIN START\n");
    fprintf(stderr,"#    method                         %s\n",Tname);
    if(oparams.method<4 || oparams.method==5){
      fprintf(stderr,"#    initial step size              %g\n", oparams.step_size);
      fprintf(stderr,"#    line minimization tolerance    %g\n",oparams.tol);
      fprintf(stderr,"#    maximum number of iterations   %u\n",oparams.maxiter);
      fprintf(stderr,"#    precision                      %g\n",oparams.epsabs);
    }
    else{
      fprintf(stderr,"#    maximum number of iterations   %u\n",oparams.maxiter);
      fprintf(stderr,"#    maximum simplex size           %g\n",oparams.maxsize);
    }
  }
  /* -------------------------------------------- */



  /* compute values of y for initial condition */
  for(i=0;i<n;i++){
    if(type==NULL)
      SET(y,i,x[i]);
    else
      switch(type[i]){
      case 0:/* (-inf,+inf) */
	SET(y,i,x[i]);
	break;
      case 1:/* [a,+inf) */
	SET(y,i,sqrt( x[i]-xmin[i] ));
	break;
      case 2:/* (-inf,a] */
	SET(y,i,sqrt( xmax[i]-x[i] ));
	break;
      case 3:/* [a,b] */
	dtmp1 = (xmax[i]>xmin[i]?
		 (2.*x[i]-xmax[i]-xmin[i])/(xmax[i]-xmin[i]) : 0);
	/*       dtmp1 = (2.*x[i]-xmax[i]-xmin[i])/(xmax[i]-xmin[i]); */
	SET(y,i,asin( dtmp1 ));
	break;
      case 4:/* (a,+inf) */
	SET(y,i,log( x[i]-xmin[i] ));
	break;
      case 5:/* (-inf,a) */
	SET(y,i,log( xmax[i]-x[i] ));
	break;
      case 6:/* (a,b) */
	dtmp1 = (2.*x[i]-xmax[i]-xmin[i])/(xmax[i]-xmin[i]);
	SET(y,i,gsl_atanh ( dtmp1 ));
	break;
      case 7:/* (a,b) second approach */
	dtmp1 = (2.*x[i]-xmax[i]-xmin[i])/(xmax[i]-xmin[i]);
	SET(y,i, dtmp1/sqrt(1-dtmp1*dtmp1));
	break;
      case 8:/* (a,+inf) second approach */
	dtmp1 = x[i]-xmin[i];
	SET(y,i, dtmp1-1./(4.*dtmp1));
	break;
      case 9:/* (-inf,a) second approach */
	dtmp1 = xmax[i]-x[i];
	SET(y,i, 1./(4.*dtmp1)-dtmp1);
	break;
      }
  }

  /* --- OUPUT ---------------------------------- */
  if(oparams.verbosity>1){
    fprintf(stderr,"#    - variables initial value and boundaries\n");
    for(i=0;i<n;i++){
      if(type==NULL)
	fprintf(stderr,"#    x[%d]=%e (-inf,+inf) trans 0 -> %e\n",(int) i,x[i],GET(y,i));
      else
	switch(type[i]){
	case 0:/* (-inf,+inf) */
	  fprintf(stderr,"#    x[%d]=%e (-inf,+inf) trans 0 -> %e\n",(int) i,x[i],GET(y,i));
	  break;
	case 1:/* [a,+inf) */
	  fprintf(stderr,"#    x[%d]=%e [%g,+inf) trans 1 -> %e\n",(int) i,x[i],xmin[i],GET(y,i));
	  break;
	case 2:/* (-inf,a] */
	  fprintf(stderr,"#    x[%d]=%e (-inf,%g] trans 2 -> %e\n",(int) i,x[i],xmax[i],GET(y,i));
	  break;
	case 3:/* [a,b] */
	  fprintf(stderr,"#    x[%d]=%e [%g,%g] trans 3 -> %e\n",(int) i,x[i],xmin[i],xmax[i],GET(y,i));
	  break;
	case 4:/* (a,+inf) */
	  fprintf(stderr,"#    x[%d]=%e (%g,+inf) trans 4 -> %e\n",(int) i,x[i],xmin[i],GET(y,i));
	  break;
	case 5:/* (-inf,a) */
	  fprintf(stderr,"#    x[%d]=%e (-inf,%g) trans 5 -> %e\n",(int) i,x[i],xmax[i],GET(y,i));
	  break;
	case 6:/* (a,b) */
	  fprintf(stderr,"#    x[%d]=%e (%g,%g) trans 6 -> %e\n",(int) i,x[i],xmin[i],xmax[i],GET(y,i));
	  break;
	case 7:
	  fprintf(stderr,"#    x[%d]=%e (%g,%g) trans 7 -> %e\n",(int) i,x[i],xmin[i],xmax[i],GET(y,i));
	  break;
	case 8:/* [a,+inf) */
	  fprintf(stderr,"#    x[%d]=%e (%g,+inf) trans 8 -> %e\n",(int) i,x[i],xmin[i],GET(y,i));
	  break;
	case 9:/* [a,+inf) */
	  fprintf(stderr,"#    x[%d]=%e (-inf,%g) trans 9 -> %e\n",(int) i,x[i],xmax[i],GET(y,i));
	  break;
	}
    }
    {
      double res;
      fprintf(stderr,"#    - function initial value\n");
      f(n,x,fparams,&res);
      fprintf(stderr,"#    f=%e\n",res);
    }
  }
  /* -------------------------------------------- */


  if(oparams.method<4 || oparams.method==5){/* methods with derivatives */

    unsigned iter=0;
    int status;
    struct g_params gparams;
    gsl_multimin_function_fdf GdG;
    gsl_multimin_fdfminimizer *s = gsl_multimin_fdfminimizer_alloc (Tfdf,n);

    /* set the parameters of the new function */
    gparams.n       = n;
    gparams.type    = type;
    gparams.xmin    = xmin;
    gparams.xmax    = xmax;
    gparams.f       = f;
    gparams.df      = df;
    gparams.fdf     = fdf;
    gparams.fparams = fparams;
    
    /* set the function to solve */
    GdG.f=g;
    GdG.df=dg;
    GdG.fdf=gdg;
    GdG.n=n;
    GdG.params=(void *) &gparams;

  
    /* initialize minimizer */
    status=gsl_multimin_fdfminimizer_set(s,&GdG,y,oparams.step_size,oparams.tol);  

    if(status)
      {
	fprintf(stderr,"#ERROR: %s\n",gsl_strerror (status));
	exit(EXIT_FAILURE);
      }

    /* +++++++++++++++++++++++++++++++++++++++++++++++ */
    if(oparams.verbosity>2)
      fprintf(stderr,"#    - start minimization \n");
    /* +++++++++++++++++++++++++++++++++++++++++++++++ */
   
    do
      {

	if( ++iter > oparams.maxiter) break;
	
	status = gsl_multimin_fdfminimizer_iterate (s);

	/* +++++++++++++++++++++++++++++++++++++++++++++++ */
	if(oparams.verbosity>2){
	  fprintf(stderr,"#     [%d]",iter);
	  fprintf(stderr," g=%+12.6e  y=( ",s->f);
	  for(i=0;i<n;i++)
	    fprintf(stderr,"%+12.6e ",GET(s->x,i));
	  fprintf(stderr,") dg=( ");
	  for(i=0;i<n;i++)
	    fprintf(stderr,"%+12.6e  ",GET(s->gradient,i));
          fprintf(stderr,") |dg|=%12.6e ",gsl_blas_dnrm2 (s->gradient));
          fprintf(stderr,"|dx|=%12.6e\n",gsl_blas_dnrm2 (s->dx));
	}
	/* +++++++++++++++++++++++++++++++++++++++++++++++ */


	if(status == GSL_ENOPROG){
	  fprintf(stderr,"#    status: %s\n",gsl_strerror (status));
	  break;
	}
	
	if(status){
	  fprintf(stderr,"#WARNING: %s\n", gsl_strerror (status));
	  break;
	}
            
	status = gsl_multimin_test_gradient (s->gradient,oparams.epsabs); 

      }
    while (status == GSL_CONTINUE);

    gsl_vector_memcpy (y,s->x);
    *fun=s->f;
    gsl_multimin_fdfminimizer_free (s);

    /* +++++++++++++++++++++++++++++++++++++++++++++++ */
    if(oparams.verbosity>2){
      fprintf(stderr,"#    - end minimization\n");
      fprintf(stderr,"#    iterations %u\n",iter-1);
    }
    /* +++++++++++++++++++++++++++++++++++++++++++++++ */

  }
  else{ /* methods without derivatives */

    unsigned iter=0;
    int status;
    double size;
    gsl_vector *ss = gsl_vector_alloc (n);
    struct g_params gparams;
    gsl_multimin_function G;
    gsl_multimin_fminimizer *s=gsl_multimin_fminimizer_alloc (Tf,n);

    /* set the parameters of the new function */
    gparams.n       = n;
    gparams.type    = type;
    gparams.xmin    = xmin;
    gparams.xmax    = xmax;
    gparams.f       = f;
    gparams.fparams = fparams;

    /* set the function to solve */
    G.f=g;
    G.n=n;
    G.params=(void *) &gparams;

    /* Initial vertex size vector */
    gsl_vector_set_all (ss,oparams.step_size+oparams.maxsize);

    /* --- OUPUT ---------------------------------- */
    if(oparams.verbosity>0){
      size_t i;
      fprintf(stderr,"#    initial simplex sizes\n");
      fprintf(stderr,"#    ");
      for(i=0;i<n;i++)
	fprintf(stderr," %g", GET(ss,i));
      fprintf(stderr,"\n");
    }
    /* -------------------------------------------- */

    /* Initialize minimizer */ 
    status=gsl_multimin_fminimizer_set(s,&G,y,ss);

    if(status)
      {
	fprintf(stderr,"#ERROR: %s\n",gsl_strerror (status));
	exit(EXIT_FAILURE);
      }

    /* +++++++++++++++++++++++++++++++++++++++++++++++ */
    if(oparams.verbosity>2)
      fprintf(stderr,"#    - start minimization \n");
    /* +++++++++++++++++++++++++++++++++++++++++++++++ */

    do
      {

	if( ++iter > oparams.maxiter) break;

	status = gsl_multimin_fminimizer_iterate(s);
	size = gsl_multimin_fminimizer_size (s);

	/* +++++++++++++++++++++++++++++++++++++++++++++++ */
	if(oparams.verbosity>2){
	  fprintf(stderr,"#    g=%g y=( ",s->fval);
	  for(i=0;i<n;i++)
	    fprintf(stderr,"%g ",GET(s->x,i));
	  fprintf(stderr,") ");
	  fprintf(stderr," simplex size=%g ",size);
	  fprintf(stderr,"\n");
	}
	/* +++++++++++++++++++++++++++++++++++++++++++++++ */

	status=gsl_multimin_test_size (size,oparams.maxsize);
      }
    while (status == GSL_CONTINUE);

    gsl_vector_memcpy (y, s->x);
    *fun=s->fval;
    gsl_multimin_fminimizer_free (s);

    /* +++++++++++++++++++++++++++++++++++++++++++++++ */
    if(oparams.verbosity>2){
      fprintf(stderr,"#    - end minimization\n");
      fprintf(stderr,"#    iterations %u\n",iter-1);
    }
    /* +++++++++++++++++++++++++++++++++++++++++++++++ */

  }

  /* compute values of x */
  for(i=0;i<n;i++){
    if(type==NULL) /* (-inf,+inf) */
      x[i]=GET(y,i);
    else 
      switch(type[i]){
      case 0:/* (-inf,+inf) */
	x[i]=GET(y,i);
	break;
      case 1:/* [a,+inf) */
	x[i]=xmin[i]+GET(y,i)*GET(y,i);
	break;
      case 2:/* (-inf,a] */
	x[i]=xmax[i]-GET(y,i)*GET(y,i);
	break;
      case 3:/* [a,b] */
	dtmp1 = sin( GET(y,i) );
	x[i]=.5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	break;
      case 4:/* (a,+inf) */
	dtmp1 = exp( GET(y,i) );
	x[i]=xmin[i]+dtmp1;
	break;
      case 5:/* (-inf,a) */
	dtmp1 = -exp( GET(y,i) );
	x[i]=xmax[i]+dtmp1;
	break;
      case 6:/* (a,b) */
	dtmp1 = tanh( GET(y,i) );
	x[i]=.5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	break;
      case 7:/* (a,b) second approach */
	dtmp1 = GET(y,i) ;
	dtmp1 = dtmp1/sqrt(1.+dtmp1*dtmp1);
	x[i]=.5*(xmin[i]*(1-dtmp1) +xmax[i]*(1+dtmp1));
	break;
      case 8:/* (a,+inf) second approach */
	dtmp1 = sqrt(1.+GET(y,i)*GET(y,i));
	x[i]= xmin[i] + .5*(dtmp1+GET(y,i));
	break;
      case 9:/* (a,+inf) second approach */
	dtmp1 = sqrt(1.+GET(y,i)*GET(y,i));
	x[i]= xmax[i] + .5*(GET(y,i)-dtmp1);
	break;
      }
  }

  /* --- OUPUT ---------------------------------- */
  if(oparams.verbosity>0){
    for(i=0;i<n;i++)
      fprintf(stderr,"#    %e -> x[%zd]=%e\n",GET(y,i),i,x[i]);
    fprintf(stderr,"#--- MULTIMIN END --- \n");
  }
  /* -------------------------------------------- */


  gsl_vector_free (y);
  
}


#endif   //end of multimin.c by Giulio Bottazzi



//File--------------------------mpfit.h--------------------------------------

#ifndef __IR_MPFIT_H__
#define __IR_MPFIT_H__

//By Craig Markwardt et al.-------see note in mpfit.c


/* 
 * MINPACK-1 Least Squares Fitting Library
 *
 * Original public domain version by B. Garbow, K. Hillstrom, J. More'
 *   (Argonne National Laboratory, MINPACK project, March 1980)
 * 
 * Tranlation to C Language by S. Moshier (moshier.net)
 * 
 * Enhancements and packaging by C. Markwardt
 *   (comparable to IDL fitting routine MPFIT
 *    see http://cow.physics.wisc.edu/~craigm/idl/idl.html)
 */

/* Header file defining constants, data structures and functions of
   mpfit library 
   $Id: mpfit.h,v 1.16 2016/06/02 19:14:16 craigm Exp $
*/


/* This is a C library.  Allow compilation with a C++ compiler */
#ifdef __cplusplus
extern "C" {
#endif

/* MPFIT version string */
#define MPFIT_VERSION "1.3"

/* Definition of a parameter constraint structure */
struct mp_par_struct {
  int fixed;        /* 1 = fixed; 0 = free */
  int limited[2];   /* 1 = low/upper limit; 0 = no limit */
  double limits[2]; /* lower/upper limit boundary value */

  string parname;    /* Name of parameter, or 0 for none */  //KWR edit to string
  double step;      /* Step size for finite difference */
  double relstep;   /* Relative step size for finite difference */
  int side;         /* Sidedness of finite difference derivative 
		        0 - one-sided derivative computed automatically
		        1 - one-sided derivative (f(x+h) - f(x)  )/h
		       -1 - one-sided derivative (f(x)   - f(x-h))/h
		        2 - two-sided derivative (f(x+h) - f(x-h))/(2*h) 
			3 - user-computed analytical derivatives
		    */
  int deriv_debug;  /* Derivative debug mode: 1 = Yes; 0 = No;

                       If yes, compute both analytical and numerical
                       derivatives and print them to the console for
                       comparison.

		       NOTE: when debugging, do *not* set side = 3,
		       but rather to the kind of numerical derivative
		       you want to compare the user-analytical one to
		       (0, 1, -1, or 2).
		    */
  double deriv_reltol; /* Relative tolerance for derivative debug
			  printout */
  double deriv_abstol; /* Absolute tolerance for derivative debug
			  printout */
};

/* Just a placeholder - do not use!! */
typedef void (*mp_iterproc)(void);

/* Definition of MPFIT configuration structure */
struct mp_config_struct {
  /* NOTE: the user may set the value explicitly; OR, if the passed
     value is zero, then the "Default" value will be substituted by
     mpfit(). */
  double ftol;    /* Relative chi-square convergence criterium Default: 1e-10 */
  double xtol;    /* Relative parameter convergence criterium  Default: 1e-10 */
  double gtol;    /* Orthogonality convergence criterium       Default: 1e-10 */
  double epsfcn;  /* Finite derivative step size               Default: MP_MACHEP0 */
  double stepfactor; /* Initial step bound                     Default: 100.0 */
  double covtol;  /* Range tolerance for covariance calculation Default: 1e-14 */
  size_t maxiter;    /* Maximum number of iterations.  If maxiter == MP_NO_ITER,
                     then basic error checking is done, and parameter
                     errors/covariances are estimated based on input
                     parameter values, but no fitting iterations are done. 
		     Default: 200
		  */
#define MP_NO_ITER (-1) /* No iterations, just checking */
  size_t maxfev;     /* Maximum number of function evaluations, or 0 for no limit
		     Default: 0 (no limit) */
  size_t nprint;     /* Default: 1 */
  int douserscale;/* Scale variables by user values?
		     1 = yes, user scale values in diag;
		     0 = no, variables scaled internally (Default) */
  int nofinitecheck; /* Disable check for infinite quantities from user?
			0 = do not perform check (Default)
			1 = perform check 
		     */
  mp_iterproc iterproc; /* Placeholder pointer - must set to 0 */

};

/* Definition of results structure, for when fit completes */
struct mp_result_struct {
  double bestnorm;     /* Final chi^2 */
  double orignorm;     /* Starting value of chi^2 */
  int niter;           /* Number of iterations */
  int nfev;            /* Number of function evaluations */
  int status;          /* Fitting status code */
  
  int npar;            /* Total number of parameters */
  int nfree;           /* Number of free parameters */
  int npegged;         /* Number of pegged parameters */
  int nfunc;           /* Number of residuals (= num. of data points) */

  double *resid;       /* Final residuals
			  nfunc-vector, or 0 if not desired */
  double *xerror;      /* Final parameter uncertainties (1-sigma)
			  npar-vector, or 0 if not desired */
  double *covar;       /* Final parameter covariance matrix
			  npar x npar array, or 0 if not desired */
  char version[20];    /* MPFIT version string */
};  

/* Convenience typedefs */  
typedef struct mp_par_struct mp_par;
typedef struct mp_config_struct mp_config;
typedef struct mp_result_struct mp_result;

/* Enforce type of fitting function */
typedef int (*mp_func)(int m, /* Number of functions (elts of fvec) */
		       int n, /* Number of variables (elts of x) */
		       double *x,      /* I - Parameters */
		       double *fvec,   /* O - function values */
		       double **dvec,  /* O - function derivatives (optional)*/
		       void *private_data); /* I/O - function private data*/

/* Error codes */
#define MP_ERR_INPUT (0)         /* General input parameter error */
#define MP_ERR_NAN (-16)         /* User function produced non-finite values */
#define MP_ERR_FUNC (-17)        /* No user function was supplied */
#define MP_ERR_NPOINTS (-18)     /* No user data points were supplied */
#define MP_ERR_NFREE (-19)       /* No free parameters */
#define MP_ERR_MEMORY (-20)      /* Memory allocation error */
#define MP_ERR_INITBOUNDS (-21)  /* Initial values inconsistent w constraints*/
#define MP_ERR_BOUNDS (-22)      /* Initial constraints inconsistent */
#define MP_ERR_PARAM (-23)       /* General input parameter error */
#define MP_ERR_DOF (-24)         /* Not enough degrees of freedom */

/* Potential success status codes */
#define MP_OK_CHI (1)            /* Convergence in chi-square value */
#define MP_OK_PAR (2)            /* Convergence in parameter value */
#define MP_OK_BOTH (3)           /* Both MP_OK_PAR and MP_OK_CHI hold */
#define MP_OK_DIR (4)            /* Convergence in orthogonality */
#define MP_MAXITER (5)           /* Maximum number of iterations reached */
#define MP_FTOL (6)              /* ftol is too small; no further improvement*/
#define MP_XTOL (7)              /* xtol is too small; no further improvement*/
#define MP_GTOL (8)              /* gtol is too small; no further improvement*/

/* Double precision numeric constants */
#define MP_MACHEP0 2.2204460e-16
#define MP_DWARF   2.2250739e-308
#define MP_GIANT   1.7976931e+308

#if 0
/* Float precision */
#define MP_MACHEP0 1.19209e-07
#define MP_DWARF   1.17549e-38
#define MP_GIANT   3.40282e+38
#endif

#define MP_RDWARF  (sqrt(MP_DWARF*1.5)*10)
#define MP_RGIANT  (sqrt(MP_GIANT)*0.1)


/* External function prototype declarations */
//extern
int mpfit(mp_func funct, int m, int npar,
          double *xall, mp_par *pars, mp_config *config, 
          void *private_data, 
          mp_result *result);



/* C99 uses isfinite() instead of finite() */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#define mpfinite(x) isfinite(x)

/* Microsoft C uses _finite(x) instead of finite(x) */
#elif defined(_MSC_VER) && _MSC_VER
#include <float.h>
#define mpfinite(x) _finite(x)

/* Default is to assume that compiler/library has finite() function */
#else
#define mpfinite(x) finite(x)

#endif

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* MPFIT_H */



//File--------------------------mpfit.c--------------------------------------

#ifndef __IR_MPFIT_H__
#include "mpfit.h"
#endif

#ifndef __IR_MPFIT_C__
#define __IR_MPFIT_C__


/* 
 * MINPACK-1 Least Squares Fitting Library
 *
 * Original public domain version by B. Garbow, K. Hillstrom, J. More'
 *   (Argonne National Laboratory, MINPACK project, March 1980)
 * See the file DISCLAIMER for copyright information.
 * 
 * Tranlation to C Language by S. Moshier (moshier.net)
 * 
 * Enhancements and packaging by C. Markwardt
 *   (comparable to IDL fitting routine MPFIT
 *    see http://cow.physics.wisc.edu/~craigm/idl/idl.html)
 */

/* Main mpfit library routines (double precision) 
   $Id: mpfit.c,v 1.24 2013/04/23 18:37:38 craigm Exp $
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
//#include "mpfit.h"

/* Forward declarations of functions in this module */
static int mp_fdjac2(mp_func funct,
	      int m, int n, int *ifree, int npar, double *x, double *fvec,
	      double *fjac, int ldfjac, double epsfcn,
	      double *wa, void *priv, int *nfev,
	      double *step, double *dstep, int *dside,
	      int *qulimited, double *ulimit,
	      int *ddebug, double *ddrtol, double *ddatol,
	      double *wa2, double **dvecptr);
static void mp_qrfac(int m, int n, double *a, int lda, 
	      int pivot, int *ipvt, int lipvt,
	      double *rdiag, double *acnorm, double *wa);
static void mp_qrsolv(int n, double *r, int ldr, int *ipvt, double *diag,
	       double *qtb, double *x, double *sdiag, double *wa);
static void mp_lmpar(int n, double *r, int ldr, int *ipvt, int *ifree, double *diag,
	      double *qtb, double delta, double *par, double *x,
	      double *sdiag, double *wa1, double *wa2);
static double mp_enorm(int n, double *x);
static double mp_dmax1(double a, double b);
static double mp_dmin1(double a, double b);
static int mp_min0(int a, int b);
static int mp_covar(int n, double *r, int ldr, int *ipvt, double tol, double *wa);

/* Macro to call user function */
#define mp_call(funct, m, n, x, fvec, dvec, priv) (*(funct))(m,n,x,fvec,dvec,priv)

/* Macro to safely allocate memory */
#define mp_malloc(dest,type,size) \
  dest = (type *) malloc( sizeof(type)*size ); \
  if (dest == 0) { \
    info = MP_ERR_MEMORY; \
    goto CLEANUP; \
  } else { \
    int _k; \
    for (_k=0; _k<(size); _k++) dest[_k] = 0; \
  } 

/*
*     **********
*
*     subroutine mpfit
*
*     the purpose of mpfit is to minimize the sum of the squares of
*     m nonlinear functions in n variables by a modification of
*     the levenberg-marquardt algorithm. the user must provide a
*     subroutine which calculates the functions. the jacobian is
*     then calculated by a finite-difference approximation.
*
*     mp_funct funct - function to be minimized
*     int m          - number of data points
*     int npar       - number of fit parameters
*     double *xall   - array of n initial parameter values
*                      upon return, contains adjusted parameter values
*     mp_par *pars   - array of npar structures specifying constraints;
*                      or 0 (null pointer) for unconstrained fitting
*                      [ see README and mpfit.h for definition & use of mp_par]
*     mp_config *config - pointer to structure which specifies the
*                      configuration of mpfit(); or 0 (null pointer)
*                      if the default configuration is to be used.
*                      See README and mpfit.h for definition and use
*                      of config.
*     void *private  - any private user data which is to be passed directly
*                      to funct without modification by mpfit().
*     mp_result *result - pointer to structure, which upon return, contains
*                      the results of the fit.  The user should zero this
*                      structure.  If any of the array values are to be 
*                      returned, the user should allocate storage for them
*                      and assign the corresponding pointer in *result.
*                      Upon return, *result will be updated, and
*                      any of the non-null arrays will be filled.
*
*
* FORTRAN DOCUMENTATION BELOW
*
*
*     the subroutine statement is
*
*	subroutine lmdif(fcn,m,n,x,fvec,ftol,xtol,gtol,maxfev,epsfcn,
*			 diag,mode,factor,nprint,info,nfev,fjac,
*			 ldfjac,ipvt,qtf,wa1,wa2,wa3,wa4)
*
*     where
*
*	fcn is the name of the user-supplied subroutine which
*	  calculates the functions. fcn must be declared
*	  in an external statement in the user calling
*	  program, and should be written as follows.
*
*	  subroutine fcn(m,n,x,fvec,iflag)
*	  integer m,n,iflag
*	  double precision x(n),fvec(m)
*	  ----------
*	  calculate the functions at x and
*	  return this vector in fvec.
*	  ----------
*	  return
*	  end
*
*	  the value of iflag should not be changed by fcn unless
*	  the user wants to terminate execution of lmdif.
*	  in this case set iflag to a negative integer.
*
*	m is a positive integer input variable set to the number
*	  of functions.
*
*	n is a positive integer input variable set to the number
*	  of variables. n must not exceed m.
*
*	x is an array of length n. on input x must contain
*	  an initial estimate of the solution vector. on output x
*	  contains the final estimate of the solution vector.
*
*	fvec is an output array of length m which contains
*	  the functions evaluated at the output x.
*
*	ftol is a nonnegative input variable. termination
*	  occurs when both the actual and predicted relative
*	  reductions in the sum of squares are at most ftol.
*	  therefore, ftol measures the relative error desired
*	  in the sum of squares.
*
*	xtol is a nonnegative input variable. termination
*	  occurs when the relative error between two consecutive
*	  iterates is at most xtol. therefore, xtol measures the
*	  relative error desired in the approximate solution.
*
*	gtol is a nonnegative input variable. termination
*	  occurs when the cosine of the angle between fvec and
*	  any column of the jacobian is at most gtol in absolute
*	  value. therefore, gtol measures the orthogonality
*	  desired between the function vector and the columns
*	  of the jacobian.
*
*	maxfev is a positive integer input variable. termination
*	  occurs when the number of calls to fcn is at least
*	  maxfev by the end of an iteration.
*
*	epsfcn is an input variable used in determining a suitable
*	  step length for the forward-difference approximation. this
*	  approximation assumes that the relative errors in the
*	  functions are of the order of epsfcn. if epsfcn is less
*	  than the machine precision, it is assumed that the relative
*	  errors in the functions are of the order of the machine
*	  precision.
*
*	diag is an array of length n. if mode = 1 (see
*	  below), diag is internally set. if mode = 2, diag
*	  must contain positive entries that serve as
*	  multiplicative scale factors for the variables.
*
*	mode is an integer input variable. if mode = 1, the
*	  variables will be scaled internally. if mode = 2,
*	  the scaling is specified by the input diag. other
*	  values of mode are equivalent to mode = 1.
*
*	factor is a positive input variable used in determining the
*	  initial step bound. this bound is set to the product of
*	  factor and the euclidean norm of diag*x if nonzero, or else
*	  to factor itself. in most cases factor should lie in the
*	  interval (.1,100.). 100. is a generally recommended value.
*
*	nprint is an integer input variable that enables controlled
*	  printing of iterates if it is positive. in this case,
*	  fcn is called with iflag = 0 at the beginning of the first
*	  iteration and every nprint iterations thereafter and
*	  immediately prior to return, with x and fvec available
*	  for printing. if nprint is not positive, no special calls
*	  of fcn with iflag = 0 are made.
*
*	info is an integer output variable. if the user has
*	  terminated execution, info is set to the (negative)
*	  value of iflag. see description of fcn. otherwise,
*	  info is set as follows.
*
*	  info = 0  improper input parameters.
*
*	  info = 1  both actual and predicted relative reductions
*		    in the sum of squares are at most ftol.
*
*	  info = 2  relative error between two consecutive iterates
*		    is at most xtol.
*
*	  info = 3  conditions for info = 1 and info = 2 both hold.
*
*	  info = 4  the cosine of the angle between fvec and any
*		    column of the jacobian is at most gtol in
*		    absolute value.
*
*	  info = 5  number of calls to fcn has reached or
*		    exceeded maxfev.
*
*	  info = 6  ftol is too small. no further reduction in
*		    the sum of squares is possible.
*
*	  info = 7  xtol is too small. no further improvement in
*		    the approximate solution x is possible.
*
*	  info = 8  gtol is too small. fvec is orthogonal to the
*		    columns of the jacobian to machine precision.
*
*	nfev is an integer output variable set to the number of
*	  calls to fcn.
*
*	fjac is an output m by n array. the upper n by n submatrix
*	  of fjac contains an upper triangular matrix r with
*	  diagonal elements of nonincreasing magnitude such that
*
*		 t     t	   t
*		p *(jac *jac)*p = r *r,
*
*	  where p is a permutation matrix and jac is the final
*	  calculated jacobian. column j of p is column ipvt(j)
*	  (see below) of the identity matrix. the lower trapezoidal
*	  part of fjac contains information generated during
*	  the computation of r.
*
*	ldfjac is a positive integer input variable not less than m
*	  which specifies the leading dimension of the array fjac.
*
*	ipvt is an integer output array of length n. ipvt
*	  defines a permutation matrix p such that jac*p = q*r,
*	  where jac is the final calculated jacobian, q is
*	  orthogonal (not stored), and r is upper triangular
*	  with diagonal elements of nonincreasing magnitude.
*	  column j of p is column ipvt(j) of the identity matrix.
*
*	qtf is an output array of length n which contains
*	  the first n elements of the vector (q transpose)*fvec.
*
*	wa1, wa2, and wa3 are work arrays of length n.
*
*	wa4 is a work array of length m.
*
*     subprograms called
*
*	user-supplied ...... fcn
*
*	minpack-supplied ... dpmpar,enorm,fdjac2,lmpar,qrfac
*
*	fortran-supplied ... dabs,dmax1,dmin1,dsqrt,mod
*
*     argonne national laboratory. minpack project. march 1980.
*     burton s. garbow, kenneth e. hillstrom, jorge j. more
*
* ********** */


int mpfit(mp_func funct, int m, int npar,
	  double *xall, mp_par *pars, mp_config *config, void *private_data, 
	  mp_result *result)
{
  mp_config conf;
  int i, j, info, iflag, nfree, npegged, iter;
  int qanylim = 0;

  int ij,jj,l;
  double actred,delta,dirder,fnorm,fnorm1,gnorm, orignorm;
  double par,pnorm,prered,ratio;
  double sum,temp,temp1,temp2,temp3,xnorm, alpha;
  static double one = 1.0;
  static double p1 = 0.1;
  static double p5 = 0.5;
  static double p25 = 0.25;
  static double p75 = 0.75;
  static double p0001 = 1.0e-4;
  static double zero = 0.0;
  int nfev = 0;

  double *step = 0, *dstep = 0, *llim = 0, *ulim = 0;
  int *pfixed = 0, *mpside = 0, *ifree = 0, *qllim = 0, *qulim = 0;
  int *ddebug = 0;
  double *ddrtol = 0, *ddatol = 0;

  double *fvec = 0, *qtf = 0;
  double *x = 0, *xnew = 0, *fjac = 0, *diag = 0;
  double *wa1 = 0, *wa2 = 0, *wa3 = 0, *wa4 = 0;
  double **dvecptr = 0;
  int *ipvt = 0;

  int ldfjac;

  /* Default configuration */
  conf.ftol = 1e-10;
  conf.xtol = 1e-10;
  conf.gtol = 1e-10;
  conf.stepfactor = 100.0;
  conf.nprint = 1;
  conf.epsfcn = MP_MACHEP0;
  conf.maxiter = 200;
  conf.douserscale = 0;
  conf.maxfev = 0;
  conf.covtol = 1e-14;
  conf.nofinitecheck = 0;
  
  if (config) {
    /* Transfer any user-specified configurations */
    if (config->ftol > 0) conf.ftol = config->ftol;
    if (config->xtol > 0) conf.xtol = config->xtol;
    if (config->gtol > 0) conf.gtol = config->gtol;
    if (config->stepfactor > 0) conf.stepfactor = config->stepfactor;
    if (config->nprint >= 0) conf.nprint = config->nprint;
    if (config->epsfcn > 0) conf.epsfcn = config->epsfcn;
    if (config->maxiter > 0) conf.maxiter = config->maxiter;
    if (config->maxiter == MP_NO_ITER) conf.maxiter = 0;
    if (config->douserscale != 0) conf.douserscale = config->douserscale;
    if (config->covtol > 0) conf.covtol = config->covtol;
    if (config->nofinitecheck > 0) conf.nofinitecheck = config->nofinitecheck;
    conf.maxfev = config->maxfev;
  }

  info = MP_ERR_INPUT; /* = 0 */
  iflag = 0;
  nfree = 0;
  npegged = 0;

  /* Basic error checking */
  if (funct == 0) {
    return MP_ERR_FUNC;
  }

  if ((m <= 0) || (xall == 0)) {
    return MP_ERR_NPOINTS;
  }
  
  if (npar <= 0) {
    return MP_ERR_NFREE;
  }

  fnorm = -1.0;
  fnorm1 = -1.0;
  xnorm = -1.0;
  delta = 0.0;

  /* FIXED parameters? */
  mp_malloc(pfixed, int, npar);
  if (pars) for (i=0; i<npar; i++) {
    pfixed[i] = (pars[i].fixed)?1:0;
  }

  /* Finite differencing step, absolute and relative, and sidedness of deriv */
  mp_malloc(step,  double, npar);
  mp_malloc(dstep, double, npar);
  mp_malloc(mpside, int, npar);
  mp_malloc(ddebug, int, npar);
  mp_malloc(ddrtol, double, npar);
  mp_malloc(ddatol, double, npar);
  if (pars) for (i=0; i<npar; i++) {
    step[i] = pars[i].step;
    dstep[i] = pars[i].relstep;
    mpside[i] = pars[i].side;
    ddebug[i] = pars[i].deriv_debug;
    ddrtol[i] = pars[i].deriv_reltol;
    ddatol[i] = pars[i].deriv_abstol;
  }
    
  /* Finish up the free parameters */
  nfree = 0;
  mp_malloc(ifree, int, npar);
  for (i=0, j=0; i<npar; i++) {
    if (pfixed[i] == 0) {
      nfree++;
      ifree[j++] = i;
    }
  }
  if (nfree == 0) {
    info = MP_ERR_NFREE;
    goto CLEANUP;
  }
  
  if (pars) {
    for (i=0; i<npar; i++) {
      if ( (pars[i].limited[0] && (xall[i] < pars[i].limits[0])) ||
	   (pars[i].limited[1] && (xall[i] > pars[i].limits[1])) ) {
	info = MP_ERR_INITBOUNDS;
	goto CLEANUP;
      }
      if ( (pars[i].fixed == 0) && pars[i].limited[0] && pars[i].limited[1] &&
	   (pars[i].limits[0] >= pars[i].limits[1])) {
	info = MP_ERR_BOUNDS;
	goto CLEANUP;
      }
    }

    mp_malloc(qulim, int, nfree);
    mp_malloc(qllim, int, nfree);
    mp_malloc(ulim, double, nfree);
    mp_malloc(llim, double, nfree);

    for (i=0; i<nfree; i++) {
      qllim[i] = pars[ifree[i]].limited[0];
      qulim[i] = pars[ifree[i]].limited[1];
      llim[i]  = pars[ifree[i]].limits[0];
      ulim[i]  = pars[ifree[i]].limits[1];
      if (qllim[i] || qulim[i]) qanylim = 1;
    }
  }

  /* Sanity checking on input configuration */
  if ((npar <= 0) || (conf.ftol <= 0) || (conf.xtol <= 0) ||
      (conf.gtol <= 0) || (conf.maxiter < 0) ||
      (conf.stepfactor <= 0)) {
    info = MP_ERR_PARAM;
    cerr << "npar = " << npar << ", and precsyxg = " << conf.ftol << "," << conf.xtol << "," 
         << conf.gtol << " and maxiter = " << conf.maxiter << ", stepfactor = " << conf.stepfactor << endl;
    goto CLEANUP;
  }

  /* Ensure there are some degrees of freedom */
  if (m < nfree) {
    info = MP_ERR_DOF;
    cerr << "Got m = " << m << " and nfree = " << nfree << " from npar = " << npar << endl;
    goto CLEANUP;
  }

  /* Allocate temporary storage */
  mp_malloc(fvec, double, m);
  mp_malloc(qtf, double, nfree);
  mp_malloc(x, double, nfree);
  mp_malloc(xnew, double, npar);
  mp_malloc(fjac, double, m*nfree);
  ldfjac = m;
  mp_malloc(diag, double, npar);
  mp_malloc(wa1, double, npar);
  mp_malloc(wa2, double, npar);
  mp_malloc(wa3, double, npar);
  mp_malloc(wa4, double, m);
  mp_malloc(ipvt, int, npar);
  mp_malloc(dvecptr, double *, npar);

  /* Evaluate user function with initial parameter values */
  iflag = mp_call(funct, m, npar, xall, fvec, 0, private_data);
  nfev += 1;
  if (iflag < 0) {
    goto CLEANUP;
  }

  fnorm = mp_enorm(m, fvec);
  orignorm = fnorm*fnorm;

  /* Make a new copy */
  for (i=0; i<npar; i++) {
    xnew[i] = xall[i];
  }

  /* Transfer free parameters to 'x' */
  for (i=0; i<nfree; i++) {
    x[i] = xall[ifree[i]];
  }

  /* Initialize Levelberg-Marquardt parameter and iteration counter */

  par = 0.0;
  iter = 1;
  for (i=0; i<nfree; i++) {
    qtf[i] = 0;
  }

  /* Beginning of the outer loop */
 OUTER_LOOP:
  for (i=0; i<nfree; i++) {
    xnew[ifree[i]] = x[i];
  }
  
  /* XXX call iterproc */

  /* Calculate the jacobian matrix */
  iflag = mp_fdjac2(funct, m, nfree, ifree, npar, xnew, fvec, fjac, ldfjac,
		    conf.epsfcn, wa4, private_data, &nfev,
		    step, dstep, mpside, qulim, ulim,
		    ddebug, ddrtol, ddatol, wa2, dvecptr);
  if (iflag < 0) {
    goto CLEANUP;
  }

  /* Determine if any of the parameters are pegged at the limits */
  if (qanylim) {
    for (j=0; j<nfree; j++) {
      int lpegged = (qllim[j] && (x[j] == llim[j]));
      int upegged = (qulim[j] && (x[j] == ulim[j]));
      sum = 0;

      /* If the parameter is pegged at a limit, compute the gradient
	 direction */
      if (lpegged || upegged) {
	ij = j*ldfjac;
	for (i=0; i<m; i++, ij++) {
	  sum += fvec[i] * fjac[ij];
	}
      }
      /* If pegged at lower limit and gradient is toward negative then
	 reset gradient to zero */
      if (lpegged && (sum > 0)) {
	ij = j*ldfjac;
	for (i=0; i<m; i++, ij++) fjac[ij] = 0;
      }
      /* If pegged at upper limit and gradient is toward positive then
	 reset gradient to zero */
      if (upegged && (sum < 0)) {
	ij = j*ldfjac;
	for (i=0; i<m; i++, ij++) fjac[ij] = 0;
      }
    }
  } 

  /* Compute the QR factorization of the jacobian */
  mp_qrfac(m,nfree,fjac,ldfjac,1,ipvt,nfree,wa1,wa2,wa3);

  /*
   *	 on the first iteration and if mode is 1, scale according
   *	 to the norms of the columns of the initial jacobian.
   */
  if (iter == 1) {
    if (conf.douserscale == 0) {
      for (j=0; j<nfree; j++) {
	diag[ifree[j]] = wa2[j];
	if (wa2[j] == zero ) {
	  diag[ifree[j]] = one;
	}
      }
    }

    /*
     *	 on the first iteration, calculate the norm of the scaled x
     *	 and initialize the step bound delta.
     */
    for (j=0; j<nfree; j++ ) {
      wa3[j] = diag[ifree[j]] * x[j];
    }
    
    xnorm = mp_enorm(nfree, wa3);
    delta = conf.stepfactor*xnorm;
    if (delta == zero) delta = conf.stepfactor;
  }

  /*
   *	 form (q transpose)*fvec and store the first n components in
   *	 qtf.
   */
  for (i=0; i<m; i++ ) {
    wa4[i] = fvec[i];
  }

  jj = 0;
  for (j=0; j<nfree; j++ ) {
    temp3 = fjac[jj];
    if (temp3 != zero) {
      sum = zero;
      ij = jj;
      for (i=j; i<m; i++ ) {
	sum += fjac[ij] * wa4[i];
	ij += 1;	/* fjac[i+m*j] */
      }
      temp = -sum / temp3;
      ij = jj;
      for (i=j; i<m; i++ ) {
	wa4[i] += fjac[ij] * temp;
	ij += 1;	/* fjac[i+m*j] */
      }
    }
    fjac[jj] = wa1[j];
    jj += m+1;	/* fjac[j+m*j] */
    qtf[j] = wa4[j];
  }

  /* ( From this point on, only the square matrix, consisting of the
     triangle of R, is needed.) */

  
  if (conf.nofinitecheck) {
    /* Check for overflow.  This should be a cheap test here since FJAC
       has been reduced to a (small) square matrix, and the test is
       O(N^2). */
    int off = 0, nonfinite = 0;

    for (j=0; j<nfree; j++) {
      for (i=0; i<nfree; i++) {
	if (mpfinite(fjac[off+i]) == 0) nonfinite = 1;
      }
      off += ldfjac;
    }

    if (nonfinite) {
      info = MP_ERR_NAN;
      goto CLEANUP;
    }
  }


  /*
   *	 compute the norm of the scaled gradient.
   */
  gnorm = zero;
  if (fnorm != zero) {
    jj = 0;
    for (j=0; j<nfree; j++ ) {
      l = ipvt[j];
      if (wa2[l] != zero) {
	sum = zero;
	ij = jj;
	for (i=0; i<=j; i++ ) {
	  sum += fjac[ij]*(qtf[i]/fnorm);
	  ij += 1; /* fjac[i+m*j] */
	}
	gnorm = mp_dmax1(gnorm,fabs(sum/wa2[l]));
      }
      jj += m;
    }
  }

  /*
   *	 test for convergence of the gradient norm.
   */
  if (gnorm <= conf.gtol) info = MP_OK_DIR;
  if (info != 0) goto L300;
  if (conf.maxiter == 0) {
    info = MP_MAXITER;
    goto L300;
  }

  /*
   *	 rescale if necessary.
   */
  if (conf.douserscale == 0) {
    for (j=0; j<nfree; j++ ) {
      diag[ifree[j]] = mp_dmax1(diag[ifree[j]],wa2[j]);
    }
  }

  /*
   *	 beginning of the inner loop.
   */
 L200:
  /*
   *	    determine the levenberg-marquardt parameter.
   */
  mp_lmpar(nfree,fjac,ldfjac,ipvt,ifree,diag,qtf,delta,&par,wa1,wa2,wa3,wa4);
  /*
   *	    store the direction p and x + p. calculate the norm of p.
   */
  for (j=0; j<nfree; j++ ) {
    wa1[j] = -wa1[j];
  }

  alpha = 1.0;
  if (qanylim == 0) {
    /* No parameter limits, so just move to new position WA2 */
    for (j=0; j<nfree; j++ ) {
      wa2[j] = x[j] + wa1[j];
    }

  } else {
    /* Respect the limits.  If a step were to go out of bounds, then 
     * we should take a step in the same direction but shorter distance.
     * The step should take us right to the limit in that case.
     */
    for (j=0; j<nfree; j++) {
      int lpegged = (qllim[j] && (x[j] <= llim[j]));
      int upegged = (qulim[j] && (x[j] >= ulim[j]));
      int dwa1 = fabs(wa1[j]) > MP_MACHEP0;
      
      if (lpegged && (wa1[j] < 0)) wa1[j] = 0;
      if (upegged && (wa1[j] > 0)) wa1[j] = 0;

      if (dwa1 && qllim[j] && ((x[j] + wa1[j]) < llim[j])) {
	alpha = mp_dmin1(alpha, (llim[j]-x[j])/wa1[j]);
      }
      if (dwa1 && qulim[j] && ((x[j] + wa1[j]) > ulim[j])) {
	alpha = mp_dmin1(alpha, (ulim[j]-x[j])/wa1[j]);
      }
    }
    
    /* Scale the resulting vector, advance to the next position */
    for (j=0; j<nfree; j++) {
      double sgnu, sgnl;
      double ulim1, llim1;

      wa1[j] = wa1[j] * alpha;
      wa2[j] = x[j] + wa1[j];

      /* Adjust the output values.  If the step put us exactly
       * on a boundary, make sure it is exact.
       */
      sgnu = (ulim[j] >= 0) ? (+1) : (-1);
      sgnl = (llim[j] >= 0) ? (+1) : (-1);
      ulim1 = ulim[j]*(1-sgnu*MP_MACHEP0) - ((ulim[j] == 0)?(MP_MACHEP0):0);
      llim1 = llim[j]*(1+sgnl*MP_MACHEP0) + ((llim[j] == 0)?(MP_MACHEP0):0);

      if (qulim[j] && (wa2[j] >= ulim1)) {
	wa2[j] = ulim[j];
      }
      if (qllim[j] && (wa2[j] <= llim1)) {
	wa2[j] = llim[j];
      }
    }

  }

  for (j=0; j<nfree; j++ ) {
    wa3[j] = diag[ifree[j]]*wa1[j];
  }

  pnorm = mp_enorm(nfree,wa3);
  
  /*
   *	    on the first iteration, adjust the initial step bound.
   */
  if (iter == 1) {
    delta = mp_dmin1(delta,pnorm);
  }

  /*
   *	    evaluate the function at x + p and calculate its norm.
   */
  for (i=0; i<nfree; i++) {
    xnew[ifree[i]] = wa2[i];
  }

  iflag = mp_call(funct, m, npar, xnew, wa4, 0, private_data);
  nfev += 1;
  if (iflag < 0) goto L300;

  fnorm1 = mp_enorm(m,wa4);

  /*
   *	    compute the scaled actual reduction.
   */
  actred = -one;
  if ((p1*fnorm1) < fnorm) {
    temp = fnorm1/fnorm;
    actred = one - temp * temp;
  }

  /*
   *	    compute the scaled predicted reduction and
   *	    the scaled directional derivative.
   */
  jj = 0;
  for (j=0; j<nfree; j++ ) {
    wa3[j] = zero;
    l = ipvt[j];
    temp = wa1[l];
    ij = jj;
    for (i=0; i<=j; i++ ) {
      wa3[i] += fjac[ij]*temp;
      ij += 1; /* fjac[i+m*j] */
    }
    jj += m;
  }

  /* Remember, alpha is the fraction of the full LM step actually
   * taken
   */

  temp1 = mp_enorm(nfree,wa3)*alpha/fnorm;
  temp2 = (sqrt(alpha*par)*pnorm)/fnorm;
  prered = temp1*temp1 + (temp2*temp2)/p5;
  dirder = -(temp1*temp1 + temp2*temp2);

  /*
   *	    compute the ratio of the actual to the predicted
   *	    reduction.
   */
  ratio = zero;
  if (prered != zero) {
    ratio = actred/prered;
  }

  /*
   *	    update the step bound.
   */
  
  if (ratio <= p25) {
    if (actred >= zero) {
      temp = p5; 
    } else {
      temp = p5*dirder/(dirder + p5*actred);
    }
    if (((p1*fnorm1) >= fnorm)
	|| (temp < p1) ) {
      temp = p1;
    }
    delta = temp*mp_dmin1(delta,pnorm/p1);
    par = par/temp;
  } else {
    if ((par == zero) || (ratio >= p75) ) {
      delta = pnorm/p5;
      par = p5*par;
    }
  }

  /*
   *	    test for successful iteration.
   */
  if (ratio >= p0001) {
    
    /*
     *	    successful iteration. update x, fvec, and their norms.
     */
    for (j=0; j<nfree; j++ ) {
      x[j] = wa2[j];
      wa2[j] = diag[ifree[j]]*x[j];
    }
    for (i=0; i<m; i++ ) {
      fvec[i] = wa4[i];
    }
    xnorm = mp_enorm(nfree,wa2);
    fnorm = fnorm1;
    iter += 1;
  }
  
  /*
   *	    tests for convergence.
   */
  if ((fabs(actred) <= conf.ftol) && (prered <= conf.ftol) && 
      (p5*ratio <= one) ) {
    info = MP_OK_CHI;
  }
  if (delta <= conf.xtol*xnorm) {
    info = MP_OK_PAR;
  }
  if ((fabs(actred) <= conf.ftol) && (prered <= conf.ftol) && (p5*ratio <= one)
      && ( info == 2) ) {
    info = MP_OK_BOTH;
  }
  if (info != 0) {
    goto L300;
  }
  
  /*
   *	    tests for termination and stringent tolerances.
   */
  if ((conf.maxfev > 0) && (nfev >= conf.maxfev)) {
    /* Too many function evaluations */
    info = MP_MAXITER;
  }
  if (iter >= conf.maxiter) {
    /* Too many iterations */
    info = MP_MAXITER;
  }
  if ((fabs(actred) <= MP_MACHEP0) && (prered <= MP_MACHEP0) && (p5*ratio <= one) ) {
    info = MP_FTOL;
  }
  if (delta <= MP_MACHEP0*xnorm) {
    info = MP_XTOL;
  }
  if (gnorm <= MP_MACHEP0) {
    info = MP_GTOL;
  }
  if (info != 0) {
    goto L300;
  }
  
  /*
   *	    end of the inner loop. repeat if iteration unsuccessful.
   */
  if (ratio < p0001) goto L200;
  /*
   *	 end of the outer loop.
   */
  goto OUTER_LOOP;

 L300:
  /*
   *     termination, either normal or user imposed.
   */
  if (iflag < 0) {
    info = iflag;
  }
  iflag = 0;

  for (i=0; i<nfree; i++) {
    xall[ifree[i]] = x[i];
  }
  
  if ((conf.nprint > 0) && (info > 0)) {
    iflag = mp_call(funct, m, npar, xall, fvec, 0, private_data);
    nfev += 1;
  }

  /* Compute number of pegged parameters */
  npegged = 0;
  if (pars) for (i=0; i<npar; i++) {
    if ((pars[i].limited[0] && (pars[i].limits[0] == xall[i])) ||
	(pars[i].limited[1] && (pars[i].limits[1] == xall[i]))) {
      npegged ++;
    }
  }

  /* Compute and return the covariance matrix and/or parameter errors */
  if (result && (result->covar || result->xerror)) {
    mp_covar(nfree, fjac, ldfjac, ipvt, conf.covtol, wa2);
    
    if (result->covar) {
      /* Zero the destination covariance array */
      for (j=0; j<(npar*npar); j++) result->covar[j] = 0;
      
      /* Transfer the covariance array */
      for (j=0; j<nfree; j++) {
	for (i=0; i<nfree; i++) {
	  result->covar[ifree[j]*npar+ifree[i]] = fjac[j*ldfjac+i];
	}
      }
    }

    if (result->xerror) {
      for (j=0; j<npar; j++) result->xerror[j] = 0;

      for (j=0; j<nfree; j++) {
	double cc = fjac[j*ldfjac+j];
	if (cc > 0) result->xerror[ifree[j]] = sqrt(cc);
      }
    }
  }      

  if (result) {
    strcpy(result->version, MPFIT_VERSION);
    result->bestnorm = mp_dmax1(fnorm,fnorm1);
    result->bestnorm *= result->bestnorm;
    result->orignorm = orignorm;
    result->status   = info;
    result->niter    = iter;
    result->nfev     = nfev;
    result->npar     = npar;
    result->nfree    = nfree;
    result->npegged  = npegged;
    result->nfunc    = m;
    
    /* Copy residuals if requested */
    if (result->resid) {
      for (j=0; j<m; j++) result->resid[j] = fvec[j];
    }
  }


 CLEANUP:
  if (fvec) free(fvec);
  if (qtf)  free(qtf);
  if (x)    free(x);
  if (xnew) free(xnew);
  if (fjac) free(fjac);
  if (diag) free(diag);
  if (wa1)  free(wa1);
  if (wa2)  free(wa2);
  if (wa3)  free(wa3);
  if (wa4)  free(wa4);
  if (ipvt) free(ipvt);
  if (pfixed) free(pfixed);
  if (step) free(step);
  if (dstep) free(dstep);
  if (mpside) free(mpside);
  if (ddebug) free(ddebug);
  if (ddrtol) free(ddrtol);
  if (ddatol) free(ddatol);
  if (ifree) free(ifree);
  if (qllim) free(qllim);
  if (qulim) free(qulim);
  if (llim)  free(llim);
  if (ulim)  free(ulim);
  if (dvecptr) free(dvecptr);

  return info;
}


/************************fdjac2.c*************************/

static 
int mp_fdjac2(mp_func funct,
	      int m, int n, int *ifree, int npar, double *x, double *fvec,
	      double *fjac, int ldfjac, double epsfcn,
	      double *wa, void *priv, int *nfev,
	      double *step, double *dstep, int *dside,
	      int *qulimited, double *ulimit,
	      int *ddebug, double *ddrtol, double *ddatol,
	      double *wa2, double **dvec)
{
/*
*     **********
*
*     subroutine fdjac2
*
*     this subroutine computes a forward-difference approximation
*     to the m by n jacobian matrix associated with a specified
*     problem of m functions in n variables.
*
*     the subroutine statement is
*
*	subroutine fdjac2(fcn,m,n,x,fvec,fjac,ldfjac,iflag,epsfcn,wa)
*
*     where
*
*	fcn is the name of the user-supplied subroutine which
*	  calculates the functions. fcn must be declared
*	  in an external statement in the user calling
*	  program, and should be written as follows.
*
*	  subroutine fcn(m,n,x,fvec,iflag)
*	  integer m,n,iflag
*	  double precision x(n),fvec(m)
*	  ----------
*	  calculate the functions at x and
*	  return this vector in fvec.
*	  ----------
*	  return
*	  end
*
*	  the value of iflag should not be changed by fcn unless
*	  the user wants to terminate execution of fdjac2.
*	  in this case set iflag to a negative integer.
*
*	m is a positive integer input variable set to the number
*	  of functions.
*
*	n is a positive integer input variable set to the number
*	  of variables. n must not exceed m.
*
*	x is an input array of length n.
*
*	fvec is an input array of length m which must contain the
*	  functions evaluated at x.
*
*	fjac is an output m by n array which contains the
*	  approximation to the jacobian matrix evaluated at x.
*
*	ldfjac is a positive integer input variable not less than m
*	  which specifies the leading dimension of the array fjac.
*
*	iflag is an integer variable which can be used to terminate
*	  the execution of fdjac2. see description of fcn.
*
*	epsfcn is an input variable used in determining a suitable
*	  step length for the forward-difference approximation. this
*	  approximation assumes that the relative errors in the
*	  functions are of the order of epsfcn. if epsfcn is less
*	  than the machine precision, it is assumed that the relative
*	  errors in the functions are of the order of the machine
*	  precision.
*
*	wa is a work array of length m.
*
*     subprograms called
*
*	user-supplied ...... fcn
*
*	minpack-supplied ... dpmpar
*
*	fortran-supplied ... dabs,dmax1,dsqrt
*
*     argonne national laboratory. minpack project. march 1980.
*     burton s. garbow, kenneth e. hillstrom, jorge j. more
*
      **********
*/
  int i,j,ij;
  int iflag = 0;
  double eps,h,temp;
  static double zero = 0.0;
  int has_analytical_deriv = 0, has_numerical_deriv = 0;
  int has_debug_deriv = 0;
  
  temp = mp_dmax1(epsfcn,MP_MACHEP0);
  eps = sqrt(temp);
  ij = 0;
  ldfjac = 0;   /* Prevent compiler warning */
  if (ldfjac){} /* Prevent compiler warning */

  for (j=0; j<npar; j++) dvec[j] = 0;

  /* Initialize the Jacobian derivative matrix */
  for (j=0; j<(n*m); j++) fjac[j] = 0;

  /* Check for which parameters need analytical derivatives and which
     need numerical ones */
  for (j=0; j<n; j++) {  /* Loop through free parameters only */
    if (dside && dside[ifree[j]] == 3 && ddebug[ifree[j]] == 0) {
      /* Purely analytical derivatives */
      dvec[ifree[j]] = fjac + j*m;
      has_analytical_deriv = 1;
    } else if (dside && ddebug[ifree[j]] == 1) {
      /* Numerical and analytical derivatives as a debug cross-check */
      dvec[ifree[j]] = fjac + j*m;
      has_analytical_deriv = 1;
      has_numerical_deriv = 1;
      has_debug_deriv = 1;
    } else {
      has_numerical_deriv = 1;
    }
  }

  /* If there are any parameters requiring analytical derivatives,
     then compute them first. */
  if (has_analytical_deriv) {
    iflag = mp_call(funct, m, npar, x, wa, dvec, priv);
    if (nfev) *nfev = *nfev + 1;
    if (iflag < 0 ) goto DONE;
  }

  if (has_debug_deriv) {
    printf("FJAC DEBUG BEGIN\n");
    printf("#  %10s %10s %10s %10s %10s %10s\n", 
	   "IPNT", "FUNC", "DERIV_U", "DERIV_N", "DIFF_ABS", "DIFF_REL");
  }

  /* Any parameters requiring numerical derivatives */
  if (has_numerical_deriv) for (j=0; j<n; j++) {  /* Loop thru free parms */
    int dsidei = (dside)?(dside[ifree[j]]):(0);
    int debug  = ddebug[ifree[j]];
    double dr = ddrtol[ifree[j]], da = ddatol[ifree[j]];
    
    /* Check for debugging */
    if (debug) {
      printf("FJAC PARM %d\n", ifree[j]);
    }

    /* Skip parameters already done by user-computed partials */
    if (dside && dsidei == 3) continue;

    temp = x[ifree[j]];
    h = eps * fabs(temp);
    if (step  &&  step[ifree[j]] > 0) h = step[ifree[j]];
    if (dstep && dstep[ifree[j]] > 0) h = fabs(dstep[ifree[j]]*temp);
    if (h == zero)                    h = eps;

    /* If negative step requested, or we are against the upper limit */
    if ((dside && dsidei == -1) || 
	(dside && dsidei == 0 && 
	 qulimited && ulimit && qulimited[j] && 
	 (temp > (ulimit[j]-h)))) {
      h = -h;
    }

    x[ifree[j]] = temp + h;
    iflag = mp_call(funct, m, npar, x, wa, 0, priv);
    if (nfev) *nfev = *nfev + 1;
    if (iflag < 0 ) goto DONE;
    x[ifree[j]] = temp;

    if (dsidei <= 1) {
      /* COMPUTE THE ONE-SIDED DERIVATIVE */
      if (! debug) {
	/* Non-debug path for speed */
	for (i=0; i<m; i++, ij++) {
	  fjac[ij] = (wa[i] - fvec[i])/h; /* fjac[i+m*j] */
	}
      } else {
	/* Debug path for correctness */
	for (i=0; i<m; i++, ij++) {
	  double fjold = fjac[ij];
	  fjac[ij] = (wa[i] - fvec[i])/h; /* fjac[i+m*j] */
	  if ((da == 0 && dr == 0 && (fjold != 0 || fjac[ij] != 0)) ||
	      ((da != 0 || dr != 0) && (fabs(fjold-fjac[ij]) > da + fabs(fjold)*dr))) {
	    printf("   %10d %10.4g %10.4g %10.4g %10.4g %10.4g\n", 
		   i, fvec[i], fjold, fjac[ij], fjold-fjac[ij], 
		   (fjold == 0)?(0):((fjold-fjac[ij])/fjold));
	  }
	}
      } /* end debugging */

    } else {  /* dside > 2 */
      /* COMPUTE THE TWO-SIDED DERIVATIVE */
      for (i=0; i<m; i++) {
	wa2[i] = wa[i];
      }

      /* Evaluate at x - h */
      x[ifree[j]] = temp - h;
      iflag = mp_call(funct, m, npar, x, wa, 0, priv);
      if (nfev) *nfev = *nfev + 1;
      if (iflag < 0 ) goto DONE;
      x[ifree[j]] = temp;

      /* Now compute derivative as (f(x+h) - f(x-h))/(2h) */
      if (! debug ) {
	/* Non-debug path for speed */
	for (i=0; i<m; i++, ij++) {
	  fjac[ij] = (fjac[ij] - wa[i])/(2*h); /* fjac[i+m*j] */
	}
      } else {
	/* Debug path for correctness */
	for (i=0; i<m; i++, ij++) {
	  double fjold = fjac[ij];
	  fjac[ij] = (wa2[i] - wa[i])/(2*h); /* fjac[i+m*j] */
	  if ((da == 0 && dr == 0 && (fjold != 0 || fjac[ij] != 0)) ||
	      ((da != 0 || dr != 0) && (fabs(fjold-fjac[ij]) > da + fabs(fjold)*dr))) {
	    printf("   %10d %10.4g %10.4g %10.4g %10.4g %10.4g\n", 
		   i, fvec[i], fjold, fjac[ij], fjold-fjac[ij], 
		   (fjold == 0)?(0):((fjold-fjac[ij])/fjold));
	  }
	}
      } /* end debugging */
      
    } /* if (dside > 2) */
  } /* if (has_numerical_derivative) */

  if (has_debug_deriv) {
    printf("FJAC DEBUG END\n");
  }

 DONE:
  if (iflag < 0) return iflag;
  return 0; 
  /*
   *     last card of subroutine fdjac2.
   */
}


/************************qrfac.c*************************/
 
static 
void mp_qrfac(int m, int n, double *a, int lda, 
	      int pivot, int *ipvt, int lipvt,
	      double *rdiag, double *acnorm, double *wa)
{
/*
*     **********
*
*     subroutine qrfac
*
*     this subroutine uses householder transformations with column
*     pivoting (optional) to compute a qr factorization of the
*     m by n matrix a. that is, qrfac determines an orthogonal
*     matrix q, a permutation matrix p, and an upper trapezoidal
*     matrix r with diagonal elements of nonincreasing magnitude,
*     such that a*p = q*r. the householder transformation for
*     column k, k = 1,2,...,min(m,n), is of the form
*
*			    t
*	    i - (1/u(k))*u*u
*
*     where u has zeros in the first k-1 positions. the form of
*     this transformation and the method of pivoting first
*     appeared in the corresponding linpack subroutine.
*
*     the subroutine statement is
*
*	subroutine qrfac(m,n,a,lda,pivot,ipvt,lipvt,rdiag,acnorm,wa)
*
*     where
*
*	m is a positive integer input variable set to the number
*	  of rows of a.
*
*	n is a positive integer input variable set to the number
*	  of columns of a.
*
*	a is an m by n array. on input a contains the matrix for
*	  which the qr factorization is to be computed. on output
*	  the strict upper trapezoidal part of a contains the strict
*	  upper trapezoidal part of r, and the lower trapezoidal
*	  part of a contains a factored form of q (the non-trivial
*	  elements of the u vectors described above).
*
*	lda is a positive integer input variable not less than m
*	  which specifies the leading dimension of the array a.
*
*	pivot is a logical input variable. if pivot is set true,
*	  then column pivoting is enforced. if pivot is set false,
*	  then no column pivoting is done.
*
*	ipvt is an integer output array of length lipvt. ipvt
*	  defines the permutation matrix p such that a*p = q*r.
*	  column j of p is column ipvt(j) of the identity matrix.
*	  if pivot is false, ipvt is not referenced.
*
*	lipvt is a positive integer input variable. if pivot is false,
*	  then lipvt may be as small as 1. if pivot is true, then
*	  lipvt must be at least n.
*
*	rdiag is an output array of length n which contains the
*	  diagonal elements of r.
*
*	acnorm is an output array of length n which contains the
*	  norms of the corresponding columns of the input matrix a.
*	  if this information is not needed, then acnorm can coincide
*	  with rdiag.
*
*	wa is a work array of length n. if pivot is false, then wa
*	  can coincide with rdiag.
*
*     subprograms called
*
*	minpack-supplied ... dpmpar,enorm
*
*	fortran-supplied ... dmax1,dsqrt,min0
*
*     argonne national laboratory. minpack project. march 1980.
*     burton s. garbow, kenneth e. hillstrom, jorge j. more
*
*     **********
*/
  int i,ij,jj,j,jp1,k,kmax,minmn;
  double ajnorm,sum,temp;
  static double zero = 0.0;
  static double one = 1.0;
  static double p05 = 0.05;

  lda = 0;      /* Prevent compiler warning */
  lipvt = 0;    /* Prevent compiler warning */
  if (lda) {}   /* Prevent compiler warning */
  if (lipvt) {} /* Prevent compiler warning */

  /*
   *     compute the initial column norms and initialize several arrays.
   */
  ij = 0;
  for (j=0; j<n; j++) {
    acnorm[j] = mp_enorm(m,&a[ij]);
    rdiag[j] = acnorm[j];
    wa[j] = rdiag[j];
    if (pivot != 0)
      ipvt[j] = j;
    ij += m; /* m*j */
  }
  /*
   *     reduce a to r with householder transformations.
   */
  minmn = mp_min0(m,n);
  for (j=0; j<minmn; j++) {
    if (pivot == 0)
      goto L40;
    /*
     *	 bring the column of largest norm into the pivot position.
     */
    kmax = j;
    for (k=j; k<n; k++)
      {
	if (rdiag[k] > rdiag[kmax])
	  kmax = k;
      }
    if (kmax == j)
      goto L40;
      
    ij = m * j;
    jj = m * kmax;
    for (i=0; i<m; i++)
      {
	temp = a[ij]; /* [i+m*j] */
	a[ij] = a[jj]; /* [i+m*kmax] */
	a[jj] = temp;
	ij += 1;
	jj += 1;
      }
    rdiag[kmax] = rdiag[j];
    wa[kmax] = wa[j];
    k = ipvt[j];
    ipvt[j] = ipvt[kmax];
    ipvt[kmax] = k;
      
  L40:
    /*
     *	 compute the householder transformation to reduce the
     *	 j-th column of a to a multiple of the j-th unit vector.
     */
    jj = j + m*j;
    ajnorm = mp_enorm(m-j,&a[jj]);
    if (ajnorm == zero)
      goto L100;
    if (a[jj] < zero)
      ajnorm = -ajnorm;
    ij = jj;
    for (i=j; i<m; i++)
      {
	a[ij] /= ajnorm;
	ij += 1; /* [i+m*j] */
      }
    a[jj] += one;
    /*
     *	 apply the transformation to the remaining columns
     *	 and update the norms.
     */
    jp1 = j + 1;
    if (jp1 < n)
      {
	for (k=jp1; k<n; k++)
	  {
	    sum = zero;
	    ij = j + m*k;
	    jj = j + m*j;
	    for (i=j; i<m; i++)
	      {
		sum += a[jj]*a[ij];
		ij += 1; /* [i+m*k] */
		jj += 1; /* [i+m*j] */
	      }
	    temp = sum/a[j+m*j];
	    ij = j + m*k;
	    jj = j + m*j;
	    for (i=j; i<m; i++)
	      {
		a[ij] -= temp*a[jj];
		ij += 1; /* [i+m*k] */
		jj += 1; /* [i+m*j] */
	      }
	    if ((pivot != 0) && (rdiag[k] != zero))
	      {
		temp = a[j+m*k]/rdiag[k];
		temp = mp_dmax1( zero, one-temp*temp );
		rdiag[k] *= sqrt(temp);
		temp = rdiag[k]/wa[k];
		if ((p05*temp*temp) <= MP_MACHEP0)
		  {
		    rdiag[k] = mp_enorm(m-j-1,&a[jp1+m*k]);
		    wa[k] = rdiag[k];
		  }
	      }
	  }
      }
      
  L100:
    rdiag[j] = -ajnorm;
  }
  /*
   *     last card of subroutine qrfac.
   */
}

/************************qrsolv.c*************************/

static 
void mp_qrsolv(int n, double *r, int ldr, int *ipvt, double *diag,
	       double *qtb, double *x, double *sdiag, double *wa)
{
/*
*     **********
*
*     subroutine qrsolv
*
*     given an m by n matrix a, an n by n diagonal matrix d,
*     and an m-vector b, the problem is to determine an x which
*     solves the system
*
*	    a*x = b ,	  d*x = 0 ,
*
*     in the least squares sense.
*
*     this subroutine completes the solution of the problem
*     if it is provided with the necessary information from the
*     qr factorization, with column pivoting, of a. that is, if
*     a*p = q*r, where p is a permutation matrix, q has orthogonal
*     columns, and r is an upper triangular matrix with diagonal
*     elements of nonincreasing magnitude, then qrsolv expects
*     the full upper triangle of r, the permutation matrix p,
*     and the first n components of (q transpose)*b. the system
*     a*x = b, d*x = 0, is then equivalent to
*
*		   t	   t
*	    r*z = q *b ,  p *d*p*z = 0 ,
*
*     where x = p*z. if this system does not have full rank,
*     then a least squares solution is obtained. on output qrsolv
*     also provides an upper triangular matrix s such that
*
*	     t	 t		 t
*	    p *(a *a + d*d)*p = s *s .
*
*     s is computed within qrsolv and may be of separate interest.
*
*     the subroutine statement is
*
*	subroutine qrsolv(n,r,ldr,ipvt,diag,qtb,x,sdiag,wa)
*
*     where
*
*	n is a positive integer input variable set to the order of r.
*
*	r is an n by n array. on input the full upper triangle
*	  must contain the full upper triangle of the matrix r.
*	  on output the full upper triangle is unaltered, and the
*	  strict lower triangle contains the strict upper triangle
*	  (transposed) of the upper triangular matrix s.
*
*	ldr is a positive integer input variable not less than n
*	  which specifies the leading dimension of the array r.
*
*	ipvt is an integer input array of length n which defines the
*	  permutation matrix p such that a*p = q*r. column j of p
*	  is column ipvt(j) of the identity matrix.
*
*	diag is an input array of length n which must contain the
*	  diagonal elements of the matrix d.
*
*	qtb is an input array of length n which must contain the first
*	  n elements of the vector (q transpose)*b.
*
*	x is an output array of length n which contains the least
*	  squares solution of the system a*x = b, d*x = 0.
*
*	sdiag is an output array of length n which contains the
*	  diagonal elements of the upper triangular matrix s.
*
*	wa is a work array of length n.
*
*     subprograms called
*
*	fortran-supplied ... dabs,dsqrt
*
*     argonne national laboratory. minpack project. march 1980.
*     burton s. garbow, kenneth e. hillstrom, jorge j. more
*
*     **********
*/
  int i,ij,ik,kk,j,jp1,k,kp1,l,nsing;
  double cosx,cotan,qtbpj,sinx,sum,tanx,temp;
  static double zero = 0.0;
  static double p25 = 0.25;
  static double p5 = 0.5;
  
  /*
   *     copy r and (q transpose)*b to preserve input and initialize s.
   *     in particular, save the diagonal elements of r in x.
   */
  kk = 0;
  for (j=0; j<n; j++) {
    ij = kk;
    ik = kk;
    for (i=j; i<n; i++)
      {
	r[ij] = r[ik];
	ij += 1;   /* [i+ldr*j] */
	ik += ldr; /* [j+ldr*i] */
      }
    x[j] = r[kk];
    wa[j] = qtb[j];
    kk += ldr+1; /* j+ldr*j */
  }

  /*
   *     eliminate the diagonal matrix d using a givens rotation.
   */
  for (j=0; j<n; j++) {
    /*
     *	 prepare the row of d to be eliminated, locating the
     *	 diagonal element using p from the qr factorization.
     */
    l = ipvt[j];
    if (diag[l] == zero)
      goto L90;
    for (k=j; k<n; k++)
      sdiag[k] = zero;
    sdiag[j] = diag[l];
    /*
     *	 the transformations to eliminate the row of d
     *	 modify only a single element of (q transpose)*b
     *	 beyond the first n, which is initially zero.
     */
    qtbpj = zero;
    for (k=j; k<n; k++)
      {
	/*
	 *	    determine a givens rotation which eliminates the
	 *	    appropriate element in the current row of d.
	 */
	if (sdiag[k] == zero)
	  continue;
	kk = k + ldr * k;
	if (fabs(r[kk]) < fabs(sdiag[k]))
	  {
	    cotan = r[kk]/sdiag[k];
	    sinx = p5/sqrt(p25+p25*cotan*cotan);
	    cosx = sinx*cotan;
	  }
	else
	  {
	    tanx = sdiag[k]/r[kk];
	    cosx = p5/sqrt(p25+p25*tanx*tanx);
	    sinx = cosx*tanx;
	  }
	/*
	 *	    compute the modified diagonal element of r and
	 *	    the modified element of ((q transpose)*b,0).
	 */
	r[kk] = cosx*r[kk] + sinx*sdiag[k];
	temp = cosx*wa[k] + sinx*qtbpj;
	qtbpj = -sinx*wa[k] + cosx*qtbpj;
	wa[k] = temp;
	/*
	 *	    accumulate the tranformation in the row of s.
	 */
	kp1 = k + 1;
	if (n > kp1)
	  {
	    ik = kk + 1;
	    for (i=kp1; i<n; i++)
	      {
		temp = cosx*r[ik] + sinx*sdiag[i];
		sdiag[i] = -sinx*r[ik] + cosx*sdiag[i];
		r[ik] = temp;
		ik += 1; /* [i+ldr*k] */
	      }
	  }
      }
  L90:
    /*
     *	 store the diagonal element of s and restore
     *	 the corresponding diagonal element of r.
     */
    kk = j + ldr*j;
    sdiag[j] = r[kk];
    r[kk] = x[j];
  }
  /*
   *     solve the triangular system for z. if the system is
   *     singular, then obtain a least squares solution.
   */
  nsing = n;
  for (j=0; j<n; j++) {
    if ((sdiag[j] == zero) && (nsing == n))
      nsing = j;
    if (nsing < n)
      wa[j] = zero;
  }
  if (nsing < 1)
    goto L150;
  
  for (k=0; k<nsing; k++) {
    j = nsing - k - 1;
    sum = zero;
    jp1 = j + 1;
    if (nsing > jp1)
      {
	ij = jp1 + ldr * j;
	for (i=jp1; i<nsing; i++)
	  {
	    sum += r[ij]*wa[i];
	    ij += 1; /* [i+ldr*j] */
	  }
      }
    wa[j] = (wa[j] - sum)/sdiag[j];
  }
 L150:
  /*
   *     permute the components of z back to components of x.
   */
  for (j=0; j<n; j++) {
    l = ipvt[j];
    x[l] = wa[j];
  }
  /*
   *     last card of subroutine qrsolv.
   */
}

/************************lmpar.c*************************/

static 
void mp_lmpar(int n, double *r, int ldr, int *ipvt, int *ifree, double *diag,
	      double *qtb, double delta, double *par, double *x,
	      double *sdiag, double *wa1, double *wa2) 
{
  /*     **********
   *
   *     subroutine lmpar
   *
   *     given an m by n matrix a, an n by n nonsingular diagonal
   *     matrix d, an m-vector b, and a positive number delta,
   *     the problem is to determine a value for the parameter
   *     par such that if x solves the system
   *
   *	    a*x = b ,	  sqrt(par)*d*x = 0 ,
   *
   *     in the least squares sense, and dxnorm is the euclidean
   *     norm of d*x, then either par is zero and
   *
   *	    (dxnorm-delta) .le. 0.1*delta ,
   *
   *     or par is positive and
   *
   *	    abs(dxnorm-delta) .le. 0.1*delta .
   *
   *     this subroutine completes the solution of the problem
   *     if it is provided with the necessary information from the
   *     qr factorization, with column pivoting, of a. that is, if
   *     a*p = q*r, where p is a permutation matrix, q has orthogonal
   *     columns, and r is an upper triangular matrix with diagonal
   *     elements of nonincreasing magnitude, then lmpar expects
   *     the full upper triangle of r, the permutation matrix p,
   *     and the first n components of (q transpose)*b. on output
   *     lmpar also provides an upper triangular matrix s such that
   *
   *	     t	 t		     t
   *	    p *(a *a + par*d*d)*p = s *s .
   *
   *     s is employed within lmpar and may be of separate interest.
   *
   *     only a few iterations are generally needed for convergence
   *     of the algorithm. if, however, the limit of 10 iterations
   *     is reached, then the output par will contain the best
   *     value obtained so far.
   *
   *     the subroutine statement is
   *
   *	subroutine lmpar(n,r,ldr,ipvt,diag,qtb,delta,par,x,sdiag,
   *			 wa1,wa2)
   *
   *     where
   *
   *	n is a positive integer input variable set to the order of r.
   *
   *	r is an n by n array. on input the full upper triangle
   *	  must contain the full upper triangle of the matrix r.
   *	  on output the full upper triangle is unaltered, and the
   *	  strict lower triangle contains the strict upper triangle
   *	  (transposed) of the upper triangular matrix s.
   *
   *	ldr is a positive integer input variable not less than n
   *	  which specifies the leading dimension of the array r.
   *
   *	ipvt is an integer input array of length n which defines the
   *	  permutation matrix p such that a*p = q*r. column j of p
   *	  is column ipvt(j) of the identity matrix.
   *
   *	diag is an input array of length n which must contain the
   *	  diagonal elements of the matrix d.
   *
   *	qtb is an input array of length n which must contain the first
   *	  n elements of the vector (q transpose)*b.
   *
   *	delta is a positive input variable which specifies an upper
   *	  bound on the euclidean norm of d*x.
   *
   *	par is a nonnegative variable. on input par contains an
   *	  initial estimate of the levenberg-marquardt parameter.
   *	  on output par contains the final estimate.
   *
   *	x is an output array of length n which contains the least
   *	  squares solution of the system a*x = b, sqrt(par)*d*x = 0,
   *	  for the output par.
   *
   *	sdiag is an output array of length n which contains the
   *	  diagonal elements of the upper triangular matrix s.
   *
   *	wa1 and wa2 are work arrays of length n.
   *
   *     subprograms called
   *
   *	minpack-supplied ... dpmpar,mp_enorm,qrsolv
   *
   *	fortran-supplied ... dabs,mp_dmax1,dmin1,dsqrt
   *
   *     argonne national laboratory. minpack project. march 1980.
   *     burton s. garbow, kenneth e. hillstrom, jorge j. more
   *
   *     **********
   */
  int i,iter,ij,jj,j,jm1,jp1,k,l,nsing;
  double dxnorm,fp,gnorm,parc,parl,paru;
  double sum,temp;
  static double zero = 0.0;
  /* static double one = 1.0; */
  static double p1 = 0.1;
  static double p001 = 0.001;
  
  /*
   *     compute and store in x the gauss-newton direction. if the
   *     jacobian is rank-deficient, obtain a least squares solution.
   */
  nsing = n;
  jj = 0;
  for (j=0; j<n; j++) {
    wa1[j] = qtb[j];
    if ((r[jj] == zero) && (nsing == n))
      nsing = j;
    if (nsing < n)
      wa1[j] = zero;
    jj += ldr+1; /* [j+ldr*j] */
  }

  if (nsing >= 1) {
    for (k=0; k<nsing; k++)
      {
	j = nsing - k - 1;
	wa1[j] = wa1[j]/r[j+ldr*j];
	temp = wa1[j];
	jm1 = j - 1;
	if (jm1 >= 0)
	  {
	    ij = ldr * j;
	    for (i=0; i<=jm1; i++)
	      {
		wa1[i] -= r[ij]*temp;
		ij += 1;
	      }
	  }
      }
  }
  
  for (j=0; j<n; j++) {
    l = ipvt[j];
    x[l] = wa1[j];
  }
  /*
   *     initialize the iteration counter.
   *     evaluate the function at the origin, and test
   *     for acceptance of the gauss-newton direction.
   */
  iter = 0;
  for (j=0; j<n; j++)
    wa2[j] = diag[ifree[j]]*x[j];
  dxnorm = mp_enorm(n,wa2);
  fp = dxnorm - delta;
  if (fp <= p1*delta) {
    goto L220;
  }
  /*
   *     if the jacobian is not rank deficient, the newton
   *     step provides a lower bound, parl, for the zero of
   *     the function. otherwise set this bound to zero.
   */
  parl = zero;
  if (nsing >= n) {
    for (j=0; j<n; j++)
      {
	l = ipvt[j];
	wa1[j] = diag[ifree[l]]*(wa2[l]/dxnorm);
      }
    jj = 0;
    for (j=0; j<n; j++)
      {
	sum = zero;
	jm1 = j - 1;
	if (jm1 >= 0)
	  {
	    ij = jj;
	    for (i=0; i<=jm1; i++)
	      {
		sum += r[ij]*wa1[i];
		ij += 1;
	      }
	  }
	wa1[j] = (wa1[j] - sum)/r[j+ldr*j];
	jj += ldr; /* [i+ldr*j] */
      }
    temp = mp_enorm(n,wa1);
    parl = ((fp/delta)/temp)/temp;
  }
  /*
   *     calculate an upper bound, paru, for the zero of the function.
   */
  jj = 0;
  for (j=0; j<n; j++) {
    sum = zero;
    ij = jj;
    for (i=0; i<=j; i++)
      {
	sum += r[ij]*qtb[i];
	ij += 1;
      }
    l = ipvt[j];
    wa1[j] = sum/diag[ifree[l]];
    jj += ldr; /* [i+ldr*j] */
  }
  gnorm = mp_enorm(n,wa1);
  paru = gnorm/delta;
  if (paru == zero)
    paru = MP_DWARF/mp_dmin1(delta,p1);
  /*
   *     if the input par lies outside of the interval (parl,paru),
   *     set par to the closer endpoint.
   */
  *par = mp_dmax1( *par,parl);
  *par = mp_dmin1( *par,paru);
  if (*par == zero)
    *par = gnorm/dxnorm;

  /*
   *     beginning of an iteration.
   */
 L150:
  iter += 1;
  /*
   *	 evaluate the function at the current value of par.
   */
  if (*par == zero)
    *par = mp_dmax1(MP_DWARF,p001*paru);
  temp = sqrt( *par );
  for (j=0; j<n; j++)
    wa1[j] = temp*diag[ifree[j]];
  mp_qrsolv(n,r,ldr,ipvt,wa1,qtb,x,sdiag,wa2);
  for (j=0; j<n; j++)
    wa2[j] = diag[ifree[j]]*x[j];
  dxnorm = mp_enorm(n,wa2);
  temp = fp;
  fp = dxnorm - delta;
  /*
   *	 if the function is small enough, accept the current value
   *	 of par. also test for the exceptional cases where parl
   *	 is zero or the number of iterations has reached 10.
   */
  if ((fabs(fp) <= p1*delta)
      || ((parl == zero) && (fp <= temp) && (temp < zero))
      || (iter == 10))
    goto L220;
  /*
   *	 compute the newton correction.
   */
  for (j=0; j<n; j++) {
    l = ipvt[j];
    wa1[j] = diag[ifree[l]]*(wa2[l]/dxnorm);
  }
  jj = 0;
  for (j=0; j<n; j++) {
    wa1[j] = wa1[j]/sdiag[j];
    temp = wa1[j];
    jp1 = j + 1;
    if (jp1 < n)
      {
	ij = jp1 + jj;
	for (i=jp1; i<n; i++)
	  {
	    wa1[i] -= r[ij]*temp;
	    ij += 1; /* [i+ldr*j] */
	  }
      }
    jj += ldr; /* ldr*j */
  }
  temp = mp_enorm(n,wa1);
  parc = ((fp/delta)/temp)/temp;
  /*
   *	 depending on the sign of the function, update parl or paru.
   */
  if (fp > zero)
    parl = mp_dmax1(parl, *par);
  if (fp < zero)
    paru = mp_dmin1(paru, *par);
  /*
   *	 compute an improved estimate for par.
   */
  *par = mp_dmax1(parl, *par + parc);
  /*
   *	 end of an iteration.
   */
  goto L150;
  
 L220:
  /*
   *     termination.
   */
  if (iter == 0)
    *par = zero;
  /*
   *     last card of subroutine lmpar.
   */
}


/************************enorm.c*************************/
 
static 
double mp_enorm(int n, double *x) 
{
  /*
   *     **********
   *
   *     function enorm
   *
   *     given an n-vector x, this function calculates the
   *     euclidean norm of x.
   *
   *     the euclidean norm is computed by accumulating the sum of
   *     squares in three different sums. the sums of squares for the
   *     small and large components are scaled so that no overflows
   *     occur. non-destructive underflows are permitted. underflows
   *     and overflows do not occur in the computation of the unscaled
   *     sum of squares for the intermediate components.
   *     the definitions of small, intermediate and large components
   *     depend on two constants, rdwarf and rgiant. the main
   *     restrictions on these constants are that rdwarf**2 not
   *     underflow and rgiant**2 not overflow. the constants
   *     given here are suitable for every known computer.
   *
   *     the function statement is
   *
   *	double precision function enorm(n,x)
   *
   *     where
   *
   *	n is a positive integer input variable.
   *
   *	x is an input array of length n.
   *
   *     subprograms called
   *
   *	fortran-supplied ... dabs,dsqrt
   *
   *     argonne national laboratory. minpack project. march 1980.
   *     burton s. garbow, kenneth e. hillstrom, jorge j. more
   *
   *     **********
   */
  int i;
  double agiant,floatn,s1,s2,s3,xabs,x1max,x3max;
  double ans, temp;
  double rdwarf = MP_RDWARF;
  double rgiant = MP_RGIANT;
  static double zero = 0.0;
  static double one = 1.0;
  
  s1 = zero;
  s2 = zero;
  s3 = zero;
  x1max = zero;
  x3max = zero;
  floatn = n;
  agiant = rgiant/floatn;
  
  for (i=0; i<n; i++) {
    xabs = fabs(x[i]);
    if ((xabs > rdwarf) && (xabs < agiant))
      {
	/*
	 *	    sum for intermediate components.
	 */
	s2 += xabs*xabs;
	continue;
      }
      
    if (xabs > rdwarf)
      {
	/*
	 *	       sum for large components.
	 */
	if (xabs > x1max)
	  {
	    temp = x1max/xabs;
	    s1 = one + s1*temp*temp;
	    x1max = xabs;
	  }
	else
	  {
	    temp = xabs/x1max;
	    s1 += temp*temp;
	  }
	continue;
      }
    /*
     *	       sum for small components.
     */
    if (xabs > x3max)
      {
	temp = x3max/xabs;
	s3 = one + s3*temp*temp;
	x3max = xabs;
      }
    else	
      {
	if (xabs != zero)
	  {
	    temp = xabs/x3max;
	    s3 += temp*temp;
	  }
      }
  }
  /*
   *     calculation of norm.
   */
  if (s1 != zero) {
    temp = s1 + (s2/x1max)/x1max;
    ans = x1max*sqrt(temp);
    return(ans);
  }
  if (s2 != zero) {
    if (s2 >= x3max)
      temp = s2*(one+(x3max/s2)*(x3max*s3));
    else
      temp = x3max*((s2/x3max)+(x3max*s3));
    ans = sqrt(temp);
  }
  else
    {
      ans = x3max*sqrt(s3);
    }
  return(ans);
  /*
   *     last card of function enorm.
   */
}

/************************lmmisc.c*************************/

static 
double mp_dmax1(double a, double b) 
{
  if (a >= b)
    return(a);
  else
    return(b);
}

static 
double mp_dmin1(double a, double b)
{
  if (a <= b)
    return(a);
  else
    return(b);
}

static 
int mp_min0(int a, int b)
{
  if (a <= b)
    return(a);
  else
    return(b);
}

/************************covar.c*************************/
/*
c     **********
c
c     subroutine covar
c
c     given an m by n matrix a, the problem is to determine
c     the covariance matrix corresponding to a, defined as
c
c                    t
c           inverse(a *a) .
c
c     this subroutine completes the solution of the problem
c     if it is provided with the necessary information from the
c     qr factorization, with column pivoting, of a. that is, if
c     a*p = q*r, where p is a permutation matrix, q has orthogonal
c     columns, and r is an upper triangular matrix with diagonal
c     elements of nonincreasing magnitude, then covar expects
c     the full upper triangle of r and the permutation matrix p.
c     the covariance matrix is then computed as
c
c                      t     t
c           p*inverse(r *r)*p  .
c
c     if a is nearly rank deficient, it may be desirable to compute
c     the covariance matrix corresponding to the linearly independent
c     columns of a. to define the numerical rank of a, covar uses
c     the tolerance tol. if l is the largest integer such that
c
c           abs(r(l,l)) .gt. tol*abs(r(1,1)) ,
c
c     then covar computes the covariance matrix corresponding to
c     the first l columns of r. for k greater than l, column
c     and row ipvt(k) of the covariance matrix are set to zero.
c
c     the subroutine statement is
c
c       subroutine covar(n,r,ldr,ipvt,tol,wa)
c
c     where
c
c       n is a positive integer input variable set to the order of r.
c
c       r is an n by n array. on input the full upper triangle must
c         contain the full upper triangle of the matrix r. on output
c         r contains the square symmetric covariance matrix.
c
c       ldr is a positive integer input variable not less than n
c         which specifies the leading dimension of the array r.
c
c       ipvt is an integer input array of length n which defines the
c         permutation matrix p such that a*p = q*r. column j of p
c         is column ipvt(j) of the identity matrix.
c
c       tol is a nonnegative input variable used to define the
c         numerical rank of a in the manner described above.
c
c       wa is a work array of length n.
c
c     subprograms called
c
c       fortran-supplied ... dabs
c
c     argonne national laboratory. minpack project. august 1980.
c     burton s. garbow, kenneth e. hillstrom, jorge j. more
c
c     **********
*/

static 
int mp_covar(int n, double *r, int ldr, int *ipvt, double tol, double *wa)
{
  int i, ii, j, jj, k, l;
  int kk, kj, ji, j0, k0, jj0;
  int sing;
  double one = 1.0, temp, tolr, zero = 0.0;

  /*
   * form the inverse of r in the full upper triangle of r.
   */

#if 0
  for (j=0; j<n; j++) {
    for (i=0; i<n; i++) {
      printf("%f ", r[j*ldr+i]);
    }
    printf("\n");
  }
#endif

  tolr = tol*fabs(r[0]);
  l = -1;
  for (k=0; k<n; k++) {
    kk = k*ldr + k;
    if (fabs(r[kk]) <= tolr) break;

    r[kk] = one/r[kk];
    for (j=0; j<k; j++) {
      kj = k*ldr + j;
      temp = r[kk] * r[kj];
      r[kj] = zero;

      k0 = k*ldr; j0 = j*ldr;
      for (i=0; i<=j; i++) {
	r[k0+i] += (-temp*r[j0+i]);
      }
    }
    l = k;
  }

  /* 
   * Form the full upper triangle of the inverse of (r transpose)*r
   * in the full upper triangle of r
   */

  if (l >= 0) {
    for (k=0; k <= l; k++) {
      k0 = k*ldr; 

      for (j=0; j<k; j++) {
	temp = r[k*ldr+j];

	j0 = j*ldr;
	for (i=0; i<=j; i++) {
	  r[j0+i] += temp*r[k0+i];
	}
      }
      
      temp = r[k0+k];
      for (i=0; i<=k; i++) {
	r[k0+i] *= temp;
      }
    }
  }

  /*
   * For the full lower triangle of the covariance matrix
   * in the strict lower triangle or and in wa
   */
  for (j=0; j<n; j++) {
    jj = ipvt[j];
    sing = (j > l);
    j0 = j*ldr;
    jj0 = jj*ldr;
    for (i=0; i<=j; i++) {
      ji = j0+i;

      if (sing) r[ji] = zero;
      ii = ipvt[i];
      if (ii > jj) r[jj0+ii] = r[ji];
      if (ii < jj) r[ii*ldr+jj] = r[ji];
    }
    wa[jj] = r[j0+j];
  }

  /*
   * Symmetrize the covariance matrix in r
   */
  for (j=0; j<n; j++) {
    j0 = j*ldr;
    for (i=0; i<j; i++) {
      r[j0+i] = r[i*ldr+j];
    }
    r[j0+j] = wa[j];
  }

#if 0
  for (j=0; j<n; j++) {
    for (i=0; i<n; i++) {
      printf("%f ", r[j*ldr+i]);
    }
    printf("\n");
  }
#endif

  return 0;
}

#endif   //of mpfit.c

 
//File-------------------Minimizer.h----------------------------------- 
 
#include <algorithm>

#ifndef __IR_MINIMIZER_H__ 
#define __IR_MINIMIZER_H__ 

#ifndef __IR_INCLUDES_H__
#include "IRincludes.h"
#endif

#ifndef __IR_UTIL_H__ 
#include "IRutil.h" 
#endif                      //end of #ifndef __IR_UTIL_H__ 
 
#ifndef __IR_FUNCTIONS_H__ 
#include "IRfunctions.h" 
#endif                      //end of #ifndef __IR_FUNCTIONS_H__ 
 
#ifndef __IR_MISC_GLOBAL_H__ 
#include "IRmiscGlobal.h" 
#endif	 //end of #ifndef __IR_MISC_GLOBAL_H__ 
 
#ifndef __IR_POSITION_H__
#include "Position.h"
#endif

#ifndef __IR_GAME_INFO_H__
#include "GameInfo.h"
#endif

#ifndef __IR_TRIAL_SPEC_H__ 
#include "TrialSpec.h" 
#endif	  //end of #ifndef __IR_TRIAL_SPEC_H__ 
 
#ifndef __IR_TURN_INFO_H__ 
#include "TurnInfo.h" 
#endif	  //end of #ifndef __IR_TURN_INFO_H__ 
 
#ifndef __IR_TUPLE_INFO_H__
#include "TupleInfo.h"
#endif 

#ifndef __IR_TURN_CONTEXT_H__
#include "TurnContext.h"
#endif

#ifndef __IR_FILTERS_H__ 
#include "Filters.h" 
#endif	  //end of #ifndef __IR_FILTERS_H__ 

#ifndef __IR_DELTA_SCALES_H__
#include "DeltaScales.h"
#endif    //end of #ifndef __IR_DELTA_SCALES_H__

 
#ifndef __IR_PERFDATA_H__ 
#include "PerfData.h" 
#endif	 //end of #ifndef __IR_PERFDATA_H__ 
 
#ifndef __IR_SHUFFLE_H__
#include "Shuffle.h"
#endif

#ifndef __IR_DECISION_INFO_H__
#include "DecisionInfo.h"
#endif
 
#ifndef __IR_MODELS_H__
#include "IRmodels.h"
#endif

#ifndef __IR_MOVESELECTION_H__
#include "MoveSelector.h"
#endif

#ifndef __IR_TRIAL_H__ 
#include "Trial.h" 
#endif	  //end of #ifndef __IR_TRIAL_H__ 
 
#ifndef __IR_TRIAL_FILTERS_H__ 
#include "TrialFilters.h" 
#endif 

#ifndef __IR_MULTIMIN_H__
#include "multimin.h"
#endif

#ifndef __IR_MPFIT_H__
#include "mpfit.h"
#endif
 
 
/** A "Swiss Army Knife" front end to multiple minimization packages and allowing:
    () user-weighted combinations of multiple objective functions f_j(X) to minimize;
    () holding any subset of eight total variables constant while fitting the n others;
    () bounded parameter domains (for packages that support them---not imposed here);
    () uniform control over search precision (x, y, and g for "geometry") and step parameters.
    For those components f_j(X) of the form "projected test j value minus actual value in data",
    the squared difference is divided by the (projected) variance to make a squared z-score,
    thus normalizing the units of all the tests, and the sum of these is minimized.  
    (As a back-door, entering a negative weight w_j for f_j gives |w_j|*the raw squared difference.)

    Also implements the relaxation technique of Murrag and Ng (2010) with switch mumul>0:

       minimize f(X) + mumul*g(X)

    where g(X) is a strongly convex function.  User gives initial value mu for mumul and
    a dividor d, then the procedure in Murray-Ng iterates until mumul/d^k < the x precision, 
    whereupon a final pass with mumul=0 occurs.  Initializing mumul=0 bypasses this process.

    Updates to parameters being fitted are managed as a /side effect/ on the global TrialSpec 
    (which is held in the class Trial "callback pointer" held by the Minimizer object).  
    If so needed, updates are copied to/from the fitted-parameter array (typically called "xs")
    passed in the package invocation function (variously called "f" or "fcn" or "Ef" in docs).
    Some packages also desire the f_j(X) values to be held separately so as to form their own
    internal weighted sum-of-squares (and also enforce m == n or m <= n); the mutable "testVals" 
    array in Minimizer itself does this.  Other Minimizer fields satisfy package requirements.

    Because the packages are mostly C code, the passed-in f/fcn/Ef/etc. function must be "static".
    Happily those packages give f a void* environment parameter, which is filled by the owning
    Minimizer object as "this" and cast to "(Minimizer*) miniMe" within f.  This allows invoking
    miniMe->minimand() which does the actual computation of f(X) as configured by the user.
    The body of f/fcn/Ef also updates the TrialSpec and adds mumul*g(X) to f(X) if mumul > 0.
    Updates to mumul are managed by the user-invoked minimize(...) method, which calls the
    workhorse method minimize1(...) for each "epoch" of minimization.  The package choice is
    effected in the body of minimize1 rather than minimize using top-level if/else statements.

    Because the actual function f(X) being minimized is static, it can be exported for use by
    other packages.  In fact, all package routines have been implemented this way.  To add another:
    () Add enumeration constant(s) for the new method(s) to the METHOD enum.
    () Make a new if-else block (or switch block) for each of the new methods in minimize1.
    () If "f", "fcn", or "Ef" does not already match the prototype needed by the routine, code it
       with the needed prototype and an analogous body.
    () Form structs either in the class or in the body of minimize1 as needed to invoke the routine.
    () If calling the new routine(s) from within the IR program, add entries for them to the
       methodMenu object built in the initMenus() routine in class Ensemble.  It may-or-may-not
       be necessary also to add code to the Ensemble::makeMinimizer(...) body.
       [Of course, CSE712 people wishing to do this can get help from me.  If the package's own 
       interface is clear, the process is really quick.]
 */

class Minimizer { 
 public: 
   enum METHOD {
      VWALK, GSL_NM4, GSL_NM6, GSL_NM7, GSL_SIM_ANN, 
      CMINPACK_LMDIF, CMINPACK_LMDIF1, CMINPACK_HYBRD, CMINPACK_HYBRD1, 
      MPFIT_LMDIF, NUM_METHODS
   };
   enum SKED {
      UNIT_SKED, SQRT_SKED, LIN_SKED, QUAD_SKED, INVVAR_SKED, 
      SQRT_ALLWT, LIN_ALLWT, QUAD_ALLWT, NUM_SKEDS
   };
   enum MINIMAND { 
      PERCFIT, ML, BINS,  //PERCFITOLD, PERCFITOLDL1, 
         FALLOFF, FIRST_LINE, SECOND_LINE, THIRD_LINE, ETV, //FOURTH_LINE, FIFTH_LINE,
         INDEX_FIT, INDEX_DIFF, ERROR1, ERROR2,
         //INDEXFITMASS, INDEXDIFFMASS, INDEXFITINVVAR, INDEXFITPROP,
         //FIRSTL1A, ETVL1A, 
         NUM_MINIMANDS
   }; 
 private: 
   const double STOLERANCE; 
   const double CTOLERANCE; 
   typedef double (Minimizer::*Monic)(const double) const; //used only for vWalk
   //typedef double (Trial::*TrialFn)(); 
 
//-------------------------//
   Trial* const theTrial;            //modifying theTrial->theSpec is the main side effect
   const METHOD method;
   size_t numActiveTests;            // = "m" in MINPACK routines
   map<MINIMAND, double> minibook;   //set of tests we are minimizing, with a weight for each
//-------------------------//

   //custom features of some tests
   size_t equalTopIndexLimit;
   const int indexFitStart;     //0-based move index
   const int indexFitEnd;
   const SKED indexFitSked;
   const int indexDiffStart;
   const int indexDiffEnd;
   const SKED indexDiffSked;
   const double error1Low;
   const double error1Hi;
   const SKED error1Sked;
   const double error2Low;
   const double error2Hi;
   const SKED error2Sked;
   vector<MoveSelector*>* mySelectors;

//--------------------------//
   size_t numIndices;
   double mumul;               //"funnel factor" for smoothing, = mu in Miller-Ng paper
   double mudiv;               //amount to divide mumul by in each "epoch"

   size_t whichParams;         //code (s,c,d,v,w,em,ep,a) in binary from 00000000 to 11111111
   const TrialSpec lowSpec;    //used to keep parameter bounds used in fitting
   const TrialSpec hiSpec;     //or in the logarithmic "funnel function".
   TrialSpec pivotSpec;        //map e.g. [lowS,pivotS,hiS] to [0,1/2,1]
//-------------------------//

   //const size_t mjudgmentDepth;
   unsigned int maxIter;  //not size_t to avoid compatibility warning with GSL
   size_t numRetries;
   mutable size_t numCalls;  //temp variable
   mutable size_t callsPerDisplay;   //ditto
   const double xprec; 
   const double yprec;
   const double geomprec;
   const bool walkOut; 
   const double walkOutStep; 
   const size_t bootNum;
   const bool keepSpecInBoot;
   bool verbose; 
   bool finished;
   vector<ostream*>* outs; 

   //Deprecated
   const bool geometricMeans;
   const bool sFirst;

   //CMINPACK quantities
   double epsfcn;           //machine-precision limit constant
   int* nfev;               //actual number of iterations, output variable
   double* testVals;        // "fvec" in MINPACK routines, size m = numActiveTests
   mutable string testValStr;
   mutable map<MINIMAND,string> testNames;

   //Temporary storage used by CMINPACK
   double* diag;            // "diag" in MINPACK routines, size n = numParamsUsed
   int* paramSwap;          // swap used for params in MINPACK routines
   double* lmdifSwap;       // extra swap for "lmdif" routine
   double* fjac;            // simulated Jacobian by CMINPACK lmdif
   double* qtf;
   double* wa1;
   double* wa2;
   double* wa3;
   double* wa4;
   double* hwa;



 public: 
   Minimizer(Trial* trial, METHOD gmethod, map<MINIMAND,double> gmini, size_t etvlimit,
             size_t ifs, size_t ife, SKED ifsked, size_t ids, size_t ide, SKED idsked,
             double e1lo, double e1hi, SKED e1sked, double e2lo, double e2hi, SKED e2sked,
             double mu, double mud, //bool upv,
             const TrialSpec loSpec, const TrialSpec hSpec, const TrialSpec pivSpec,
             unsigned int max_iter, size_t num_retries,
             double precx, double precy, double precg, 
             bool wout = true, double woutstep = 0.02, double epsfn = 1e-08,
             double bn = 0, bool ksib = false, bool vb = false,
             vector<ostream*>* gouts = new vector<ostream*>()) 
      : STOLERANCE(0.00001), CTOLERANCE(0.01), theTrial(trial), method(gmethod), 
        numActiveTests(gmini.size()), minibook(gmini), equalTopIndexLimit(etvlimit),
        indexFitStart(ifs), indexFitEnd(ife), indexFitSked(ifsked),
        indexDiffStart(ids), indexDiffEnd(ide), indexDiffSked(idsked),
        error1Low(e1lo), error1Hi(e1hi), error1Sked(e1sked),
        error2Low(e2lo), error2Hi(e2hi), error2Sked(e2sked),
        mySelectors(new vector<MoveSelector*>()),
        numIndices(max(indexFitEnd,max(indexDiffEnd,5))),
        mumul(mu), mudiv(mud), whichParams(255), 
        lowSpec(loSpec), hiSpec(hSpec), pivotSpec(pivSpec),
        maxIter(max_iter), numRetries(num_retries), numCalls(0), callsPerDisplay(50),
        xprec(precx), yprec(precy), geomprec(precg),
        walkOut(wout), walkOutStep(woutstep), bootNum(bn), keepSpecInBoot(ksib),
        verbose(vb), finished(false), outs(gouts), geometricMeans(false), sFirst(true),
        epsfcn(epsfn), nfev(new int(0)), testValStr(""), testNames(map<MINIMAND,string>())
   { 
      const size_t nat = gmini.size();
      testVals = new double[nat];
      diag = new double[8];
      paramSwap = new int[8];
      lmdifSwap = new double[8*nat + 40 + nat]; //mn+5n+m
      fjac = new double[8*nat];
      qtf = new double[8];
      wa1 = new double[8];
      wa2 = new double[8];
      wa3 = new double[8];
      wa4 = new double[nat];
      hwa = new double[74];
      
      for (int i = 0; i < 8; i++) { diag[i] = 1.0; }
      size_t jd = theTrial->getScale()->getJudgmentDepth();
      map<MINIMAND,double>::const_iterator mapite = gmini.end();
      if (gmini.find(ERROR1) != mapite && e1hi >= e1lo) {
          MoveRawDeltaSelector* mds1lo = new MoveRawDeltaSelector(GEQ,e1lo,jd,false,"mds1lo");
          MoveRawDeltaSelector* mds1hi = new MoveRawDeltaSelector(LEQ,e1hi,jd,false,"mds1hi");
          AndSelector* as1 = new AndSelector(mds1lo,mds1hi,"as1",false);
          mySelectors->push_back(as1);
      }
      if (gmini.find(ERROR2) != mapite && e2hi >= e2lo) {
          MoveRawDeltaSelector* mds2lo = new MoveRawDeltaSelector(GEQ,e2lo,jd,false,"mds2lo");
          MoveRawDeltaSelector* mds2hi = new MoveRawDeltaSelector(LEQ,e2hi,jd,false,"mds2hi");
          AndSelector* as2 = new AndSelector(mds2lo,mds2hi,"as2",false);
          mySelectors->push_back(as2);
      }
      
      if (trial->getS() < STOLERANCE) { 
         cout << "Adjusting s = 0 to " << STOLERANCE 
              << ", hope that's OK." << endl; 
         theTrial->setS(STOLERANCE); 
      } 
      if (trial->getC() < CTOLERANCE && geometricMeans) { 
         cout << "Adjusting c to " << CTOLERANCE 
              << " for geometric means." << endl; 
         theTrial->setC(CTOLERANCE); 
      } 
      testNames[PERCFIT] = "PercFit";
      testNames[ML] = "MaxLikely";
      testNames[BINS] = "Bins";
      testNames[FALLOFF] = "ASD";
      testNames[FIRST_LINE] = "Line1";
      testNames[SECOND_LINE] = "Line2";
      testNames[THIRD_LINE] = "Line3";
      testNames[ETV] = "ETV[" + IRutil::itoa(equalTopIndexLimit) + "]";
      testNames[INDEX_FIT] = "IndexFit["+IRutil::itoa(ifs)+","+IRutil::itoa(ife)+"]";
      testNames[INDEX_DIFF] = "IndexDiff["+IRutil::itoa(ids)+","+IRutil::itoa(ide)+"]";
      testNames[ERROR1] = "Error["+IRutil::ftoa(e1lo,2)+","+IRutil::ftoa(e1hi,2)+"]";
      testNames[ERROR2] = "Error["+IRutil::ftoa(e2lo,2)+","+IRutil::ftoa(e2hi,2)+"]";
   } 

   virtual ~Minimizer() {
      for (size_t i = 0; i < mySelectors->size(); i++) {
         delete(mySelectors->at(i));
      }
      delete(mySelectors);
      delete(nfev);
      delete(testVals);
      delete[](diag);
      delete[](paramSwap);
      delete[](lmdifSwap);
      delete[](hwa);
      delete[](wa1);
      delete[](wa2);
      delete[](wa3);
      delete[](wa4);
    } 
 
   inline bool isSFirst() const { return sFirst; } 
   inline TrialSpec getSpec() const { return theTrial->getSpec(); } 
   inline void setSpec(const TrialSpec& ts) { theTrial->setSpec(ts); }
   inline TrialSpec getLowSpec() const { return lowSpec; }
   inline TrialSpec getPivotSpec() const { return pivotSpec; }
   inline TrialSpec getHighSpec() const { return hiSpec; }
   inline METHOD getMethod() const { return method; }
   inline map<MINIMAND,double> getMinibook() const { return minibook; }
   inline size_t getMaxIter() const { return maxIter; }
   inline size_t getBootNum() const { return bootNum; }
   inline void setSilent() { verbose = false; }
   inline void setVerbose() { verbose = true; }
   inline bool isFinished() const { return finished; }
   inline string getTestValStr() const { return testValStr; }

   inline static double skedVal(Minimizer::SKED sked, double projTally, double projVar, double allWt) {
      switch(sked) {
       case UNIT_SKED:
         return 1.0;
       case SQRT_SKED:
         return sqrt(sqrt(projTally));
       case LIN_SKED:
         return sqrt(projTally);
       case QUAD_SKED:
         return projTally;
       case INVVAR_SKED:
         //sked = 1.0/sqrt(ss.indexMatchesWtd.at(i));
         return 1.0/sqrt(projVar);
       case SQRT_ALLWT:
         return sqrt(sqrt(allWt));
       case LIN_ALLWT:
         return sqrt(allWt);
       case QUAD_ALLWT:
         return allWt;
       default:
         return 1.0;
      }
   }

 
   /** The quantity being minimized---a weighted combination of test statistics.
       Does NOT include the "g" part of funneling f(X) + mu*g(X).
    */
   inline double minimand(bool vb = true) const {   //side effect: writes to testVals and testValStr
      vb = verbose;
      double result = 0.0; 
      size_t onTest = 0;
      size_t ilen, sel;
      double denom = IRutil::MINGTZERO;
      double sked, indexCume, falloffDiffSq, zFalloffSq, evDiffSq, zEVsq, idiff, idiffSq, zi, zisq, zir;
      size_t numIndices = 3;  //always do first-second-third line

      map<MINIMAND,double>::const_iterator mapite = minibook.end();
      if (minibook.find(INDEX_DIFF) != mapite && indexDiffEnd >= numIndices) { numIndices = indexDiffEnd+1; }
      if (minibook.find(INDEX_FIT) != mapite && indexFitEnd >= numIndices) { numIndices = indexFitEnd+1; }

      size_t numSelectors = mySelectors->size();
      testValStr = "";

      //This line evaluates the main test statistics; rest of the code applies only those selected.
      SimpleStats ss = theTrial->perfTestSimple(numIndices,numSelectors,mySelectors,equalTopIndexLimit,
                                                false,true,false);   //gives absolute numbers

      map<MINIMAND,double>::const_iterator citr = minibook.begin();
      while (citr != mapite) {
         MINIMAND md = (*citr).first;
         double mul = (*citr).second;
         denom += fabs(mul);
         double testVal = 0.0;
         //double gadd = (mumul > 0 ? mumul*g() : 0.0);

         switch(md) { 

          case PERCFIT: 
            testVal = mul * theTrial->percFit(new vector<ostream*>()); 
            break; 

          case ML: 
            testVal = mul * theTrial->logSumPlayedMoves(); 
            break; 

          case BINS:
            testVal = mul * theTrial->probabilityBins();
            break;

          case FALLOFF:
            falloffDiffSq = IRutil::sqr(ss.scaledFalloffWtd - ss.scaledFalloffProjWtd);
            if (mul < 0.0) {
               testVal = -mul * falloffDiffSq / IRutil::sqr(ss.accumWeight);
            } else {
               zFalloffSq = falloffDiffSq / ss.scaledFalloffVarianceProjWtd;
               testVal = mul * zFalloffSq;
            }
            break;

          case FIRST_LINE:
            idiffSq = IRutil::sqr(ss.indexMatchesWtd.at(0) - ss.indexMatchesProjWtd.at(0));
            if (mul < 0.0) {
               testVal = -mul * idiffSq / IRutil::sqr(ss.accumWeight);
            } else {
               zisq = (idiffSq / ss.indexMatchesVarianceProjWtd.at(0));
               testVal = mul * zisq;
            }
            break;

          case SECOND_LINE:
            idiffSq = IRutil::sqr(ss.indexMatchesWtd.at(1) - ss.indexMatchesProjWtd.at(1));
            if (mul < 0.0) {
               testVal = -mul * idiffSq / IRutil::sqr(ss.accumWeight);
            } else {
               zisq = (idiffSq / ss.indexMatchesVarianceProjWtd.at(1));
               testVal = mul * zisq;
            }
            break;

          case THIRD_LINE:
            idiffSq = IRutil::sqr(ss.indexMatchesWtd.at(2) - ss.indexMatchesProjWtd.at(2));
            if (mul < 0.0) {
               testVal = -mul * idiffSq / IRutil::sqr(ss.accumWeight);
            } else {
               zisq = (idiffSq / ss.indexMatchesVarianceProjWtd.at(2));
               testVal = mul * zisq;
            }
            break;

          case ETV:
            evDiffSq = IRutil::sqr(ss.equalValueMatchWtd - ss.equalValueMatchProjWtd);
            if (mul < 0.0) {
               testVal = -mul * evDiffSq / IRutil::sqr(ss.accumWeight);
            } else {
               zEVsq = evDiffSq / ss.equalValueMatchVarianceProjWtd;
               testVal = mul * zEVsq;
            }
            break;

          case INDEX_FIT:
            zir = 0.0;
            indexCume = 0.0;
            for (size_t i = indexFitStart; i <= indexFitEnd; i++) {
               sked = skedVal(indexFitSked, ss.indexMatchesProjWtd.at(i),
                              ss.indexMatchesVarianceProjWtd.at(i), ss.accumWeight);
               idiff = (ss.indexMatchesWtd.at(i) - ss.indexMatchesProjWtd.at(i));  // not /ss.accumWeight;
               idiffSq = 10000.0*IRutil::sqr(idiff/ss.accumWeight);
               if (mul < 0.0) {    //use raw index stats
                  indexCume += sked*idiffSq;
               } else {
                  zisq = (idiffSq / ss.indexMatchesVarianceProjWtd.at(i));
                  zir += zisq;
                  indexCume += sked*zisq;
               }
            }
            if (mul < 0.0) {
               testVal = -mul*indexCume/(indexFitEnd - indexFitStart + 1);
            } else {
               testVal = mul*zir/(indexFitEnd - indexFitStart + 1);
            }
            break;

          case INDEX_DIFF:
            zir = 0.0;
            indexCume = 0.0;
            idiff = 0.0;
            for (size_t i = indexDiffStart; i <= indexDiffEnd; i++) {
               sked = skedVal(indexDiffSked, ss.indexMatchesProjWtd.at(i),
                              ss.indexMatchesVarianceProjWtd.at(i), ss.accumWeight);
               idiff += 100.0*(ss.indexMatchesWtd.at(i) - ss.indexMatchesProjWtd.at(i)); 
               if (mul < 0.0) {    //use raw index stats
                  indexCume += sked*idiff/ss.accumWeight;
               } else {
                  zi = idiff / sqrt(ss.indexMatchesVarianceProjWtd.at(i));
                  zir += zi;
                  indexCume += sked*zi;
               }
            }
            if (mul < 0.0) {
               testVal = -mul*IRutil::sqr(indexCume)/(indexFitEnd - indexFitStart + 1);
            } else {
               testVal = mul*zir*zir/(indexFitEnd - indexFitStart + 1);
            }
            break;

          case ERROR1:
            testVal = 0.0;
            for (size_t i = 0; i < mySelectors->size(); i++) {
               if (mySelectors->at(i)->getName() == "as1") {
                  sel = i;
                  break;
               }
            }
            sked = skedVal(error1Sked, ss.selectorMatchesPlayerProjWtd.at(sel),
                           ss.selectorMatchesPlayerProjVarianceWtd.at(sel), ss.accumWeight);

            idiff = ss.selectorMatchesPlayerWtd.at(sel) - ss.selectorMatchesPlayerProjWtd.at(sel);
            if (mul < 0.0) {
               testVal += sked * fabs(mul) * IRutil::sqr(idiff/ss.accumWeight);  //yes?
            } else {
               idiffSq = IRutil::sqr(idiff);  // /ss.accumWeight);
               zisq = idiffSq / ss.selectorMatchesPlayerProjVarianceWtd.at(sel);
               testVal += sked * mul * zisq;
            }
            /*
            if (finished) {
               cout << "ERROR1 Actual: " << ss.selectorMatchesPlayerWtd.at(sel)
                    << ", Proj: " << ss.selectorMatchesPlayerProjWtd.at(sel)
                    << ", Var: " << ss.selectorMatchesPlayerProjVarianceWtd.at(sel)
                    << ", Z: " << sqrt(zisq) << ", sked " << sked << ", testVal: " << testVal << endl;
            }
            */
            break;

          case ERROR2:
            for (size_t i = 0; i < mySelectors->size(); i++) {
               if (mySelectors->at(i)->getName() == "as2") {
                  sel = i;
                  break;
               }
            }
            sked = skedVal(error2Sked, ss.selectorMatchesPlayerProjWtd.at(sel),
                           ss.selectorMatchesPlayerProjVarianceWtd.at(sel), ss.accumWeight);

            idiff = ss.selectorMatchesPlayerWtd.at(sel) - ss.selectorMatchesPlayerProjWtd.at(sel);
            if (mul < 0.0) {
               testVal += sked * fabs(mul) * IRutil::sqr(idiff/ss.accumWeight);
            } else {
               idiffSq = IRutil::sqr(idiff);  // /ss.accumWeight);
               zisq = idiffSq / ss.selectorMatchesPlayerProjVarianceWtd.at(sel);
               testVal += sked * mul * zisq;
            }
            /*
            if (finished) {
               cout << "ERROR2 Actual: " << ss.selectorMatchesPlayerWtd.at(sel)
                    << ", Proj: " << ss.selectorMatchesPlayerProjWtd.at(sel)
                    << ", Var: " << ss.selectorMatchesPlayerProjVarianceWtd.at(sel)
                    << ", Z: " << sqrt(zisq) << ", sked " << sked << ", testVal: " << testVal << endl;
            }
            */
            break;
          default: 
            cerr << "Default on test " << md << ", using percFit." << endl;
            testVal = fabs(mul) * theTrial->percFit(new vector<ostream*>()); 
            break; 
         } 

         //testValStr += IRutil::itoa(1+md) + ": " + IRutil::ftoa(testVal) + "; ";
         testValStr += testNames[md] + ": " + IRutil::ftoa(testVal) + "; ";
         //testVal += gadd/denom;
         result += testVal;
         testVals[onTest] = sqrt(testVal);  //testVal is a square and this will be re-squared by CMINPACK
         onTest++;
         citr++;
      }

      numCalls++;
      if (vb && numCalls % callsPerDisplay == 0) { 
         string s1 = theTrial->strPWV();
         string s2 = (getSpec().v > 0 ? "\nSWV: " + theTrial->strSWV() : "");
         cout << getSpec().paramsPosition();
         if (s1.length() > 10) { cout << endl; } else { cout << "; "; }
         cout << "PWV: " << s1;
	 //if (s2.length() > 10) { cout << endl; } else { cout << "; "; }
	 cout << s2 << endl;
         cout << "Minimand " << result << "/" << denom << " from tests " << testValStr << endl;
      }
      return (result/denom); 
   } 


   
   /** Function f in format expected by GSL multimin.
       Needs to be static rather than member---hence "fparams" is used to
       pass in the needed reference to "this".
    */
   static void f(const size_t n, const double* xs, void* fparams, double* fval){
      Minimizer* miniMe = (Minimizer*)fparams;
      Trial* thisTrial = miniMe->getTrial();   //needed since f is static
      thisTrial->setWhichParams(miniMe->whichParams,n,xs);
      *fval = miniMe->minimand() + (miniMe->mumul > 0 ? miniMe->mumul*miniMe->g() : 0.0);
   }

   /** The "Energy" function f in format for GSL simulated annealing---repeated below.
    *
   static double Ef(void* xp) {
      SimanConfig* scp = (SimanConfig*)xp;  //dynamic_cast<SimanConfig*>(xp);
      return scp->miniMe->minimand();
   }
   */


   /** Function fcn in format needed by MINPACK (C/C++), again static.
       Unlike documentation, happily there really is a void* first parameter.
    */
   static int fcn(void* fparams, int m, int n, const double* xs, double* fvec, int iflag) {
      Minimizer* miniMe = (Minimizer*)fparams;  //passed in as "this", not new
      Trial* thisTrial = miniMe->getTrial();   //needed since f is static
      thisTrial->setWhichParams(miniMe->whichParams,n,xs);

      double res = miniMe->minimand() + (miniMe->mumul > 0 ? miniMe->mumul*miniMe->g() : 0.0);
      fvec = miniMe->testVals;  //set as side-effect of calls to minimand()
      return iflag;
   }

   /** Function header for MINPACK HYBRD where m == n
    */
   static int fcn2(void* fparams, int n, const double* xs, double* fvec, int iflag) {
      return fcn(fparams, n, n, xs, fvec, iflag);
   }

   /** Rearranged form used by MPFIT.  We will use only with the pointer "dvec" set to null,
       so it is ignored.  Since MPFIT manages its own settings of whether parameters are 
       "fixed" or "free", we could dispense with the call to setWhichParams, but we keep it.
       Always fvec is an alias of miniMe->testvals and those values get written.
    */
   static int mpfcn(int m, int n, double* allxs, double* fvec, double** dvec, void* fparams) {
      Minimizer* miniMe = (Minimizer*)fparams;  //passed in as "this", not new
      fvec = miniMe->testVals;
      Trial* thisTrial = miniMe->getTrial();    //needed since f is static
      thisTrial->setWhichParams(255,n,allxs);   //255 because we carry along whole xs matrix
      double res1 = miniMe->minimand();
      double res2 = (miniMe->mumul > 0 ? miniMe->mumul*miniMe->g() : 0.0);
      return int(100000.0 * (res1 + res2));
   }



   /** Helper for funneling---also creates an infinite "penalty" at the boundary.
    */
   static double loginterp(const double& x, const double& lo, const double& mid, const double& hi) {
      const double y2 = (x < mid ? (x - lo)/(mid - lo) : (hi - 2*mid + x)/(hi - x));

      return -(log((y2+IRutil::MINGTZERO)/2.0) + log((2.0-y2+IRutil::MINGTZERO)/2.0));
   }

   /** "Funneling" function---we will minimize f + mu*g.
       As long as mu > 0, also keeps in bounds of lowS..hiS etc.
    */
   inline double g() const {
      double res = 0.0;
      if ((whichParams >> 7) % 2) {
         res += loginterp(theTrial->getS(), lowSpec.s, pivotSpec.s, hiSpec.s);
      }
      if ((whichParams >> 6) % 2) {
         res += loginterp(theTrial->getC(), lowSpec.c, pivotSpec.c, hiSpec.c);
      }
      if ((whichParams >> 5) % 2) {
         res += loginterp(theTrial->getD(), lowSpec.d, pivotSpec.d, hiSpec.d);
      }
      if ((whichParams >> 4) % 2) {
         res += loginterp(theTrial->getV(), lowSpec.v, pivotSpec.v, hiSpec.v);
      }
      if ((whichParams >> 3) % 2) {
         res += loginterp(theTrial->getA(), lowSpec.a, pivotSpec.a, hiSpec.a);
      }
      if ((whichParams >> 2) % 2) {
         res += loginterp(theTrial->getHM(), lowSpec.hm, pivotSpec.hm, hiSpec.hm);
      }
      if ((whichParams >> 1) % 2) {
         res += loginterp(theTrial->getHP(), lowSpec.hp, pivotSpec.hp, hiSpec.hp);
      }
      if ((whichParams) % 2) {
         res += loginterp(theTrial->getB(), lowSpec.b, pivotSpec.b, hiSpec.b);
      }
      return res;
   }



   /** This is the $64,000 function that the client calls. 
       USED ONLY BY void Ensemble::runFit(), and 
       the veeFinder and veeWalker methods are NOT used outside here. 
       --ALSO SETS just ONE of the optimal s and/or c values; runFit() sets
       --the other in a separate call.

       Modified 12/12 to return a TrialSpec, bringing that call in here.
    */ 
   TrialSpec minimize() { 
      finished = false;
      TrialSpec ots = theTrial->getSpec();
      TrialSpec ts = theTrial->getSpec();
      while (mumul > yprec) { 
         double tmp = mumul*pow(yprec,0.25);    //can tune better?
         double myyprec = (tmp > 0.1 ? 0.1 : tmp < yprec ? yprec : tmp);
         double myxprec = myyprec*xprec/yprec;   //preserve original user ratios
         double mygprec = myyprec*geomprec/yprec;
         double wos = walkOutStep * pow(myyprec/yprec, 0.25)/100.0;  //can tune better?
         for (vector<ostream*>::const_iterator it = outs->begin();
              it != outs->end(); it++) {
            (**it) << endl << IRutil::DASHLINE << endl
                   << "Iteration with mu = " << mumul << ", yprec = " << myyprec << ", and spec = " << endl
                   << string(ts) << endl << IRutil::DASHLINE << endl;
         }

         ts = minimize1(myxprec,myyprec,mygprec,wos);
         theTrial->setSpec(ts);
         pivotSpec = ts;
         mumul /= mudiv;
      }
      if (mumul > 0.0) {
         for (vector<ostream*>::const_iterator it = outs->begin();
             it != outs->end(); it++) {
            (**it) << endl << IRutil::DASHLINE << endl
                   << "Final step with prec = " << yprec << ", and spec = " 
                  << string(ts) << endl << IRutil::DASHLINE << endl;
         }
         mumul = 0.0;
      }
      TrialSpec finalTS = minimize1(xprec,yprec,geomprec,walkOutStep); 
      finished = true;
      return finalTS;
   }
      
   TrialSpec minimize1(double myxprec, double myyprec, double mygprec, double mywos) {
      if (verbose) {
         for (vector<ostream*>::const_iterator it = outs->begin(); 
              it != outs->end(); it++) { 
            (**it) << endl << IRutil::DASHLINE << endl << string(*this)  
                   << IRutil::DASHLINE << endl; 
         } 
      } 

      //Create a field that makes this use gradient descent rather than 
      TrialSpec ots = theTrial->getSpec();
      if (method == VWALK) {
         callsPerDisplay *= 1000;   //VWALK code has its own display protocol
         double val = walkOut ? veeWalker() : veeFinder();
         if (isSFirst()) {
            ots.s = val;
            ots.c = bestCFor(ots.s);
         } else {
            ots.c = val;
            //minS = mm->getSpec().s;
            ots.s = bestSFor(ots.c);
         }
         callsPerDisplay /= 1000;

      } else {  //if (method == GSL_MULTIMIN || method == GSL_SIM_ANN || method == CMINPACK_LMDIF1) { 
                //or GSL_NM4, GSL_NM6, GSL_NM7, GSL_SIM_ANN, CMINPACK_LMDIF, CMINPACK_HYBRD

         //from bounds, see if some params are meant to be fixed
         const int numParams = 8;
         const int limi = (mumul > 0 ? 0 : 1);
         mp_par paramSettings[numParams] = {
             {1, {limi, limi}, {lowSpec.s, hiSpec.s}, "s", 0, 0, 0, 0, 0, 0},
             {1, {limi, limi}, {lowSpec.c, hiSpec.c}, "c", 0, 0, 0, 0, 0, 0},
             {1, {limi, limi}, {lowSpec.d, hiSpec.d}, "d", 0, 0, 0, 0, 0, 0},
             {1, {limi, limi}, {lowSpec.v, hiSpec.v}, "v", 0, 0, 0, 0, 0, 0},
             {1, {limi, limi}, {lowSpec.a, hiSpec.a}, "a", 0, 0, 0, 0, 0, 0},
             {1, {limi, limi}, {lowSpec.hm, hiSpec.hm}, "hm", 0, 0, 0, 0, 0, 0},
             {1, {limi, limi}, {lowSpec.hp, hiSpec.hp}, "hp", 0, 0, 0, 0, 0, 0},
             {1, {limi, limi}, {lowSpec.b, hiSpec.b}, "b", 0, 0, 0, 0, 0, 0}
         };
         double params[numParams+1];  //allows room to pass cast of "this" as last arg
         double xmax[numParams];
         double xmin[numParams];
         unsigned mtype[numParams];
         size_t paramsCode = 0; //code is (s,c,d,v,w,em,ep,a) from 00000000 to 11111111 = 255
         size_t numParamsUsed = 0;
         size_t numParamsSeen = 0;

         if (hiSpec.s - lowSpec.s > xprec) {
            paramSettings[numParamsSeen].fixed = 0;
            ots.s = min(max(ots.s,lowSpec.s),hiSpec.s);
            paramsCode += 128; 
            params[numParamsUsed] = ots.s;
            xmax[numParamsUsed] = hiSpec.s;
            xmin[numParamsUsed] = lowSpec.s;
            mtype[numParamsUsed] = 3;
            numParamsUsed += 1;
         } else if (lowSpec.s < hiSpec.s + xprec) {   //adopt and freeze lowSpec.s as the value
            ots.s = lowSpec.s;   
            //leave paramSettings[i].fixed = 1;
         }  //else current value of s is frozen in place
         paramSettings[numParamsSeen].parname = "s";
         numParamsSeen += 1;
            
         if (hiSpec.c - lowSpec.c > xprec) {
            paramSettings[numParamsSeen].fixed = 0;
            ots.c = min(max(ots.c,lowSpec.c),hiSpec.c);
            paramsCode += 64;
            params[numParamsUsed] = ots.c;
            xmax[numParamsUsed] = hiSpec.c;
            xmin[numParamsUsed] = lowSpec.c;
            mtype[numParamsUsed] = 3;
            numParamsUsed += 1;
         } else if (lowSpec.c < hiSpec.c + xprec) {   //adopt and freeze lowSpec.c as the value
            ots.c = lowSpec.c;
         }
         paramSettings[numParamsSeen].parname = "c";
         numParamsSeen += 1;

         if (hiSpec.d - lowSpec.d > xprec) {
            paramSettings[numParamsSeen].fixed = 0;
            ots.d = min(max(ots.d,lowSpec.d),hiSpec.d);
            paramsCode += 32;
            params[numParamsUsed] = ots.d;
            xmax[numParamsUsed] = hiSpec.d;
            xmin[numParamsUsed] = lowSpec.d;
            mtype[numParamsUsed] = 3;
            numParamsUsed += 1;
         } else if (lowSpec.d < hiSpec.d + xprec) {   //adopt and freeze lowSpec.d as the value
            ots.d = lowSpec.d;
         }
         paramSettings[numParamsSeen].parname = "d";
         numParamsSeen += 1;

         if (hiSpec.v - lowSpec.v > xprec) {
            paramSettings[numParamsSeen].fixed = 0;
            ots.v = min(max(ots.v,lowSpec.v),hiSpec.v);
            paramsCode += 16;
            params[numParamsUsed] = ots.v;
            xmax[numParamsUsed] = hiSpec.v;
            xmin[numParamsUsed] = lowSpec.v;
            mtype[numParamsUsed] = 3;
            numParamsUsed += 1;
         } else if (lowSpec.v < hiSpec.v + xprec) {   //adopt and freeze lowSpec.v as the value
            ots.v = lowSpec.v;
         }
         paramSettings[numParamsSeen].parname = "v";
         numParamsSeen += 1;

         if (hiSpec.a - lowSpec.a > xprec) {
            paramSettings[numParamsSeen].fixed = 0;
            ots.a = min(max(ots.a,lowSpec.a),hiSpec.a);
            paramsCode += 8;
            params[numParamsUsed] = ots.a;
            xmax[numParamsUsed] = hiSpec.a;
            xmin[numParamsUsed] = lowSpec.a;
            mtype[numParamsUsed] = 3;
            numParamsUsed += 1;
         } else if (lowSpec.a < hiSpec.a + xprec) {   //adopt and freeze lowSpec.v as the value
            ots.a = lowSpec.a;
         }
         paramSettings[numParamsSeen].parname = "a";
         numParamsSeen += 1;

         if (hiSpec.hm - lowSpec.hm > xprec) {
            paramSettings[numParamsSeen].fixed = 0;
            ots.hm = min(max(ots.hm,lowSpec.hm),hiSpec.hm);
            paramsCode += 4;
            params[numParamsUsed] = ots.hm;
            xmax[numParamsUsed] = hiSpec.hm;
            xmin[numParamsUsed] = lowSpec.hm;
            mtype[numParamsUsed] = 3;
            numParamsUsed += 1;
         } else if (lowSpec.hm < hiSpec.hm + xprec) {   //adopt and freeze lowSpec.v as the value
            ots.hm = lowSpec.hm;
         }
         paramSettings[numParamsSeen].parname = "hm";
         numParamsSeen += 1;

         if (hiSpec.hp - lowSpec.hp > xprec) {
            paramSettings[numParamsSeen].fixed = 0;
            ots.hp = min(max(ots.hp,lowSpec.hp),hiSpec.hp);
            paramsCode += 2;
            params[numParamsUsed] = ots.hp;
            xmax[numParamsUsed] = hiSpec.hp;
            xmin[numParamsUsed] = lowSpec.hp;
            mtype[numParamsUsed] = 3;
            numParamsUsed += 1;
         } else if (lowSpec.hp < hiSpec.hp + xprec) {   //adopt and freeze lowSpec.v as the value
            ots.hp = lowSpec.hp;
         }
         paramSettings[numParamsSeen].parname = "hp";
         numParamsSeen += 1;

         if (hiSpec.b - lowSpec.b > xprec) {
            paramSettings[numParamsSeen].fixed = 0;
            ots.b = min(max(ots.b,lowSpec.b),hiSpec.b);
            paramsCode += 1;
            params[numParamsUsed] = ots.b;
            xmax[numParamsUsed] = hiSpec.b;
            xmin[numParamsUsed] = lowSpec.b;
            mtype[numParamsUsed] = 3;
            numParamsUsed += 1;
         } else if (lowSpec.b < hiSpec.b + xprec) {   //adopt and freeze lowSpec.v as the value
            ots.b = lowSpec.b;
         }
         paramSettings[numParamsSeen].parname = "b";
         numParamsSeen += 1;

         double allxs[numParamsSeen] = {
            ots.s, ots.c, ots.d, ots.v, ots.a, ots.hm, ots.hp, ots.b
         };

         this->whichParams = paramsCode;
         theTrial->setSpec(ots);
         double minVal;

         unsigned int vb = (verbose ? 4 : 0);
         numCalls = 0;

         Minimizer* fparams = this;
         // Type multimin_params imported from GSL
#ifdef OS_UNIX 

         int info = 0;
         gsl_set_error_handler_off();

         if (method == GSL_NM4 || method == GSL_NM6 || method == GSL_NM7) {
            unsigned int alg = (method == GSL_NM4 ? 4 : (method == GSL_NM6 ? 6 : 7));
         
            struct multimin_params optim_par = {
               mywos,         //double step_size
               myxprec,       //double tol  //accuracy of line minimization
               maxIter,       //unsigned maxiter
               myyprec,       //double epsabs---accuracy of the minimization
               mygprec,      //double maxsize---final size of the simplex 
               alg,           //unsigned method---Nelder-Mead simplex flavor
               vb             //verbosity
            };

            if (mumul > 0.0) {
               multimin(numParamsUsed,params,&minVal,NULL,NULL,NULL,
                     &Minimizer::f,&Minimizer::f,NULL,(void*)fparams,optim_par);
            } else {
               multimin(numParamsUsed,params,&minVal,mtype,xmin,xmax,
                     &Minimizer::f,&Minimizer::f,NULL,(void*)fparams,optim_par);
            }

            if (info) {
               cerr << "Multimin failure.  No harm done, can try again." << endl;
            }

         } else if (method == GSL_SIM_ANN) {
            callsPerDisplay *= 4;
            double initialEnergy = minimand();
            //double initTemp = 1.0;  //(prec/initialEnergy);  //or sqrt since least-squares---?
            double initTemp = epsfcn * 10000.0;
            double numCools = size_t(1.0 + maxIter/double(numRetries));
            double dampFactor = pow(initTemp/myyprec, 1.0/double(numCools));

            gsl_siman_params_t gsp;
            gsp.n_tries = numRetries;
            gsp.iters_fixed_T = numRetries;
            gsp.step_size = mywos;
            gsp.k = 1.0;
            gsp.t_initial = initTemp;
            gsp.mu_t = dampFactor;  //1.003;   //magic number like k is
            gsp.t_min = myyprec;
            const gsl_rng_type* T;
            gsl_rng* r;

            gsl_rng_env_setup();

            T = gsl_rng_default;
            r = gsl_rng_alloc(T);
            void* x0_p = new SimanConfig(this, theTrial, theTrial->getSpec(), paramsCode);

            if (verbose) {
               for (vector<ostream*>::const_iterator it = outs->begin();
                    it != outs->end(); it++) {
                  (**it) << endl << "Doing " << maxIter << " evals by SA from temp " << initTemp
                         << " damped by " << IRutil::ftoa(dampFactor, 4) << endl
                         << "giving " << numCools << " cooling stages with " << numRetries
                         << " probes each." << endl;
               }
            }


            gsl_siman_solve(r, x0_p, Ef, takeStep, configDistance, printPosition,
                            //copyConfig, copyConstructConfig, destroyConfig,
                            NULL, NULL, NULL,
                            sizeof(SimanConfig), gsp);

            if (info) {
               cerr << "Simulated annealing failure.  No harm done, can try again." << endl;
            } else {

               SimanConfig* x0 = (SimanConfig*)x0_p;
               theTrial->setSpec(x0->mySpec);
            }
            callsPerDisplay /= 4;

         } else if (method == CMINPACK_LMDIF1) {  //This still has debugging print code

            int lwa = 8*numActiveTests + 40 + numActiveTests;

            cerr << "About to call lmdif1 with m = " << numActiveTests 
                 << " and n = " << numParamsUsed << "..." << endl;

            info = lmdif1(fcn, fparams, numActiveTests, numParamsUsed, params, 
                          testVals, myyprec, paramSwap, lmdifSwap, lwa);

            cerr << "And lmdif1 gave info = " << info << endl;

         } else if (method == CMINPACK_LMDIF) {

            cerr << "About to call lmdif with m = " << numActiveTests 
                 << " and n = " << numParamsUsed << "..." << endl;

            info = lmdif(fcn, fparams, numActiveTests, numParamsUsed, params, testVals,
                             myyprec, myxprec, mygprec, maxIter, epsfcn, diag, 1, mywos, 
                             callsPerDisplay, nfev, fjac, numActiveTests, paramSwap, qtf, wa1, wa2, wa3, wa4);

            cerr << "And lmdif gave info = " << info << endl;

         } else if (method == CMINPACK_HYBRD1) {

            cerr << "About to call hybrd1 with m = " << numActiveTests 
                 << " and n = " << numParamsUsed << "..." << endl;

            if (numParamsUsed == numActiveTests) {
               int lwa = 74;
               info = hybrd1(fcn2, fparams, numParamsUsed, params, testVals, myyprec, hwa, lwa);
            } else {
               cerr << "#active tests must == #active params to use HYBRD" << endl;
            }

            cerr << "And hybrd1 gave info = " << info << endl;

         } else if (method == CMINPACK_HYBRD) {

            cerr << "About to call hybrd with m = " << numActiveTests 
                 << " and n = " << numParamsUsed << "..." << endl;

            if (numParamsUsed == numActiveTests) {
               int lr = numParamsUsed*(numParamsUsed+1)/2;
               info = hybrd(fcn2, fparams, numParamsUsed, params, testVals, myyprec, maxIter, 
                            numParamsUsed, numParamsUsed, epsfcn, diag, 1, mywos,
                            callsPerDisplay, nfev, fjac, numParamsUsed, hwa, lr, qtf, wa1, wa2, wa3, wa4);
            } else {
               cerr << "#active tests must == #active params to use HYBRD" << endl;
            }

            cerr << "And hybrd gave info = " << info << endl;


         } else if (method == MPFIT_LMDIF) {

            mp_config* settings = new mp_config {
               myyprec,            //ftol
               myxprec,            //xtol
               mygprec,            //gtol
               epsfcn,             //epsfcn
               mywos*10000.0,      //stepfactor, common default is 100
               mygprec*0.001,      //covtol
               maxIter,            //maxiter
               0,                  //nfev---no limit on minimand calls
               callsPerDisplay,    //nprint
               0,                  //let variables be scaled internally == MODE in CMINPACK
               0,                  //do not enable check for infinite values
               0                   //mandatory 0 value
            };

            mp_result* results = new mp_result();

            cerr << "About to call mpfit with m = " << numActiveTests << " and n = " 
                 << numParamsSeen << " with " << numParamsUsed << " used and values " << endl;
            for (int i = 0; i < numParamsSeen; i++) {
               cerr << paramSettings[i].parname << ": " << allxs[i] << " in ["
                    << paramSettings[i].limits[0] << ", " << paramSettings[i].limits[1] << "]" << endl;
            }
            int initfv = mpfcn(numActiveTests, numParamsSeen, allxs, testVals, NULL, this);
            cerr << "Initial value " << initfv << " aka. " << minimand() << " from ";
            for (int j = 0; j < numActiveTests; j++) {
               cerr << testVals[j] << " ";
            }
            cerr << endl;

            info = mpfit(&Minimizer::mpfcn, numActiveTests, numParamsSeen, allxs,
                         paramSettings, settings, this, results);

            cerr << "And mpfit gave info = " << info << endl;
            delete(settings);
         }
#endif

         //The calls to f have already set the TrialSpec, so copy it to output.
         ots = theTrial->getSpec();
         
      } 
      //return val;
      //Caller will update the status of the params menu.

      if (verbose) {
         for (vector<ostream*>::const_iterator it = outs->begin();
              it != outs->end(); it++) {
            (**it) << endl << "Total number of minimand calls: " << numCalls << endl;
         }
      }

      return ots;
   } 


   /** Data structures and functions for GSL simulated annealing.
       Have side effect of setting the spec in the Trial.
    */
   struct SimanConfig {
      Minimizer* miniMe; //always points to this
      Trial* thisTrial;  //always points to this->theTrial
      TrialSpec mySpec;  //updated by copy each time.
      size_t paramsCode; //controls which parameters are active

      SimanConfig(Minimizer* m, Trial* t, TrialSpec spec, size_t code) 
       : miniMe(m), thisTrial(t), mySpec(spec), paramsCode(code)
      { }
      void copyp(SimanConfig *rhs) {
         miniMe = rhs->miniMe; 
         thisTrial = rhs->thisTrial;
         mySpec = rhs->mySpec;
         paramsCode = rhs->paramsCode;
      }
   };

   static void copyConfig (void* source, void* dest) {
      SimanConfig* src = (SimanConfig*)source;  //dynamic_cast<SimanConfig*>(source);
      SimanConfig* dst = (SimanConfig*)dest;  //dynamic_cast<SimanConfig*>(dest);
      dst->miniMe = src->miniMe;
      dst->thisTrial = src->thisTrial;
      dst->mySpec = src->mySpec;
      dst->paramsCode = src->paramsCode;
   }

   static void* copyConstructConfig (void* source) {
      SimanConfig* src = (SimanConfig*)source;  //dynamic_cast<SimanConfig*>(source);
      SimanConfig* dst = new SimanConfig(src->miniMe, src->thisTrial, src->mySpec, src->paramsCode);  
      return dst;
   }


   static void destroyConfig(void* xp) { }   //can do nothing


   static double Ef(void* xp) {
      SimanConfig* scp = (SimanConfig*)xp;  //dynamic_cast<SimanConfig*>(xp);
      return scp->miniMe->minimand();
   }
      
   static double configDistance(void* xp, void* yp) {
      SimanConfig* scx = (SimanConfig*)xp;  //dynamic_cast<SimanConfig*>(xp);
      SimanConfig* scy = (SimanConfig*)yp;  //dynamic_cast<SimanConfig*>(yp);
      double sumsq = 0.0;
      sumsq += IRutil::sqr(scx->mySpec.s - scy->mySpec.s);
      sumsq += IRutil::sqr(scx->mySpec.c - scy->mySpec.c);
      sumsq += IRutil::sqr(scx->mySpec.d - scy->mySpec.d);
      sumsq += IRutil::sqr(scx->mySpec.v - scy->mySpec.v);
      sumsq += IRutil::sqr(scx->mySpec.a - scy->mySpec.a);
      sumsq += IRutil::sqr(scx->mySpec.hm - scy->mySpec.hm);
      sumsq += IRutil::sqr(scx->mySpec.hp - scy->mySpec.hp);
      sumsq += IRutil::sqr(scx->mySpec.b - scy->mySpec.b);
      return sqrt(sumsq);
   }

   static void takeStep(const gsl_rng* r, void* xp, double step_size) {
      SimanConfig* scx = (SimanConfig*)xp;  //dynamic_cast<SimanConfig*>(xp);
      double u, inc;
      if ((scx->paramsCode >> 7) % 2) {
         u = gsl_rng_uniform(r);
         inc = (2.0*u - 1.0)*step_size;
         scx->mySpec.s *= (1.0 + inc);   //relative
         if (scx->mySpec.s < scx->miniMe->lowSpec.s || scx->mySpec.s > scx->miniMe->hiSpec.s) { 
            scx->mySpec.s *= (1.0 - inc)/(1.0 + inc);
         }
      }
      if ((scx->paramsCode >> 6) % 2) {
         u = gsl_rng_uniform(r);
         inc = (2.0*u - 1.0)*step_size;
         scx->mySpec.c *= (1.0 + inc);   //relative
         if (scx->mySpec.c < scx->miniMe->lowSpec.c || scx->mySpec.c > scx->miniMe->hiSpec.c) {
            scx->mySpec.c *= (1.0 - inc)/(1.0 + inc);
         }
      }
      if ((scx->paramsCode >> 5) % 2) {   //d is treated differently
         u = gsl_rng_uniform(r);
         inc = (2.0*u - 1.0)*200*step_size;  //200 is a magic number
         scx->mySpec.d += inc;
         if (scx->mySpec.d < scx->miniMe->lowSpec.d || scx->mySpec.d > scx->miniMe->hiSpec.d) { 
            scx->mySpec.d -= 2*inc;
         }
      }
      if ((scx->paramsCode >> 4) % 2) {
         u = gsl_rng_uniform(r);
         inc = (2.0*u - 1.0)*step_size;
         scx->mySpec.v *= (1.0 + inc);
         if (scx->mySpec.v < scx->miniMe->lowSpec.v || scx->mySpec.v > scx->miniMe->hiSpec.v) { 
            scx->mySpec.v *= (1.0 - inc)/(1.0 + inc);
         }
      }
      if ((scx->paramsCode >> 3) % 2) {
         u = gsl_rng_uniform(r);
         inc = (2.0*u - 1.0)*step_size;
         scx->mySpec.a *= (1.0 + inc);
         if (scx->mySpec.a < scx->miniMe->lowSpec.a || scx->mySpec.a > scx->miniMe->hiSpec.a) { 
            scx->mySpec.a *= (1.0 - inc)/(1.0 + inc);
         }
      }
      if ((scx->paramsCode >> 2) % 2) {
         u = gsl_rng_uniform(r);
         inc = (2.0*u - 1.0)*step_size;
         scx->mySpec.hm *= (1.0 + inc);
         if (scx->mySpec.hm < scx->miniMe->lowSpec.hm || scx->mySpec.hm > scx->miniMe->hiSpec.hm) { 
            scx->mySpec.hm *= (1.0 - inc)/(1.0 + inc);
         }
      }
      if ((scx->paramsCode >> 1) % 2) {
         u = gsl_rng_uniform(r);
         inc = (2.0*u - 1.0)*step_size;
         scx->mySpec.hp *= (1.0 + inc);
         if (scx->mySpec.hp < scx->miniMe->lowSpec.hp || scx->mySpec.hp > scx->miniMe->hiSpec.hp) { 
            scx->mySpec.hp *= (1.0 - inc)/(1.0 + inc);
         }
      }
      if ((scx->paramsCode) % 2) {
         u = gsl_rng_uniform(r);
         inc = (2.0*u - 1.0)*step_size;
         scx->mySpec.b *= (1.0 + inc);
         if (scx->mySpec.b < scx->miniMe->lowSpec.b || scx->mySpec.b > scx->miniMe->hiSpec.b) { 
            scx->mySpec.b *= (1.0 - inc)/(1.0 + inc);
         }
      }
      scx->thisTrial->setSpec(scx->mySpec);
   }

   static void printPosition(void* xp) {
      SimanConfig* scx = (SimanConfig*)xp;
      if (scx->miniMe->numCalls % 10 == 0) { cout << scx->mySpec.paramsPosition(); }
   }


   /** String output on top of what package libraries provide.
    */
   string method2str() const {
      switch(method) {
       case VWALK: 
         return "Two-level bitonic search on s and c only";
       case GSL_NM4: 
         return "GSL Nelder-Mead (old version)";
       case GSL_NM6: 
         return "GSL Nelder-Mead (newer version)";
       case GSL_NM7:
         return "GSL Nelder-Mead (random orientations)";
       case GSL_SIM_ANN:
         return "GSL Simulated Annealing";
       case CMINPACK_LMDIF: 
         return "CMINPACK Levenberg-Marquardt (no derivatives)";
       case CMINPACK_LMDIF1:
         return "CMINPACK Levenberg-Marquardt (simplified call)";
       case CMINPACK_HYBRD:
         return "CMINPACK hybrid Powell method (no derivatives)";
       case CMINPACK_HYBRD1:
         return "CMINPACK hybrid Powell method (simplified call)";
       case MPFIT_LMDIF: 
         return "MPFIT Levenberg-Marquardt (no derivatives)";
       default:
         return "Unknown fitting method";
      }
   };

 
   string sked2str(SKED sked) const {
      switch(sked) {
       case UNIT_SKED:
         return "unitsked";
       case SQRT_SKED:
         return "sqrtsked";
       case LIN_SKED:
         return "linsked";
       case QUAD_SKED:
         return "quadsked";
       case INVVAR_SKED:
         return "invvarsked";
       case SQRT_ALLWT:
         return "sqrtsked";
       case LIN_ALLWT:
         return "linsked";
       case QUAD_ALLWT:
         return "quadsked";
       default:
         return "unknown sked";
      }
   }

 
   inline operator string() const {
      string res = method2str() + " with active tests and weights:\n";
      map<MINIMAND,double>::const_iterator citr = minibook.begin();
      while (citr != minibook.end()) {
         MINIMAND kind = (*citr).first; 
         string mulstr = IRutil::ftoa((*citr).second);
         string skind = "";
         switch(kind) { 
          case PERCFIT: 
            skind = "Percentile fit with L2 distance: " + mulstr + "\n"; 
            break; 
          case ML: 
            skind = "Max-likelihood of played moves: " + mulstr + "\n"; 
            break; 
          case BINS:
            skind = "Fit percentages of hits in bins of probabilities: " + mulstr + "\n";
            break;
          case FALLOFF:
            skind = "Fit of scaled error: " + mulstr + "\n";
            break;
          case FIRST_LINE:
            skind = "Fit of engine first line: " + mulstr + "\n";
            break;
          case SECOND_LINE:
            skind = "Fit of engine second line: " + mulstr + "\n";
	    break;
	  case THIRD_LINE:
            skind = "Fit of engine third line: " + mulstr + "\n";
            break;
          case ETV:
            skind = "Fit of equal-top-value moves to index " + IRutil::itoa(equalTopIndexLimit) + ": " + mulstr + "\n";
            break;
          case INDEX_FIT:
            skind = "Index fit of [" + IRutil::itoa(indexFitStart) + "," + IRutil::itoa(indexFitEnd)
                        + "], " + sked2str(indexFitSked) + ": " + mulstr + "\n";
            break;
          case INDEX_DIFF:
            skind = "Index diff of [" + IRutil::itoa(indexDiffStart) + "," + IRutil::itoa(indexDiffEnd)
                        + "], " + sked2str(indexDiffSked) + ": " + mulstr + "\n";
            break;
          case ERROR1: 
            skind = "Error frequency in [" + IRutil::ftoa(error1Low) + "," + IRutil::ftoa(error1Hi)
                        + "]: " + sked2str(error1Sked) + ": " + mulstr + "\n";
            break;
          case ERROR2:
            skind = "Error frequency in [" + IRutil::ftoa(error2Low) + "," + IRutil::ftoa(error2Hi)
                        + "]: " + sked2str(error2Sked) + ": " + mulstr + "\n";
            break;
          default: 
            skind = "Unknown regression: " + mulstr + "\n"; 
            break; 
         } 
         res += skind;
         citr++;
      }
      
      res += "bounds s in [" + IRutil::ftoa(lowSpec.s) 
                         + ".." + IRutil::ftoa(hiSpec.s) + "], c in ["  
                         + IRutil::ftoa(lowSpec.c) + ".."  
                         + IRutil::ftoa(hiSpec.c) + "],  d in ["
                         + IRutil::ftoa(lowSpec.d) + ".."
                         + IRutil::ftoa(hiSpec.d) + "], v in ["
                         + IRutil::ftoa(lowSpec.v) + ".."
                         + IRutil::ftoa(hiSpec.v) + "], a in ["
                         + IRutil::ftoa(lowSpec.a) + ".."
                         + IRutil::ftoa(hiSpec.a) + "], hm in ["
                         + IRutil::ftoa(lowSpec.hm) + ".."
                         + IRutil::ftoa(hiSpec.hm) + "], hp in ["
                         + IRutil::ftoa(lowSpec.hp) + ".."
                         + IRutil::ftoa(hiSpec.hp) + "], b in ["
                         + IRutil::ftoa(lowSpec.b) + ".."
                         + IRutil::ftoa(hiSpec.b) + "], of\n";

      res += string(*theTrial); 
      return res; 
   } 


   //Rest of code is ONLY used for the "veeFinder" 2-dim. bitonic search routines
 
 private: 
 
   /** Helper function for veeFinders.  Assumes the following true at call: 
       INV: midVal <= f(low), midVal <= f(hi). 
       Returns a local minimum (point not value) of f to approximation 
       (hi - low)/2^(depth+1).  Acts as though Ran(f) is V-shaped. 
       Reports some but not all cases where f has more than one minimum. 
    */ 
   double vfh(Monic f, double low, double mid, double hi, double midVal) const;


 public: 
   Trial* getTrial() const { return theTrial; }

   inline double f1(const double s) const { 
      theTrial->setS(s); 
      return minimand(); 
   } 
   inline double f2(const double c) const { 
      theTrial->setC(c); 
      return minimand(); 
   } 
   inline double vfC(const double s) const {   // find best c for a given s 
      Monic f = &Minimizer::f2; 
      theTrial->setS(s); 
      double midC = geometricMeans ? 2*lowSpec.c*hiSpec.c/(lowSpec.c + hiSpec.c) : (lowSpec.c + hiSpec.c)/2; 
      return vfh(f,lowSpec.c,midC,hiSpec.c, (this->*f)(midC)); 
   } 
   inline double vfCVal(const double s) const { 
      //return value given by best c for s 
      theTrial->setC(vfC(s)); 
      return minimand(); 
   } 
   inline double vfS(const double c) const { 
      // find best s for a given c 
      Monic f = &Minimizer::f1; 
      theTrial->setC(c); 
      double midS = geometricMeans ? 2*lowSpec.s*hiSpec.s/(lowSpec.s+hiSpec.s) 
                                       : (lowSpec.s + hiSpec.s)/2; 
      return vfh(f,lowSpec.s,midS,hiSpec.s, (this->*f)(midS)); 
   } 
   inline double vfSVal(const double c) const { 
      //return value given by best s for c 
      theTrial->setS(vfS(c)); 
      return minimand(); 
   } 
   inline double veeFinder1() const { 
      Monic v = &Minimizer::vfCVal; 
      double midS = geometricMeans ? 2*lowSpec.s*hiSpec.s/(lowSpec.s+hiSpec.s) 
                                       : (lowSpec.s + hiSpec.s)/2; 
      return vfh(v,lowSpec.s,midS,hiSpec.s, (this->*v)(midS)); 
   } 
   inline double veeFinder2() const { 
      Monic v = &Minimizer::vfSVal; 
      double midC = geometricMeans ? 2*lowSpec.c*hiSpec.c/(lowSpec.c + hiSpec.c) : (lowSpec.c + hiSpec.c)/2; 
      return vfh(v,lowSpec.c,midC,hiSpec.c, (this->*v)(midC)); 
   } 
   inline double veeFinder() const { 
      return (sFirst ? veeFinder1() : veeFinder2()); 
   } 
 
   /** Walk out from the trial's initial (s,c) point rather than in from 
       the Minimizer object's overall boundaries.  Otherwise functions are 
       similar to above---longer implementations are outside the class. 
    */ 
   double vWalkC(const double s) const; 
   double vWalkCVal(const double s) const; 
   double vWalkS(const double c) const; 
   double vWalkSVal(const double c) const; 
   double veeWalker1() const; 
   double veeWalker2() const; 
 
   inline double veeWalker() const { 
      return (sFirst ? veeWalker1() : veeWalker2()); 
   } 
 
 
   inline double bestSFor(const double c) const { 
      return (walkOut ? vWalkS(c) : vfS(c)); 
   } 
 
   inline double bestCFor(const double s) const { 
      return (walkOut ? vWalkC(s) : vfC(s)); 
   } 
 
}; //end of class Minimizer, implementation of V-walk methods follows (can ignore)
 
 
#endif    //end of #ifndef __IR_MINIMIZER_H__ 
 
 
 
//File-------------------Minimizer.cpp---------------------------------- 
 
#ifndef __IR_MINIMIZER_CPP__ 
#define __IR_MINIMIZER_CPP__ 

#ifndef __IR_MINIMIZER_H__
#include "Minimizer.h"
#endif
 
/** Helper function for veeFinders.  Assumes the following true at call: 
    INV: midVal <= f(low), midVal <= f(hi). 
    Returns a local minimum (point not value) of f to approximation 
    (hi - low)/2^(depth+1).  Acts as though Ran(f) is V-shaped. 
    Reports some but not all cases where f has more than one minimum. 
 */ 
double Minimizer::vfh(Monic f, double low, double mid, double hi, double midVal) const { 
   while (hi - low > yprec) { 
      if (verbose) { 
         cout << "."; 
         flush(cout); 
      } 
      double q1 = geometricMeans ? 2.0*low*mid/(low + mid) : (low + mid)/2.0; 
      double q3 = geometricMeans ? 2.0*mid*hi/(mid + hi)   : (mid + hi)/2.0; 
      double q1Val = (this->*f)(q1); 
      double q3Val = (this->*f)(q3); 
 
      if (q1Val < midVal) {        //so by INV, q1Val < lowVal too. 
         if (q3Val < midVal) { 
            if (verbose) { 
               for (vector<ostream*>::const_iterator it = outs->begin(); 
                    it != outs->end(); it++) { 
 
                  (**it) << "Found a W: f(" << q1 << ") = " << q1Val 
                         << ", f(" << mid << ") = " << midVal 
                         << ", f(" << q3 << ") = " << q3Val << endl; 
               } 
            } 
            if (q1Val < q3Val) { 
               hi = mid; mid = q1; midVal = q1Val; 
            } else {               //so q3Val <= q1Val <= midVal <= hiVal 
               low = mid; mid = q3; midVal = q3Val; 
            } 
         } else { 
            hi = mid; mid = q1; midVal = q1Val; 
         } 
      } else { 
         if (q3Val < midVal) { 
            low = mid; mid = q3; midVal = q3Val; 
         } else {                  //midVal is <= both q1Val,q3Val 
            low = q1; hi = q3; 
         } 
      } 
   } 
 
   if (verbose) { 
      cout << "Done, with value "; 
      for (vector<ostream*>::const_iterator it = outs->begin(); 
           it != outs->end(); it++) { 
         (**it) << fixed << setprecision(6) 
                << "f(" << mid << ") = " << midVal << endl; 
      } 
   } 
   return mid; 
} 


/** Walk out from the trial's initial (s,c) point rather than in from 
 the Minimizer object's overall boundaries. 
 */ 
double Minimizer::vWalkC(const double s) const { 
Monic f = &Minimizer::f2; 
theTrial->setS(s);      //s is unchanged for this run 
double c1 = theTrial->getC(); 
double c1Val = minimand();    //uses c1, == f(c1). 
double c2 = c1 + walkOutStep; 
double c0 = c1 - walkOutStep; 
double c2Val = (this->*f)(c2); 
double c0Val = (this->*f)(c0); 
if (c1Val < c2Val && c1Val < c0Val) { 
    return vfh(f,c0,c1,c2,c1Val); 
   } 
   if (c1Val > c2Val && c1Val > c0Val) { cout << "Found an immediate W\n"; } 
   int sg = c0Val < c2Val ? -1 : +1; 
   int mul = 2; 
   double cNew = c1 + mul*sg*walkOutStep; 
   double cNewVal; 
   double cMid = c1 + sg*walkOutStep;  //is c0 or c2 
   double cMidVal = (sg == -1 ? c0Val : c2Val); 
   double cBack = c1; 
   double cBackVal = c1Val;  //INV: cMidVal <= cBackVal 
   double cBound = (sg == -1 ? lowSpec.c : hiSpec.c); 
   while (sg*cNew <= sg*cBound && (cNewVal = (this->*f)(cNew)) < cMidVal) { 
      cBack = cMid; 
      cBackVal = cMidVal; 
      cMid = cNew; 
      cMidVal = cNewVal; 
      mul *= 2; 
      cNew = c1 + mul*sg*walkOutStep; 
   } 
   if (cNew < lowSpec.c) { 
      cout << "LowC boundary hit on inner walk for s = " << s 
           << " from c = " << c1 << endl; 
      cNew = lowSpec.c; 
      cNewVal = (this->*f)(lowSpec.c); //no need to check if > cMidVal... 
   } else if (cNew > hiSpec.c) { 
      cout << "HiC boundary hit on inner walk for s = " << s 
           << " from c = " << c1 << endl; 
      cNew = hiSpec.c; 
      cNewVal = (this->*f)(hiSpec.c);  //i.e. we assume boundaries are not minima 
   } else { 
      //do nothing 
   } 
   return vfh(f,cBack,cMid,cNew,cMidVal); 
} 
 
double Minimizer::vWalkCVal(const double s) const { 
   //return value given by best c for s 
   theTrial->setC(vWalkC(s)); 
   return minimand(); 
} 
 
double Minimizer::vWalkS(const double c) const { 
   Monic f = &Minimizer::f1; 
   theTrial->setC(c);      //c is unchanged for this run 
   double s1 = theTrial->getS(); 
   double s1Val = minimand();    //uses s1, == f(s1). 
   double s2 = s1 + walkOutStep; 
   double s0 = s1 - walkOutStep; 
   double s2Val = (this->*f)(s2); 
   double s0Val = (this->*f)(s0); 
   if (s1Val < s2Val && s1Val < s0Val) { 
       return vfh(f,s0,s1,s2,s1Val); 
   } 
   if (s1Val > s2Val && s1Val > s0Val) { 
      cout << "Found an immediate W\n"; 
   } 
   int sg = s0Val < s2Val ? -1 : +1; 
   int mul = 2; 
   double sNew = s1 + mul*sg*walkOutStep; 
   double sNewVal; 
   double sMid = s1 + sg*walkOutStep;  //is s0 or s2 
   double sMidVal = (sg == -1 ? s0Val : s2Val); 
   double sBack = s1; 
   double sBackVal = s1Val;  //INV: sMidVal <= sBackVal 
   double sBound = (sg == -1 ? lowSpec.s : hiSpec.s); 
   while (sg*sNew <= sg*sBound 
             && (sNewVal = (this->*f)(sNew)) < sMidVal) { 
      sBack = sMid; 
      sBackVal = sMidVal; 
      sMid = sNew; 
      sMidVal = sNewVal; 
      mul *= 2; 
      sNew = s1 + mul*sg*walkOutStep; 
   } 
   if (sNew < lowSpec.s) { 
      cout << "LowS boundary hit on inner walk for c = " << c 
           << " from s = " << s1 << endl; 
      sNew = lowSpec.s; 
      sNewVal = (this->*f)(lowSpec.s); //need not check > sMidVal... 
   } else if (sNew > hiSpec.s) { 
      cout << "HiS boundary hit on inner walk for c = " << c 
           << " from s = " << s1 << endl; 
      sNew = hiSpec.s; 
      sNewVal = (this->*f)(hiSpec.s);  //i.e. assume bounds not minima 
   } else { 
      //do nothing 
   } 
   return vfh(f,sBack,sMid,sNew, sMidVal); 
} 
 
double Minimizer::vWalkSVal(const double c) const { 
   //return value given by best s for c 
   theTrial->setS(vWalkS(c)); 
   return minimand(); 
} 
 
double Minimizer::veeWalker1() const { 
   double c = theTrial->getC(); 
   Monic w = &Minimizer::vWalkCVal; 
   double s1 = theTrial->getS(); 
   double s1Val = (this->*w)(s1); 
   double s2 = s1 + walkOutStep; 
   double s0 = s1 - walkOutStep; 
   double s2Val = (this->*w)(s2); 
   double s0Val = (this->*w)(s0); 
   if (s1Val < s2Val && s1Val < s0Val) { 
       return vfh(w,s0,s1,s2,s1Val); 
   } 
   if (s1Val > s2Val && s1Val > s0Val) { 
      cout << "Found an immediate W\n"; 
   } 
   int sg = s0Val < s2Val ? -1 : +1; 
   int mul = 2; 
   double sNew = s1 + mul*sg*walkOutStep; 
   double sNewVal; 
   double sMid = s1 + sg*walkOutStep;  //is s0 or s2 
   double sMidVal = (sg == -1 ? s0Val : s2Val); 
   double sBack = s1; 
   double sBackVal = s1Val;  //INV: sMidVal <= sBackVal 
   double sBound = (sg == -1 ? lowSpec.s : hiSpec.s); 
   while (sg*sNew <= sg*sBound 
             && (sNewVal = (this->*w)(sNew)) < sMidVal) { 
      sBack = sMid; 
      sBackVal = sMidVal; 
      sMid = sNew; 
      sMidVal = sNewVal; 
      mul *= 2; 
      sNew = s1 + mul*sg*walkOutStep; 
   } 
   if (sNew < lowSpec.s) { 
      cout << "LowS boundary hit on outer walk for c = " << c 
           << " from s = " << s1 << endl; 
      sNew = lowSpec.s; 
      sNewVal = (this->*w)(lowSpec.s); //need not check > sMidVal... 
   } else if (sNew > hiSpec.s) { 
      cout << "HiS boundary hit on outer walk for c = " << c 
           << " from s = " << s1 << endl; 
      sNew = hiSpec.s; 
      sNewVal = (this->*w)(hiSpec.s);  //i.e. assume bounds not minima 
   } else { 
      //do nothing 
   } 
   return vfh(w,sBack,sMid,sNew, sMidVal); 
} 
 
 
double Minimizer::veeWalker2() const { 
   double s = theTrial->getS(); 
   Monic w = &Minimizer::vWalkSVal; 
   double c1 = theTrial->getC(); 
   double c1Val = (this->*w)(c1); 
   double c2 = c1 + walkOutStep; 
   double c0 = c1 - walkOutStep; 
   double c2Val = (this->*w)(c2); 
   double c0Val = (this->*w)(c0); 
   if (c1Val < c2Val && c1Val < c0Val) { 
       return vfh(w,c0,c1,c2,c1Val); 
   } 
   if (c1Val > c2Val && c1Val > c0Val) { cout << "Found an immediate W\n"; } 
   int sg = c0Val < c2Val ? -1 : +1; 
   int mul = 2; 
   double cNew = c1 + mul*sg*walkOutStep; 
   double cNewVal; 
   double cMid = c1 + sg*walkOutStep;  //is c0 or c2 
   double cMidVal = (sg == -1 ? c0Val : c2Val); 
   double cBack = c1; 
   double cBackVal = c1Val;  //INV: cMidVal <= cBackVal 
   double cBound = (sg == -1 ? lowSpec.c : hiSpec.c); 
   while (sg*cNew <= sg*cBound && (cNewVal = (this->*w)(cNew)) < cMidVal) { 
      cBack = cMid; 
      cBackVal = cMidVal; 
      cMid = cNew; 
      cMidVal = cNewVal; 
      mul *= 2; 
      cNew = c1 + mul*sg*walkOutStep; 
   } 
   if (cNew < lowSpec.c) { 
      cout << "LowC boundary hit on outer walk for s = " << s 
           << " from c = " << c1 << endl; 
      cNew = lowSpec.c; 
      cNewVal = (this->*w)(lowSpec.c); //no need to check if > cMidVal... 
   } else if (cNew > hiSpec.c) { 
      cout << "HiC boundary hit on outer walk for s = " << s 
           << " from c = " << c1 << endl; 
      cNew = hiSpec.c; 
      cNewVal = (this->*w)(hiSpec.c);  //i.e. we assume boundaries are not minima 
   } else { 
      //do nothing 
   } 
   return vfh(w,cBack,cMid,cNew,cMidVal); 
} 
 
 
#endif  //end of #ifndef __IR_MINIMIZER_CPP__ 
 
 
 
//File-----------------------Menus.h--------------------------------------- 
 
#ifndef __IR_MENUS_H__ 
#define __IR_MENUS_H__ 
 
//---------UNIFORM MENU SYSTEM, WITH AUTOMATIC LOGGING OF CHOICES----------- 
 
class Logging { 
 public: 
   virtual void loggedReadString(string& item, bool endLine = false, 
                                 bool write = true) const = 0; 
   virtual void loggedReadInt(int& item, bool endLine = false, 
                              bool write = true) const = 0; 
   virtual void loggedReadDouble(double& item, bool endLine = false, 
                                 bool write = true) const = 0; 

   //can't write a virtual template function in C++! 
   virtual void loggedWrite(const string& st, bool endLine = false)  const = 0; 
   virtual string loggedGetline() const = 0; 
   virtual bool atEOF() const = 0; 
   virtual bool usingCin() const = 0; 
   virtual ~Logging() { } 
}; 
 
 
/** Menu class allowing user selection by number *or* by name---importantly, 
    it logs the name via callback to the held "Logging" (->Ensemble) object. 
    Designed to be used in-tandem with an enum---the caller writes a switch 
    with the int returned by readChoice() over the enum. 
    Assumes the enum begins at 0, and otherwise knows nothing about it. 
    Employs special constants with int values < 0 for other status info. 
    Allows displayed menu to begin with "1" or larger indices, but keeps 
    the returned index zero-based.  Provides several menu-display options. 
    *Does not encourage toggling*---toggling makes the logged commands 
    harder to read because meaning depends on non-local context. 
    It might be a good idea to allow int entry only when ensp->isUsingCin(). 
 
    This base class governs display and iteration by the enum's indices, not 
    by the map's sorting (which is alphabetical by the menu option's name). 
    Intended---perhaps dubiously---for derivation to classes that can change 
    the indexing to alphabetical, and build other behavior on top of this. 
    The main dubious aspect is that alpha-indexing runs apart from the idea of 
    using an enum, and mandates returning the user choice as a string not int. 
 */ 
class EnumMenu {   //holds a Logging object for callbacks to loggedRead* 
 protected: 
   struct Entry { 
      int index;          //settable by DynamicMenu etc. 
      const string name; 
      string description; //ditto 
      string status; 
      bool resetToDefault; 
      bool starred; 
      const bool novel; 
      //derived field 
      const string defaultStatus; 
      const bool defaultStarred; 
 
      Entry(int i, const string& n, const string& desc, const string& s,
            bool rtd, bool st, bool nv) 
         : index(i), name(IRutil::trim(n)), description(IRutil::trim(desc)),  
           status(IRutil::trim(s)), resetToDefault(rtd), starred(st), novel(nv), 
           defaultStatus(IRutil::trim(s)), defaultStarred(st) 
      { } 
      ~Entry() { } 
   }; 
 
   Logging* ensp; 
   map<string,Entry*> entries; 
   int numItems;            //given but not fixed at creation 
   vector<string> names;    //governs mapping of indices to names 
   int firstDisplayedIndex; //not const since mutatable by descendants. 
   bool namesAfter; 
   bool padNames;           //relevant only if !namesAfter 
   bool padDescriptions;
   string preamble; 
   string postamble; 
   bool cancelable; 
   bool speakMoreOptions; 
   bool screenAnyway; 
   int maxNameLength; 
   int maxDescriptionLength;
 
 public: 
   static const int INVALID_CHOICE = -1; 
   static const int MORE_CHOICE = -2; 
   static const int CANCEL_CHOICE = -3; 
   static const int STREAM_END_CHOICE = -4; 
   const string INVALID_NAME;   // = "INVALID_NAME";  //not logged 
   const string MORE_NAME;      // = string("moreOptions").c_str();     //logged 
   const string CANCEL_NAME;    // = "cancelChoice";   //logged 
   const string STREAM_END_NAME;//= "STREAM_END";    //not logged 
 
 private: 
   /** Displays entries with "firstDisplayedIndex" offset added to "true" 
       indices, and with names before or after menu-item descriptions. 
    */ 
   void displayEntry(const Entry& e, int offset = 0) const { 
      int indexWidth = (numItems <= 10 - firstDisplayedIndex - offset ? 1 : 2); 
                                   //presume numItems <= 99 
      int numDigits = (e.index <= 9 - firstDisplayedIndex - offset ? 1 : 2); 
      if (e.novel) { cout << IRutil::DASHLINE << endl; } 
      string sep = e.starred ? "]*" : "] "; 
      string pre = (numDigits == 1 && indexWidth == 2) ? " " : ""; 
      bool hasDesc = e.description.size() > 0 && e.status.size() > 0;
      cout << pre << "[" << setw(numDigits) << right 
           << (e.index + firstDisplayedIndex) << sep; 
      if (namesAfter) { 
         cout << e.description << " <" << e.name << "> " 
              << e.status << endl; 
      } else { 
         cout << left << setw(padNames ? maxNameLength : 1) << e.name << ": " 
              << setw((hasDesc && padDescriptions) ? maxDescriptionLength : 0)
              << e.description << (hasDesc ? ": " : "") << e.status << endl; 
      } 
   } 
 
 
 public: 
   EnumMenu(Logging* enp, int gsize, int fdi = 1, bool na = false, 
            bool pa = false, const string& pre = "", const string& post = "", 
            bool ca = false, bool smo = false, bool sa = false) 
      : ensp(enp), entries(map<string,Entry*>()), numItems(gsize), 
        names(vector<string>(gsize)), firstDisplayedIndex(fdi), 
        namesAfter(na), padNames(pa), padDescriptions(pa),
        preamble(pre), postamble(post), cancelable(ca), speakMoreOptions(smo), 
        screenAnyway(sa), maxNameLength(0), maxDescriptionLength(0),
        INVALID_NAME("INVALID_NAME"), MORE_NAME("moreOptions"),
        CANCEL_NAME("cancelChoice"), STREAM_END_NAME("STREAM_END")

   { } 
 
   virtual ~EnumMenu() { }  //will null not delete the ensp pointer 
 
   int size() const { return numItems; } 
 
   bool success(int i) const { 
      return i >= 0 && i < numItems;   //zero-basedness of true index 
   } 
 
   string nameOf(int i) {   //checked 
      if (i < numItems) { 
         return names.at(i); 
      } else { 
         cerr << "Invalid index, returning empty string ..." << endl; 
         return ""; 
      } 
   } 

   int indexOf(string name) {
      for (int i = 0; i < numItems; i++) {
         if (names.at(i) == name) {
            return i;
         }
      }
      cerr << "Name " << name << " not found." << endl;
      return -1;
   }
 
   void addEntry(int index, const string& nm, const string& desc,
                 const string& status = "",
                 bool rd = true, bool starred = false, bool novel = false) { 
      string name = IRutil::trim(nm); //assumes will not be a duplicate! 
      if (index < numItems) { 
         names.at(index) = name; 
      } else if (index == numItems) { 
         names.push_back(name); 
         numItems++; 
      } else { 
         cout << "Invalid entry index " << index << ", sorry." << endl; 
         return; 
      } //so control past here means success.  OK not to delete next
      entries[name] = new Entry(index,name,desc,status,rd,starred,novel); 
      if (name.size() > maxNameLength) { 
         maxNameLength = name.size(); 
      } 
      if (desc.size() > maxDescriptionLength) {
         maxDescriptionLength = desc.size();
      }
   } 
 
   virtual void addEntry(const string& name, const string& desc,
                         const string& status = "", 
                bool rd = true, bool starred = false, bool novel = false) { 
      addEntry(numItems, name, desc, status, rd, starred, novel); 
   } 
 
   void resetDefaults() { 
      for (map<string,Entry*>::iterator it = entries.begin(); 
           it != entries.end(); it++) { 
         if (it->second->resetToDefault) { 
            it->second->status = it->second->defaultStatus; 
            it->second->starred = it->second->defaultStarred; 
         } 
      } 
   } 
 
 
   virtual void showMenu(int offset = 0) { 
      if (preamble != "") { cout << preamble << endl; } 
      for (int i = 0; i < numItems; i++) { 
         displayEntry(*(entries[names.at(i)]));  //not const since map lookup 
      } 
      if (postamble != "") { cout << postamble << endl; } 
      if (cancelable || speakMoreOptions) { 
         cout << "Enter "; 
         if (cancelable) { 
            cout << CANCEL_CHOICE << "/" << CANCEL_NAME << " to cancel"; 
            if (speakMoreOptions) { 
               cout << "; " << MORE_CHOICE << "/" << MORE_NAME 
                    << " for more options."; 
            } else { 
               cout << "."; 
            } 
         } else { 
            cout << MORE_CHOICE << "/" << MORE_NAME << " for more options."; 
         } 
         cout << endl; 
      } 
   } 
 
   bool isStarred(const string& name) {                 //unchecked! 
      bool st = entries[name]->starred; 
      return entries[name]->starred; 
   } 
   bool isStarred(int i) { 
      return success(i) && isStarred(names.at(i)); 
   } 
   void setStarred(const string& name, bool starIt) {   //unchecked! 
      entries[name]->starred = starIt; 
   } 
   void setStarred(int i, bool starIt) {         //checked 
      if (success(i)) { 
         setStarred(names.at(i),starIt); 
      } else { 
         cout << "Invalid entry index " << i << "in setStarred, sorry." << endl; 
      } 
   } 
   void clearStars() { 
      for (map<string,Entry*>::iterator it = entries.begin(); 
           it != entries.end(); it++) { 
         it->second->starred = false; 
      } 
   } 

   void setDescription(const string& name, const string& newDescription) {
      entries[name]->description = IRutil::trim(newDescription);
   }
   void setDescription(int i, const string& newDescription) {
      if (i < numItems) {
         setDescription(names.at(i), newDescription);
      } else {
         cout << "Invalid entry index " << i << "in setDescription, sorry." << endl;
      }
   }

   string getDescription(const string& name) const {
      for (map<string,Entry*>::const_iterator it = entries.begin();
           it != entries.end(); it++) {
         if ((*it).first == name) { return ((*it).second->description); }
      }
      return "";
   }
   string getDescription(int i) const {
      return getDescription(names.at(i));
   }

   void setStatus(const string& name, const string& newStatus) { 
      entries[name]->status = IRutil::trim(newStatus); 
   } 
   void setStatus(int i, const string& newStatus) { 
      if (i < numItems) { 
         setStatus(names.at(i), newStatus); 
      } else { 
         cout << "Invalid entry index " << i << "in setStatus, sorry." << endl; 
      } 
   } 
   string getStatus(const string& name) { 
      return entries[name]->status; 
   } 
   string getStatus(int i) { 
      if (i < numItems) { 
         return getStatus(names.at(i)); 
      } else { 
         cout << "Invalid entry index " << i << "in getStatus, returning empty string..." << endl; 
         return ""; 
      } 
   } 
 
   int getFDI() const { return firstDisplayedIndex; } 
   void setPreamble(const string& pre) { preamble = pre; } 
   void setPostamble(const string& post) { postamble = post; } 
   void setScreen(bool sa) { screenAnyway = sa; } 
 
   /** Single master reader and logger of all menu and catalog choices. 
       Skips over lines beginning with the IR-comment string. 
       Admittedly a kludge, clean up by putting more responsibility on caller? 
       Allows use by another routine when other element(s) are starred.
    */ 
   virtual int readChoice(bool displayMenu = true, bool specialGo = false) { 
      int choice; 
      string st; 
      if (displayMenu && (ensp->usingCin() || screenAnyway)) { 
         showMenu(); 
      } 
      ensp->loggedReadString(st,false,false);   //suppresses writing to the log 
      st = IRutil::trim(st); 
      while (IRutil::isIRComment(st) && !ensp->atEOF()) { 
         ensp->loggedWrite(st,false); 
         ensp->loggedGetline();      //consumes trailing newline too 
         ensp->loggedWrite(st,true); //append newline back 
         if (!ensp->atEOF()) { 
            ensp->loggedReadString(st,false,true); //OK to write any whitespace 
            //(**INPP) >> st; 
            st = IRutil::trim(st); 
         } else { 
            st = ""; 
         } 
      } 
      if (st == "") {           //stream has failed and caller didn't catch it 
         return STREAM_END_CHOICE;   //should clean stream and try to continue 
      } 
      if (firstDisplayedIndex <= 0 && st == "0") {  //user might have said 0 
         ensp->loggedWrite(nameOf(0),false); 
         return 0; 
      } //else---so purposeful int i is nonzero, might be "cancel" or "more..." 
 
      int i = atoi(st.c_str());         //returns 0 if st does not parse to int 
      if (i == 0) {                     //figure user entered a name 
         ensp->loggedWrite(st,false);   //we log the name whether found or not 
 
         map<string,Entry*>::iterator it = entries.find(st); 
         if (it != entries.end()) { 
            choice = it->second->index;  //true enum index, not "+ 1" 
         } else if (st == MORE_NAME) { 
            return MORE_CHOICE; 
         } else if (st == CANCEL_NAME) { 
            return CANCEL_CHOICE; 
         } else if (specialGo && (st == "0" || st == "go" || st == "OK" || st == "ok")) {
            return -5;   //kludge: == GoMenu::GO_CHOICE;
         } else { 
            cerr << "Invalid name, returning " << INVALID_CHOICE << "." << endl; 
            return INVALID_CHOICE; 
         } 
      } else if (success(i - firstDisplayedIndex)) { 
         choice = i - firstDisplayedIndex; 
         ensp->loggedWrite(nameOf(choice),false); 
         if (i == 1 && specialGo) { return -6; } //double kludge
      } else if (i == MORE_CHOICE) { 
         ensp->loggedWrite(MORE_NAME,false);  //don't start new log line 
         choice = i; 
      } else if (i == CANCEL_CHOICE) { 
         ensp->loggedWrite(CANCEL_NAME,true); //start new line since cancel 
         choice = i; 
      } else { 
         cerr << "Invalid choice, returning " << INVALID_CHOICE << "." << endl; 
         choice = INVALID_CHOICE; 
         ensp->loggedWrite(IRutil::itoa(choice),false); //yes, log the "-1" too 
      } 
      return choice; 
   } 
}; 
 
/*
const string EnumMenu::INVALID_NAME = "INVALID_NAME";  //not logged 
const string EnumMenu::MORE_NAME = "moreOptions";      //logged 
const string EnumMenu::CANCEL_NAME = "cancelChoice";   //logged 
const string EnumMenu::STREAM_END_NAME = "STREAM_END"; //not logged 
*/
 
/** Legislates that 0 is used to mean "OK" or "go" or "submit"
   EnumMenu(Logging* enp, int gsize, int fdi = 1, bool na = false,
            bool pa = false, const string& pre = "", const string& post = "",
            bool ca = false, bool smo = false, bool sa = false)
      : ensp(enp), entries(map<string,Entry*>()), numItems(gsize),
        names(vector<string>(gsize)), firstDisplayedIndex(fdi),
        namesAfter(na), padNames(pa), preamble(pre), postamble(post),
        cancelable(ca), speakMoreOptions(smo), screenAnyway(sa),
        maxNameLength(0)

 */
class GoMenu : public EnumMenu {
 public: 
   static const int GO_CHOICE = -5;
   const string GO_NAME;

   GoMenu(Logging* enp, int gsize, int fdi = 1, bool na = false,
         bool pa = false, const string& pre = "", const string& post = "",
         bool ca = false, bool smo = false, bool sa = false)
    : EnumMenu(enp,gsize,fdi,na,pa,pre,post,ca,smo,sa), GO_NAME("go")
   {
      //setPostamble("Enter 0 or go or OK or ok to submit.");
   }

   //virtual void showMenu(int offset = 0) {
      //setPostamble("Enter 0 or go or OK or ok to submit.");
      //EnumMenu::showMenu(offset);
      //cout << "Enter " << GO_CHOICE << " or " << GO_NAME << " to submit." << endl;
   //}

   virtual int readChoice(bool displayMenu = true) {
      return EnumMenu::readChoice(displayMenu, true);  //gives "go/OK/ok" special status
   }

};

//const string GoMenu::GO_NAME = "go";
 
 
//class DynamicMenu : public EnumMenu { 
//class DynamicMenu : public GoMenu {
class DynamicMenu : public EnumMenu {
   bool alphaSorted;  //A major behavior change, so perhaps there should 
                      //really be a completely separate "AlphaMenu" class. 
                      //But many EnumMenu methods are helpful to inherit... 
 
   void resetIndices() { 
      int i = 0; 
      for (map<string,Entry*>::iterator it = entries.begin(); 
           it != entries.end(); it++) { 
         names[i] = it->first; 
         it->second->index = i; 
         i++; 
      } 
   } 
 public: 
   DynamicMenu(Logging* ensp, bool alpha = true, int firstDisplayedIndex = 1, 
               bool namesAfter = false, bool padNames = false, 
               const string& pre = "", const string& post = "", 
               bool cancelable = true, bool showMoreOptions = true, 
               bool screenAlways = false) 
      : EnumMenu(ensp, 0, firstDisplayedIndex, namesAfter && !alpha, padNames, 
                 pre, post, cancelable, showMoreOptions, screenAlways), 
        alphaSorted(alpha)   //alphaSorted forces !namesAfter 
   { } 
 
   virtual ~DynamicMenu() { } 
 
   bool empty() const { return size() == 0; } 
   void setFDI(int fdi) { firstDisplayedIndex = fdi; } 
   bool hasEntry(const string& name) const { 
      return entries.find(name) != entries.end(); 
   } 
 
   void setDescription(const string& name, const string& desc) { 
      map<string,Entry*>::const_iterator it = entries.find(name); 
      if (it != entries.end()) { 
         it->second->description = desc; 
      } else { 
         cout << "Could not find item to change its description." << endl; 
      } 
   } 
 
 
   virtual void addEntry(const string& name, const string& desc,
                         const string& status = "", 
                         bool rd = false, bool starred = false, 
                         bool novel = false) { 
      map<string,Entry*>::const_iterator it = entries.find(name); 
      if (it != entries.end()) { 
         cout << "Overwriting duplicate entry " << name << " in " 
              << entries.size() << " entries, hope that's OK." << endl; 
         EnumMenu::addEntry(it->second->index, name, desc, status, 
                            rd, starred, novel); 
      } else { 
         EnumMenu::addEntry(name, desc, status, rd, starred, novel); 
         if (alphaSorted) { resetIndices(); }  //not needed for index append 
      } 
   } 
 
   virtual void removeEntry(const string& name) { 
      map<string,Entry*>::iterator it = entries.find(name); 
      if (it != entries.end()) { 
         int i = it->second->index; 
         entries.erase(it); 
         names.erase(names.begin() + i); 
         numItems--; 
         resetIndices();  //regardless of alpha-sort. 
      } else { 
         cerr << "Item not found."; 
      } 
   } 
}; 
 
 
/** Catalog class uses composition, not inheritance, with DynamicMenu. 
    Mandates alpha sort.  Intended for further derivation. 
    Use of a pointer makes the linkage "weaker" thus facilitating separate 
    compilation, but allows "const" where logically perhaps it shouldn't be. 
 */ 
class Catalog { 
 public: 
   DynamicMenu* info;     //pointer consistent with Logging, enables const 
 private: 
   Catalog (const Catalog& rhs);   //disable copying for all descendants too 
   Catalog& operator=(const Catalog& rhs); 
 
 public: 
   explicit Catalog(Logging* ensp, int fdi = 1,  //alpha-sorted, index from 1 
           string pre = "", const string& post = "", bool cancelable = true, 
           bool showMoreOptions = false, bool screenAlways = false) 
      : info(new DynamicMenu(ensp, true, fdi, false, false, pre, post, 
             cancelable, showMoreOptions, screenAlways)) 
   { } 
 
   virtual ~Catalog() { } 
 
   //Delegates---what's missing here are adding and removing. 
 
   bool empty() const { return info->empty(); } 
   int size() const { return info->size(); } 
   bool success(int i) const { return info->success(i); } 
   string nameOf(int index) const { return info->nameOf(index); } 
   void setFDI(int fdi) { info->setFDI(fdi); } 
   int getFDI() const { return info->getFDI(); } 
   void setPreamble(const string& pre) const { info->setPreamble(pre); } 
   void setPostamble(const string& post) const { info->setPostamble(post); } 
   void setScreen(bool sa) const { info->setScreen(sa); } 
   void showCatalog(int offset = 0) const { info->showMenu(offset); } 
   bool hasEntry(const string& name) const { return info->hasEntry(name); } 
   bool isStarred(int i) { return info->isStarred(i); } 
   bool isStarred(const string& name) { return info->isStarred(name); } 
   void setStarred(const string& name, bool starred) const { 
       info->setStarred(name,starred);   //unchecked! 
   } 
   void clearStars() const { info->clearStars(); } 
   void setStatus(const string& name, const string& newStatus) const { 
      info->setStatus(name,newStatus); 
   } 
   string getStatus(const string& name) const { return info->getStatus(name); } 
   void setDescription(const string& name, const string& desc) { 
      info->setDescription(name,desc); 
   } 
   void resetDefaults() const { info->resetDefaults(); } 
   int readChoice(bool displayMenu = true, bool specialGo = false) { 
      return info->readChoice(displayMenu, specialGo); 
   } 
 
   /** IMPT: Since Catalog is *not* intended to be used with an enum, 
       integer returns are meaningless, so this method returns the name. 
       This also is consistent with the unique-names policy.  Re-using the 
       EnumMenu::readChoice() method requires dealing with the int values 
       it returns, which looks kludgey since they get converted back to names, 
       but when users take the int-entry option no extra work is done. 
    */ 
   string readChoiceName() { 
      int i = info->readChoice(); 
      if (i >= 0) {                   //Zero-basedness of returns is hard-coded 
         return info->nameOf(i);      //Range-checking is done by readChoice() 
      } else if (i == EnumMenu::MORE_CHOICE) { 
         return info->MORE_NAME;  //EnumMenu::MORE_NAME;  //Forward special codes to caller. 
      } else if (i == EnumMenu::CANCEL_CHOICE) { 
         return info->CANCEL_NAME; //EnumMenu::CANCEL_NAME; 
      } else if (i == EnumMenu::STREAM_END_CHOICE) { 
         return info->STREAM_END_NAME; //EnumMenu::STREAM_END_NAME; 
      } else { 
         return info->INVALID_NAME;  //EnumMenu::INVALID_NAME; 
      } 
   } 
}; 
 
 
template <class E>  //E extends Catalogable 
class ValueCatalog : public Catalog { 
 
   map<string,E> items;   //CLASS INV: has same size as entries in "info" 
 
 public: 
   explicit ValueCatalog<E>(Logging* ensp, int fdi = 1, 
                 string pre = "", const string& post = "", bool cancelable = true, 
                 bool showMoreOptions = false, bool screenAlways = false) 
    : Catalog(ensp, fdi, pre, post, cancelable, showMoreOptions, screenAlways), 
      items(map<string,E>()) 
   { } 
   virtual ~ValueCatalog<E>() { } 
 
   E& operator[] (const string& name) { return items[name]; } 
 
   void addItem(const E& item, const string& status = "", 
                bool resetDefault = false, bool starred = false) { 
      string name = item.getName();   //via Catalogable 
      info->addEntry(name, item.getDescription(), status, 
                     resetDefault, starred, false); 
                            //catalog items are never "novel" 
      items[name] = item;   //INV: "map" and "addEntry" always agree. 
   } 
 
   void removeItem(const string& name) { 
      //map<string,E>::iterator ite = items.find(name);  //illegal!? 
      if (items.find(name) != items.end()) { 
         items.erase(items.find(name)); 
         info->removeEntry(name);   //again, semantics agrees here. 
      } else { 
         cout << "Item not found---doing nothing." << endl; 
      } 
   }  //caller has responsibility to manage the stars. 
}; 
 
 
template <class E>  //E extends Catalogable 
class RefCatalog : public Catalog { 
 
   map<string,E*> items;   //CLASS INV: has same size as entries in "info" 
 
 public: 
   explicit RefCatalog<E>(Logging* ensp, int fdi = 1, 
                 string pre = "", const string& post = "", bool cancelable = true, 
                 bool showMoreOptions = false, bool screenAlways = false) 
    : Catalog(ensp, fdi, pre, post, cancelable, showMoreOptions, screenAlways), 
      items(map<string,E*>()) 
   { } 
   virtual ~RefCatalog<E>() { } 
 
   E* operator[] (const string& name) { return items[name]; } 
 
   void addItem(E* item, const string& status = "", 
                bool resetDefault = false, bool starred = false) { 
      string name = item->getName();   //via Catalogable 
      info->addEntry(name, item->getDescription(), status, 
                     resetDefault, starred, false); 
                            //catalog items are never "novel" 
      items[name] = item;   //INV: "map" and "addEntry" always agree. 
   } 
 
   void removeItem(const string& name) { 
      //map<string,E*>::iterator ite = items.find(name);  //illegal!? 
      //previous code was like for ValueCatalog 
      if (items.find(name) != items.end()) { 
         E* foundItem = (*(items.find(name))).second;  // = items[name]; 
         //delete(foundItem); 
         items.erase(name); 
         info->removeEntry(name);   //again, semantics agrees here. 
      } else { 
         cout << "Item not found---doing nothing." << endl; 
      } 
   } 
}; 
 
 
#endif    //end of #ifndef __IR_MENUS_H__ 
 
 
 
//File--------------------Demos.h-------------------------------------- 
 
#ifndef __IR_DEMOS_H__ 
#define __IR_DEMOS_H__ 

#ifndef __IR_INCLUDES_H__
#include "IRincludes.h"
#endif

class Ensemble; 
 
namespace Demos { 
   enum DEMOS { 
      ELISTA_DEMO, 
      SAN_LUIS_MEXICO_DEMO, 
      SWING_DEMO, 
      DEMORALIZATION_DEMO, 
      NUM_DEMOS 
   }; 
   void elistaDemo(Ensemble& ens); 
   void sanLuisMexicoDemo(Ensemble& ens); 
   void swingDemo(Ensemble& ens); 
   void demoralizationDemo(Ensemble& ens); 
}; 
 
#endif    //end of #ifndef __IR_DEMOS_H__ 
 
 
 
//File-------------------Ensemble.h------------------------------------- 
 
#ifndef __IR_ENSEMBLE_H__ 
#define __IR_ENSEMBLE_H__ 

#ifndef __IR_INCLUDES_H__
#include "IRincludes.h"
#endif

#ifndef __IR_UTIL_H__ 
#include "IRutil.h" 
#endif                      //end of #ifndef __IR_UTIL_H__ 
 
#ifndef __IR_FUNCTIONS_H__ 
#include "IRfunctions.h" 
#endif                      //end of #ifndef __IR_FUNCTIONS_H__ 
 
#ifndef __IR_MISC_GLOBAL_H__ 
#include "IRmiscGlobal.h" 
#endif	 //end of #ifndef __IR_MISC_GLOBAL_H__ 
 
#ifndef __IR_POSITION_H__
#include "Position.h"
#endif

#ifndef __IR_GAME_INFO_H__
#include "GameInfo.h"
#endif

#ifndef __IR_TRIAL_SPEC_H__ 
#include "TrialSpec.h" 
#endif	  //end of #ifndef __IR_TRIAL_SPEC_H__ 
 
#ifndef __IR_TURN_INFO_H__ 
#include "TurnInfo.h" 
#endif	  //end of #ifndef __IR_TURN_INFO_H__ 
 
#ifndef __IR_TUPLE_INFO_H__
#include "TupleInfo.h"
#endif 

#ifndef __IR_TURN_CONTEXT_H__
#include "TurnContext.h"
#endif

#ifndef __IR_FILTERS_H__ 
#include "Filters.h" 
#endif	  //end of #ifndef __IR_FILTERS_H__ 

#ifndef __IR_DELTA_SCALES_H__
#include "DeltaScales.h"
#endif    //end of #ifndef __IR_DELTA_SCALES_H__

 
#ifndef __IR_PERFDATA_H__ 
#include "PerfData.h" 
#endif	 //end of #ifndef __IR_PERFDATA_H__ 
 
#ifndef __IR_SHUFFLE_H__
#include "Shuffle.h"
#endif

#ifndef __IR_DECISION_INFO_H__
#include "DecisionInfo.h"
#endif
 
#ifndef __IR_MODELS_H__
#include "IRmodels.h"
#endif

#ifndef __IR_MOVESELECTION_H__
#include "MoveSelector.h"
#endif

#ifndef __IR_TRIAL_H__ 
#include "Trial.h" 
#endif	  //end of #ifndef __IR_TRIAL_H__ 
 
#ifndef __IR_TRIAL_FILTERS_H__ 
#include "TrialFilters.h" 
#endif 

#ifndef __IR_MULTIMIN_H__
#include "multimin.h"
#endif

#ifndef __IR_MPFIT_H__
#include "mpfit.h"
#endif

 
#ifndef __IR_MINIMIZER_H__ 
#include "Minimizer.h" 
#endif	  //end of #ifndef __IR_MINIMIZER_H__ 
 
#ifndef __IR_MENUS_H__ 
#include "Menus.h" 
#endif	  //end of #ifndef __IR_MENUS_H__ 
 
#ifndef __IR_DEMOS_H__ 
#include "Demos.h" 
#endif	  //end of #ifndef __IR_DEMOS_H__ 
 
 
//--------------------Ensemble Class and UI----------------------------- 
 
struct CinAgainstConst {    //debugging aid for now 
   bool status; 
   CinAgainstConst(bool st) : status(st) { } 
}; 
 
/** Dictionary for curves and trials and filters user may keep active. 
    Intended as a singleton class.  Includes UI functions. 
 */ 
class Ensemble : public Logging { 
 
   enum MainMenuChoice { 
      NEW_TRIAL, 
      CHANGE_TRIAL, 
      SHOW_TRIAL, 
      LOAD_DELTA_SCALE, 
      ADD_TURNS, 
      CLEAR_TURNS, 
      NEW_FILTER, 
      ATTACH_FILTERS, 
      DETACH_FILTERS, 
      CLEAR_FILTERS, 
      HIDE_FILTERS, 
      NEW_SELECTOR,
      TOGGLE_SELECTORS,
      NEW_TRIAL_SPEC, 
      LOAD_TRIAL_SPEC, 
      HIDE_SPECS, 
      //PERCFIT_TRIAL, 
      RUN_FIT, 
      PERF_TEST, 
      //PERF_TEST_ALL, 
      ADD_OUTPUT_FILE, 
      CLOSE_OUTPUT_FILE, 
      READ_COMMANDS, 
      //RUN_DEMO, 
      QUIT, 
      NUM_MAIN_CHOICES 
   }; 

   enum SelectorKind {   //only the user-built options
      NO_SELECTOR,
      EXISTING_SELECTOR,
      FN_SELECTOR,
      NOT_SELECTOR,
      AND_SELECTOR,
      OR_SELECTOR,
      MAP_SELECTOR,
      MOVE_EVAL_SELECTOR,
      MOVE_RAW_DELTA_SELECTOR,
      MOVE_RAW_SWING_SELECTOR,
      MOVE_SCALED_SWING_SELECTOR,
      NUM_SELECTOR_CHOICES
   };
 
   enum FilterKind { 
      NO_FILTER, 
      EXISTING_FILTER, 
      FN_FILTER, 
      NOT_FILTER, 
      AND_FILTER, 
      OR_FILTER, 
      PLAYER_IS, 
      PLAYER_IS_ONE_OF, 
      PLAYER_IS_ON_MOVE, 
      PLAYER_ON_MOVE_IS_ONE_OF, 
      ON_MOVE_FACING, 
      ON_MOVE_FACING_ONE_OF, 
      WHITE_IS, 
      BLACK_IS, 
      EVENT_IS, 
      DATE_IS, 
      EVENT_DATE_IS,
      YEAR_IS, 
      WHITE_ELO,
      BLACK_ELO,
      PLAYER_ELO,
      ELO_DIFF,
      ELO_DIFF_WITHIN,
      EVAL_WHITE, 
      PREV_EVAL_WHITE, 
      EVAL_WITHIN, 
      PREV_EVAL_WITHIN, 
      NEXT_EVAL_WITHIN,
      TURN_NO, 
      NUM_LEGAL_MOVES, 
      DELTA_I, 
      DELTA_DIFF, 
      SECOND_DELTA, 
      DELTA_N, 
      REP_COUNT,
      PLAYED_MOVE_INDEX, 
      PLAYED_MOVE_IS_SELECTED,
      ENGINE_MOVE_IS_SELECTED,
      EQUAL_TOP_MOVE_IS_SELECTED,
      SOME_MOVE_IS_SELECTED,
      FALLOFF, 
      WEIGHT, 
      PROB_I, 
      NUM_FILTER_CHOICES 
   }; 

   enum SCALE_OPTIONS { 
      WEIGHT_EVALS_FIRST = NUM_DELTA_PATCHES,
      SWING_POLICY,
      DEPTH_WINDOW,
      SWING_WINDOW,
      ZERO_DEPTH,
      JUDGMENT_DEPTH,
      CENTER_DELTA, 
      CENTER_EVAL, 
      STRADDLE_EVALS, 
      RADIUS, 
      SCALE_POWER, 
      GRADIENT, 
      NEG_GRADIENT,
      BETA,
      GAMMA,
      NORM_FACTORS,
      DELTA_CAP, 
      PIN_TO_CAP, 
      EQUAL_TOP_FIX, 
      PATCH_POWER,
      BASE_SCALE_NAME, 
      FINISH_SCALE, 
      NUM_SCALE_OPTIONS 
   }; 

   enum TRIALSPEC_PARAMS {
      GO_SPEC,
      CURVE,
      WEIGHT_FN,
      //ARG_FORMATION,
      RATING,
      SET_FROM_STRING,
      TRIALSPEC_NAME,
      S_VALUE,
      C_VALUE,
      D_VALUE,
      V_VALUE,
      A_VALUE,
      HM_VALUE,
      HP_VALUE,
      B_VALUE,
      //SPEC_JUDGMENT_DEPTH,
      SLIDES,
      SLIDE_CURVE,
      SLIDE_LO,
      SLIDE_MID,
      SLIDE_HI,
      SLIDE_POWER,
      SLIDE_PROP,
      MEMO_STEP,
      MEMO_LIMIT,
      SHOW_STEP,
      SHOW_LIMIT,
      SHOW_CURVE,
      NUM_TRIALSPEC_PARAMS
   };
 
   enum FIT_CHOICES { 
      MIN_METHOD = Minimizer::NUM_MINIMANDS, 
      FUNNEL_FACTORS,
      START_SPEC,
      S_BOUNDS, 
      C_BOUNDS, 
      D_BOUNDS,
      V_BOUNDS,
      A_BOUNDS,
      HM_BOUNDS,
      HP_BOUNDS,
      B_BOUNDS,
      //FIT_JUDGMENT_DEPTH,
      MAX_ITERATIONS,
      NUM_RETRIES,
      PRECISION_X, 
      PRECISION_Y,
      PRECISION_G,
      //WALKOUT,
      WALKOUT_STEP,
      EPSFCN,
      GO,
      BOOT_NUM,
      KEEP_SPEC_IN_BOOT,
      VERBOSE, 
      NUM_FIT_CHOICES 
   }; 

   enum TEST_CHOICES {
      GO_TEST,
      USE_FOCUS_SPEC,
      MISS_IS_MOVE_NPLUSONE,
      FORCE_UNIT_WEIGHTS,
      SHOW_UNWEIGHTED,
      SHOW_UNSCALED,
      NUM_INDICES,
      EQUAL_TOP_INDEX_LIMIT,
      NUM_BOOTSTRAP_TRIALS,
      NUM_RESAMPLE_TRIALS,
      NUM_RESAMPLE_GAMES,
      NUM_RESAMPLE_TURNS,
      ONE_PLAYER_PER_GAME,
      ZMM_FILE,
      ZEV_FILE,
      ZAD_FILE,
      MOVES_FILE,
      MOVES_LIMIT,
      SHOW_INDIVIDUAL_MOVES,
      NUM_TEST_CHOICES
   };
      
       
 
/*//------------------------------------------------------------------------ 
   Data.  Since focusTrial's TrialSpec is *settable* during runs, it is 
   *vital* that the TrialSpec containers use value-semantics, while the 
   trials and filters use reference semantics (via pointers)---indeed, Trial 
   has a disabled copy constructor since it embeds long lists. 
   Because the forward declarations are incomplete, must use pointers here. 
*///------------------------------------------------------------------------ 
   list<GameInfo*>* pGames;
   list<TurnInfo*>* pTurns;  //INV: All trials point to these turns... 
   list<TurnInfo*>* pReferenceTurns; 
   Trial* focusTrial; 
   Trial* referenceTrial;   //...except this one, for Intrinsic Ratings 
   ValueCatalog<TrialSpec>* specs; 
   ValueCatalog<TrialSpec>* hiddenSpecs; 
   RefCatalog<DeltaScale>* scales; 
   RefCatalog<Trial>* trials; 
   RefCatalog<TurnFilter>* filters; 
   RefCatalog<TurnFilter>* hiddenFilters; 
   RefCatalog<MoveSelector>* selectors;

   mutable string dataPath;
   mutable string loadedGlobs;
   mutable vector<string> loadedFiles;

   vector<ostream*>* outs; 
   istream* INP;  //settable---this may cause headaches later... 
   ostream* LOGP; //but at least I localized most code using these to here 
   bool outputToScreen; 
   bool keepGoing; 
   LineScale* theUnitLineScale; 
   CinAgainstConst* const justUsedCin; 

   EnumMenu* modelsMenu; 
   EnumMenu* compareMenu; 
   EnumMenu* mainMenu; 
   EnumMenu* filtersMenu; 
   //GoMenu* selectorsMenu;
   EnumMenu* selectorsMenu;
   EnumMenu* methodMenu;
   EnumMenu* skedMenu;
   EnumMenu* fitMenu; 
   EnumMenu* testMenu;
   EnumMenu* curvesMenu; 
   EnumMenu* weightsMenu; 
   EnumMenu* scalesMenu; 
   EnumMenu* swingMenu;
   EnumMenu* paramsMenu;
   EnumMenu* demosMenu; 
   DynamicMenu* outsMenu; 
 
 friend class EnumMenu; 
 
 //Private methods 
   Ensemble (const Ensemble& rhs);            //disabled copy constructor... 
   Ensemble& operator=(const Ensemble& rhs);  //...and assignment 
   void initMenus(); 
 
   double readS() const; 
   double readC() const; 
   double readD() const;
   double readV() const;
   double readA() const;
   double readHM() const;
   double readHP() const;
   double readB() const;
   pair<int,int> readBounds() const;
   void resetParamsMenu();

   //size_t readJD() const;

   int parseDeltas(string& line, vector<double>* deltas) const; 
   Minimizer::SKED parseSked(string x) const;
 
 public: 
   Ensemble(Trial* initialTrial, string dpath, ostream* logp, istream* IN = &cin); 
   Ensemble(); 
 
   virtual ~Ensemble() { 
      clearFilters();
      clearReferenceTurns();
      clearTurns();   //can make all these the destructor of Trial??
      delete(referenceTrial);   //...except this one, for Intrinsic Ratings
      delete(focusTrial);
      delete(specs);
      delete(hiddenSpecs);
      delete(scales);
      delete(trials);
      delete(filters);
      delete(hiddenFilters);
      delete(selectors);
      delete(pTurns);
      delete(pGames);

      delete(modelsMenu);
      delete(compareMenu);
      delete(mainMenu);
      delete(filtersMenu);
      delete(selectorsMenu);
      delete(methodMenu);
      delete(skedMenu);
      delete(fitMenu);
      delete(testMenu);
      delete(curvesMenu);
      delete(weightsMenu);
      delete(scalesMenu);
      delete(swingMenu);
      delete(paramsMenu);
      delete(demosMenu);
      delete(outsMenu);

      (*LOGP) << endl << endl;    //in case end came in mid-line 
      LOGP->flush(); 
      delete(justUsedCin);
      //delete(INP);
      delete(LOGP);
      delete(outs);
      
   }                              //stream files will close when main exits 
 
   template<class E> 
   void loggedRead(E& item, bool endLine = false, bool write = true) const { 
      (*INP) >> item; 
      if (INP->fail() && !INP->eof()) { 
         cout << "Failed to read item, please select again." << endl; 
         INP->clear(); 
         INP->ignore(numeric_limits<streamsize>::max(),'\n'); 
         loggedWrite("Must edit glitch here before replaying!"); 
      } else { 
         justUsedCin->status = true; 
         if (write) { 
            (*LOGP) << item << (endLine ? "\n" : " "); 
         } 
      } 
   } 
   //These would all be no longer "const" if they modified a "justUsedCin" 
   //field, rather than doing so thru the CinAgainstConst object! 
 
   virtual void loggedReadString(string& item, bool endLine = false, 
                                 bool write = true) const { 
      loggedRead(item,endLine,write); 
   } 
   virtual void loggedReadInt(int& item, bool endLine = false, 
                              bool write = true) const { 
      loggedRead(item,endLine,write); 
   } 
   virtual void loggedReadDouble(double& item, bool endLine = false, 
                                 bool write = true) const { 
      loggedRead(item,endLine,write); 
   } 

   template<class E>
   void loggedReadBounded(E& item, const double lo, const double hi,
                                  bool endLine = false, bool write = true) const {
      bool entering = true;
      while (entering) {
         loggedRead(item,endLine,write);
         if (item >= lo && item <= hi) {
            entering = false;
         } else {
            cout << "Item out of bounds [" << lo << "," << hi << "]; please select again: " << endl;
         }
      }
   }
 
   virtual void loggedWrite(const string& st, bool endLine = false)  const { 
      (*LOGP) << st << (endLine ? "\n" : " "); 
   } 
   virtual string loggedGetline() const { 
      string item; 
      getline(*INP,item); 
      (*LOGP) << item << endl; 
      return item;
   } 
   virtual bool atEOF() const { return (*INP).eof(); } 
   virtual bool usingCin() const { return INP == &cin; } 
 
   void setDataPath(string newPath) { dataPath = newPath; }

//One set of turns is maintained as the reference set for computing IPR's.
//Currently it is R3Turns.txt, and the variable is set true only at pgm start.
//A bit of a kludge---should probably make a separate object rather than
//re-use code here.  Changing to SF7Turns.txt
//Returned pointer is used only by selectionOnly, else Ensemble::turns is set
 

   //list<TurnInfo*>* readInputFile(const string& fileName, bool referenceOnly = false,
                                       //bool selectionOnly = false) const; 

   list<TurnInfo*>* readInputFile(istream& file, bool referenceOnly = false,
                                       bool selectionOnly = false) const; 
   void readTurnsFromFileGlob(const string& fileGlob, bool referenceOnly = false,
                                                      bool selectionOnly = false) const; 
   void readTurns(istream& IN) const; 
      //public readers can use other instreams 
   void printDeltas(const string& name) const; 
   void printTurns(const string& name) const; 
 
   TrialSpec makeTrialSpec() const; 
   //LineScale* makeDeltaScale(double deltaCap) const; 
   LineScale* makeDeltaScale() const;
   SwingInfo* makeSwingInfo() const;
 
   //void addPercentileRange (vector<double>* percentilePoints, 
            //double low, double high, int numPoints, bool includeEnds) const; 
   //void readPercentileRange (vector<double>* percentilePoints) const; 
 
   Trial* getFocusTrial() const { 
      return focusTrial; 
   } 
 
   Trial* getReferenceTrial() const { 
      return referenceTrial; 
   } 
 
   //Trial* getReferenceTrial3() const { 
      //return referenceTrial3; 
   //} 
 
   void clearFilters() const { 
      focusTrial->clearFilters(); 
      filters->clearStars(); 
   } 
 
   void quit() { 
      keepGoing = false; 
   } 
 
   void showActiveTrial(ostream& OUT) const { 
      OUT << string(*focusTrial) << endl; 
   } 
 
   void addOutputStream(ostream* ostrm, bool firstTime = true) const { 
      string cal = IRutil::getTime(); 
      string timestamp = IRutil::getRawTime(); 
      if (firstTime) { 
         (*ostrm) << endl << IRutil::IRCOMMENT << " Session run on " << cal 
                  << " (" << timestamp << ")" << endl << endl; 
      } 
      outs->push_back(ostrm); 
   } 
 
   bool addOutputFile(const string& name, bool firstTime = true) const { 
      if (outsMenu->hasEntry(name)) { 
         cout << "File or stream already active." << endl; 
      } else if (name == "cout") { 
         outs->push_back(&cout); 
         outsMenu->addEntry("cout", ""); 
      } else { 
         ofstream* filep = new ofstream(name.c_str(), ios::app); 
         if(!filep->is_open()) { 
            cerr << "Cannot stat the output file, returning..." << endl; 
            return false; 
         } else { 
            outsMenu->addEntry(name,""); 
            addOutputStream(filep, firstTime); 
         } 
      } 
      return true; 
   } 
 
 
   void closeOutputFile(const string& name) { 
      int index = 0; 
      while (index < outsMenu->size() && outsMenu->nameOf(index) != name) { 
         index++; 
      } 
      if (outsMenu->nameOf(index) == name) { 
         outsMenu->removeEntry(name); 
         vector<ostream*>::iterator it = outs->begin() + index; 
         ofstream* filep = dynamic_cast<ofstream*>(*it); 
         if (filep) { 
            filep->close(); 
         } else { 
            cout << "Muting some output to screen..." << endl; 
            outputToScreen = false; 
         } 
         outs->erase(it); 
      } else { 
         cerr << "File you attempted to close not found." << endl; 
      } 
   } 
 
   void newTrial(); 
   void changeTrial();
 
   void loadNamedTrial(); 
 
   void loadDeltaScale(bool refToo = true); 
 
   void loadNamedTrialSpec(); 
 
   void hideSpecs(); 
 
   Minimizer* makeMinimizer() const; 
 
   void runFit(); 

   void runPerfTest() const;
 
   void addTurns() const {   //does not reassign "turns" pointer... 
      if (usingCin()) {
         readTurns(*INP);       //now logs---previously was not logged 
         reset();               //...but can't be "const" for this reason? 
      } else {
         string fileName;
         (*INP) >> fileName;
         readTurnsFromFileGlob(fileName);  //also logs now
         reset();
      }
   } 

   void clearTurns() const {
      focusTrial->clearFilteredDecisions();  //removes source pointers.
      list<TurnInfo*>::iterator tit = pTurns->begin();
      list<TurnInfo*>::iterator tite = pTurns->end();
      while (tit != tite) {
         TurnInfo* p = *tit++;
         delete(p); //does not invalidate iterator itself, zaps TurnInfo
      }
      pTurns->clear();
      list<GameInfo*>::iterator git = pGames->begin();
      list<GameInfo*>::iterator gite = pGames->end();
      while (git != gite) {
         GameInfo* g = *git++;
         delete(g); //does not invalidate iterator itself, zaps TurnInfo
      }
      pGames->clear();
      loadedGlobs = "";
      loadedFiles = vector<string>();
   }

   void clearReferenceTurns() const {
      referenceTrial->clearFilteredDecisions();  //removes source pointers.
      list<TurnInfo*>::iterator tit = pReferenceTurns->begin();
      list<TurnInfo*>::iterator tite = pReferenceTurns->end();
      while (tit != tite) {
         TurnInfo* p = *tit++;
         delete(p); //does not invalidate iterator itself, zaps TurnInfo
      }
      pReferenceTurns->clear();
   }

   TurnFilter* chooseCreatedFilter(); 
 
   TurnFilter* makeFilter(int choice); 
 
   void addNewFilter(TurnFilter* tf); 
 
   void attachFilters(); 
 
   void detachFilters(); 
 
   void hideFilter(TurnFilter* tf);
   void hideFilters(); 

   void newSelectors();   //not const since it changes status of Trial
   
   MoveSelector* chooseCreatedSelector() const;  //const unlike chooseCreatedFilter since no reset()
   
   MoveSelector* makeSelector(int choice) const;

   MoveSelector* mapSelectorInFile(const string& name, const MoveSelector* ms) const;

   void addSelector(MoveSelector* ms);
   void justAddSelector(MoveSelector* ms);  //does not set
   void setSelector(MoveSelector* ms);

   void toggleOneSelector(); //changes status but could be const in "pseudo" pointer sense
   void toggleSelectors();   //changes status and re-generates focused list.
 
   void reset() const { 
//cerr << "aa";
      focusTrial->reset(); 
//cerr << "bb";
      trials->setDescription(focusTrial->getName(), 
                             focusTrial->getDescription()); 
      //if (focusTrial->getDecisions()->empty() && usingCin()) { 
      if (focusTrial->numDecisions() == 0 && usingCin()) {
        cout << "All tuples filtered out---may see NaNs or worse!" << endl; 
      } 
//cerr << "cc";
   } 
 
   void addTrialSpec(TrialSpec ts); 
 
   void newFilters(); 
 
   void runDemo(int choice); 
 
   void doMainMenuItem(int choice); 
 
   void interactFromStream(istream* istrp, const string& matchString); 
 
   void interact(); 
 
}; //end of class Ensemble, implementation follows menu classes 
 
 
#endif    //end of #ifndef __IR_ENSEMBLE_H__ 
 
 
 
//File--------------------Ensemble.cpp----------------------------------- 
 
#ifndef __IR_ENSEMBLE_CPP__ 
#define __IR_ENSEMBLE_CPP__ 


#ifndef __IR_ENSEMBLE_H__
#include "Ensemble.h"
#endif    //end of #ifndef __IR_ENSEMBLE_H__

 
//--------------IMPLEMENTATION OF ENSEMBLE CLASS------------------------- 
 
Ensemble::Ensemble(Trial* initialTrial, string dpath, ostream* logp, istream* IN) 
 : pGames(new list<GameInfo*>()),
   pTurns(initialTrial->getTurns()), //uses trial's pointer
   pReferenceTurns(new list<TurnInfo*>()), 
   //pReferenceTurns(NULL),
   focusTrial(initialTrial), 
   referenceTrial(NULL), 
   //referenceTrial3(NULL), 
             //Catalogs all have the "cancel" option, as enabled by default 
   specs(new ValueCatalog<TrialSpec>(this, 1,  
      IRutil::DASHLINE + "\n" + "Active trial specs---enter # or name",  
      IRutil::DASHLINE, true, true, false)), 
                         // ^^^^ can show more options 
   hiddenSpecs(new ValueCatalog<TrialSpec>(this, 1,  
      IRutil::DASHLINE + "\n" + "Inactive trial specs---enter # or name",  
      IRutil::DASHLINE, true, false, false)), 
                         // ^^^^^ does not 
   scales(new RefCatalog<DeltaScale>(this, 1,  
      "Scales, * shows loaded one\n" + IRutil::DASHLINE,  
      IRutil::DASHLINE + "\nEnter -2/moreOptions to define new scale", 
      true, false, false)), 
   trials(new RefCatalog<Trial>(this, 1,  
      "Trials, * shows active one\n" + IRutil::DASHLINE,  
      IRutil::DASHLINE, true, false, false)), 
   filters(new RefCatalog<TurnFilter>(this, 1,  
      IRutil::DASHLINE + "\n" + "Filters, * shows active one(s).",  
      IRutil::DASHLINE, true, true, false)), 
   hiddenFilters(new RefCatalog<TurnFilter>(this, 1,  
      IRutil::DASHLINE + "\n" + "Hidden Filters---# or name to attach, or " 
                     + "-2/moreOptions to define new", 
      IRutil::DASHLINE, true, true, false)), 
   selectors(new RefCatalog<MoveSelector>(this, 1,
      "Move Selectors, * shows active ones.\nEnter \"go\" or \"OK\" or \"ok\" to submit\n" + IRutil::DASHLINE,
      IRutil::DASHLINE, true, true, false)),

   dataPath(dpath),
   loadedGlobs(""),
   loadedFiles(vector<string>()),

   outs(new vector<ostream*>()), INP(IN), LOGP(logp), 
   outputToScreen(true),  
   keepGoing(true),  
   theUnitLineScale(new UnitLineScale("UnitLineScale", true, 
      new SwingInfo(map<APPLICATION_POLICIES, double>(), true, false, true,
                    false, false, 0, false, false, 0.0),
      NO_PATCH, IRutil::CENTRALPATCHPOWER, 0.00, map<string,double>(), 1, 30, 30, 6, 20, 0)), 
   justUsedCin(new CinAgainstConst(false)), 
   modelsMenu(new EnumMenu(this,Models::NUM_MODELS)), 
   compareMenu(new EnumMenu(this,3,0,false,true)),        //OK to hard-code "3" 
   mainMenu(new EnumMenu(this,NUM_MAIN_CHOICES,1,true)),      //put names after 
   filtersMenu(new EnumMenu(this,NUM_FILTER_CHOICES,0,true)), //ditto, # from 0 
   //selectorsMenu(new GoMenu(this,NUM_SELECTOR_CHOICES,1,true,true,IRutil::DASHLINE,IRutil::DASHLINE,true,true,false)),
   selectorsMenu(new EnumMenu(this,NUM_SELECTOR_CHOICES,0,true,true,IRutil::DASHLINE,IRutil::DASHLINE,true,true,false)),
   methodMenu(new EnumMenu(this, Minimizer::NUM_METHODS,0,false,true)),
   skedMenu(new EnumMenu(this, Minimizer::NUM_SKEDS,0,false,true)),
   fitMenu(new EnumMenu(this,NUM_FIT_CHOICES,1,false,true)),  //pads names 
   testMenu(new EnumMenu(this,NUM_TEST_CHOICES,0,false,true)),
   curvesMenu(new EnumMenu(this, IRfun::NUM_CURVES,1,false,true)), 
   weightsMenu(new EnumMenu(this, IRfun::NUM_WEIGHTS,1,false,true)), 
   scalesMenu(new EnumMenu(this, NUM_SCALE_OPTIONS, 0, false, true)), 
   swingMenu(new EnumMenu(this, NUM_SWING_OPTIONS, 0, false, true)),
   paramsMenu(new EnumMenu(this, NUM_TRIALSPEC_PARAMS, 0, false, true)),
   demosMenu(new EnumMenu(this,Demos::NUM_DEMOS)), 
   outsMenu(new DynamicMenu(this,false,1,false,true,"","",true,false,true)) 
{ 
   initMenus(); 
   TrialSpec ts = initialTrial->getTrialSpec(); 
   trials->addItem(focusTrial,"",false,true);  //CLASS INV: focusTrial starred 
   specs->addItem(ts,"",false,true);           //ditto for its spec, by value 
   if (initialTrial->scalesDeltas()) { 
      scales->addItem(initialTrial->getScale(), "", false, true); 
   } 
   string cal = IRutil::getTime(); 
   string timestamp = IRutil::getRawTime(); 
   (*LOGP) << IRutil::IRCOMMENT << " " << "Session run on " << cal << " (" 
           << timestamp << "):" << endl; 
   outs->push_back(&cout); 
   map<string, double> engineInits;
   engineInits[string("omodo")] = 1.01;
   engineInits[string("tockfish")] = 1.0;
   //LineScale* ls = new TranslateByEval(new MulScale("RefMulScale",
                                       //false, NO_PATCH, IRutil::CENTRALPATCHPOWER, 0.00,
                                       //engineInits, 5, 30, 30, 0.00, 1.0, 1.000, 1.000, true));

   //LineScale* ls = new TranslateByEval(new FullFractalScale("RefFullFractalScale",
   //string swingPolicy = "0(separate,relative2,damped)";
   map<APPLICATION_POLICIES, double> appp;
   appp[SEPARATE_REL2] = 1.0;
   //appp[LINK_REL2] = 1;
   SwingInfo* swi = new SwingInfo(appp, true, false, true, false, false, 0, false, false, 0.0);

   LineScale* ls = new TranslateByEval(new FullFractalScale("RefFullFractalScale", true, swi, NO_PATCH,
                                       IRutil::CENTRALPATCHPOWER, 0.00, engineInits,
                                       1, 30, 30, 5, 20, 0, 1.0, 1.6, 1.2));   //zero radius;
   //LineScale* ls = new SimpleFullFractalScale("RefFullFractalScale", true, swi,
                                       //MATCH_PROBS, IRutil::CENTRALPATCHPOWER, 0.00,
                                       //engineInits, 1, 30, 30, 5, 19, 0, 1.0, 1.6, 1.2);  //);

   //LineScale* ls3 = new TranslateByEval(new FullFractalScale("RefFullFractalScale(1.0,1.0)",0.03,UP_TIED_TOP,1.0,1.0)); 

   ls->setDeltaCap(IRutil::DELTACAP);
   referenceTrial = new Trial("RefBasicPS", pReferenceTurns, ts, //0.00, 1.00, 49, false, 
         Models::POWER_SHARES, false, true, ls); 
/* 
   referenceTrial->attachFilter(new OrFilter(new EvalWithinFilter(3.0,"ew3ref"), 
                                       new PrevEvalWithinFilter(3.0,"pw3ref"), 
                                       "porew3ref") ); 
*/ 
   referenceTrial->attachFilter(new EvalWithinFilter(3.0,"ew3ref",0)); 
   referenceTrial->attachFilter(new RepCountFilter(EQ,0,true,"RC0ref"));
   //referenceTrial3= new Trial("RefBasicPS3", pReferenceTurns, ts, 0.00, 1.00, 49, 
       //false, Models::POWER_SHARES, false, 4.00, true, ls3); 
   //referenceTrial3->attachFilter(new EvalWithinFilter(3.0,"ew3ref3")); 
   cerr << "Reading reference turns now...";
   //readInputFile("R3Turns.aif", true, false);  //sets pReferenceTurns; 
   //readInputFile("tmp.aif", true);
   readTurnsFromFileGlob("SF7Turns.aif", true);  //sets pReferenceTurns;
   cerr << "done." << endl;
   referenceTrial->setSpec(focusTrial->getSpec()); 
   referenceTrial->setScale(focusTrial->getScale()); 
 
   srand(atoi(timestamp.c_str()));  //master "random" seed, all else determ^c! 
}                                   //for purpose of reproducibility 
 
Ensemble::Ensemble() 
 : pGames(new list<GameInfo*>()),
   pTurns(new list<TurnInfo*>()), 
   pReferenceTurns(new list<TurnInfo*>()), 
   focusTrial(NULL), //INV: this pointer is never null after construction 
             //Catalogs all have the "cancel" option, as enabled by default 
   referenceTrial(NULL), 
   //referenceTrial3(NULL), 
   specs(new ValueCatalog<TrialSpec>(this, 1,  
      IRutil::DASHLINE + "\n" + "Active trial specs---enter # or name",  
      IRutil::DASHLINE, true, true, false)), 
                         // ^^^^ can show more options 
   hiddenSpecs(new ValueCatalog<TrialSpec>(this, 1,  
      IRutil::DASHLINE + "\n" + "Inactive trial specs---enter # or name",  
      IRutil::DASHLINE, true, false, false)), 
                         // ^^^^^ does not 
   scales(new RefCatalog<DeltaScale>(this, 1,  
      "Scales, * shows loaded one\n" + IRutil::DASHLINE, 
      IRutil::DASHLINE + "\nEnter -2/moreOptions to define new scale", 
      true, false, false)), 
   trials(new RefCatalog<Trial>(this, 1,  
      "Trials, * shows active one\n" + IRutil::DASHLINE,  
      IRutil::DASHLINE, true, false, false)), 
   filters(new RefCatalog<TurnFilter>(this, 1,  
      IRutil::DASHLINE + "\n" + "Filters, * shows active one(s).",  
      IRutil::DASHLINE, true, true, false)), 
   hiddenFilters(new RefCatalog<TurnFilter>(this, 1,  
      IRutil::DASHLINE + "\n" + "Hidden Filters---# or name to attach, or " 
                     + "-2/moreOptions to define new", 
      IRutil::DASHLINE, true, true, false)), 
   selectors(new RefCatalog<MoveSelector>(this, 1,
      "Move Selectors, * shows active ones.\nEnter \"go\" or \"OK\" or \"ok\" to submit\n" + IRutil::DASHLINE,
      IRutil::DASHLINE, true, true, false)),

   dataPath("/projects/regan/Chess/CSE712/AIF/"),
   loadedGlobs(""),
   loadedFiles(vector<string>()),
   outs(new vector<ostream*>()), INP(&cin), 
   outputToScreen(true),  
   keepGoing(true),  

   theUnitLineScale(new UnitLineScale("UnitLineScale", true,
      new SwingInfo(map<APPLICATION_POLICIES, double>(), true, false, true,
                    false, false, 0, false, false, 0.0),
      NO_PATCH, IRutil::CENTRALPATCHPOWER, 0.00, map<string,double>(), 1, 30, 30, 6, 20, 0)),
   justUsedCin(new CinAgainstConst(false)), 
   modelsMenu(new EnumMenu(this,Models::NUM_MODELS)), 
   compareMenu(new EnumMenu(this,3,0,false,true)),        //OK to hard-code "3" 
   mainMenu(new EnumMenu(this,NUM_MAIN_CHOICES,1,true)),      //put names after 
   filtersMenu(new EnumMenu(this,NUM_FILTER_CHOICES,0,true)), //ditto, # from 0 
   //selectorsMenu(new GoMenu(this,NUM_SELECTOR_CHOICES,1,true,true,IRutil::DASHLINE,IRutil::DASHLINE,true,true,false)),
   selectorsMenu(new EnumMenu(this,NUM_SELECTOR_CHOICES,0,true,true,IRutil::DASHLINE,IRutil::DASHLINE,true,true,false)),
   methodMenu(new EnumMenu(this, Minimizer::NUM_METHODS,0,false,true)),
   skedMenu(new EnumMenu(this, Minimizer::NUM_SKEDS,0,false,true)),
   fitMenu(new EnumMenu(this,NUM_FIT_CHOICES,1,false,true)),  //pads names 
   testMenu(new EnumMenu(this,NUM_TEST_CHOICES,0,false,true)),
   curvesMenu(new EnumMenu(this, IRfun::NUM_CURVES,1,false,true)),
   weightsMenu(new EnumMenu(this, IRfun::NUM_WEIGHTS,1,false,true)),
   scalesMenu(new EnumMenu(this, NUM_SCALE_OPTIONS, 0, false, true)), 
   swingMenu(new EnumMenu(this, NUM_SWING_OPTIONS, 0, false, true)),
   paramsMenu(new EnumMenu(this, NUM_TRIALSPEC_PARAMS, 0, false, true)),
   demosMenu(new EnumMenu(this,Demos::NUM_DEMOS)), 
   outsMenu(new DynamicMenu(this,false,1,false,true,"","",true,false,true)) 
{ 
   initMenus(); 
   ofstream* filep = new ofstream(IRutil::LOGFILENAME.c_str(), ios::app); 
   if(!filep->is_open()) { 
      cerr << "Cannot read the log file, using null log..." << endl; 
      LOGP = new IRutil::nullstream(); 
   } else { 
      LOGP = filep; 
   } 
   string cal = IRutil::getTime(); 
   string timestamp = IRutil::getRawTime(); 
   (*LOGP) << IRutil::IRCOMMENT << " " << "Session run on " << cal << " (" 
           << timestamp << "):" << endl; 
   outs->push_back(&cout); 
   //int dd = int(100*IRutil::EVALMEMOCAP + 1);
   map<IRfun::CURVES, double> curveBook;
   curveBook[IRfun::INVEXP] = 1.0;
   TrialSpec ts(IRfun::INVEXP, curveBook, IRfun::UNITWTS, "startSpec", 
                0.05, 0.60, 12.5, 0.05, 1.0, 1.0, 1.0, 1.0,
                false, IRfun::FOLDEDLOGISTIC, 0.00, 2.00, 5.00, 1.0, 1.0, 0.01, 0.00);
   map<string, double> engineInits;
   engineInits[string("omodo")] = 1.01;
   engineInits[string("tockfish")] = 1.0;
   //LineScale* ls = new TranslateByEval(new MulScale("RefMulScale",
                                       //false, NO_PATCH, IRutil::CENTRALPATCHPOWER, 0.00,
                                       //engineInits, 5, 30, 30, 0.00, 1.0, 1.000, 1.000, true));

   //LineScale* ls = new TranslateByEval(new FullFractalScale("RefFullFractalScale",
   //string swingPolicy = "0(separate,relative2,damped)";
   map<APPLICATION_POLICIES, double> appp;
   appp[SEPARATE_REL2] = 1.0;
   //appp[LINK_REL2] = 1;
   SwingInfo* swi = new SwingInfo(appp, true, false, true, false, false, 0, false, false, 0.0);

   LineScale* ls = new TranslateByEval(new FullFractalScale("RefFullFractalScale", true, swi, NO_PATCH,
            IRutil::CENTRALPATCHPOWER, 0.00, engineInits,
            1, 30, 30, 5, 20, 0, 1.0, 1.6, 1.2));   //zero radius;
   //LineScale* ls = new SimpleFullFractalScale("RefFullFractalScale", true, swi,
                                       //MATCH_PROBS, IRutil::CENTRALPATCHPOWER, 0.00,
                                       //engineInits, 1, 30, 30, 5, 19, 0, 1.0, 1.6, 1.2);  //); 

   ls->setDeltaCap(IRutil::DELTACAP);
   referenceTrial = new Trial("RefBasicPS", pReferenceTurns, ts, //0.00, 1.00, 49, false, 
         Models::POWER_SHARES, false, true, ls); 
/* 
   referenceTrial->attachFilter(new OrFilter(new EvalWithinFilter(3.0,"ew3ref"), 
                                       new PrevEvalWithinFilter(3.0,"pw3ref"), 
                                       "porew3ref") ); 
*/ 
   referenceTrial->attachFilter(new EvalWithinFilter(3.0,"ew3ref",0)); 
   referenceTrial->attachFilter(new RepCountFilter(EQ,0,true,"RC0ref"));
   //readInputFile("R3Turns.aif", true, false);  //sets pReferenceTurns; 
   //readInputFile("tmp.aif", true, false);
   readTurnsFromFileGlob("SF7Turns.aif", true, false);  //sets pReferenceTurns;
   referenceTrial->setSpec(focusTrial->getSpec());
   referenceTrial->setScale(focusTrial->getScale());


 
 
   srand(atoi(timestamp.c_str()));   //master "random" seed, all else determ^c! 
   newTrial(); 
} 
 
 
/** Initialize the non-dynamic menus, just once for this Ensemble.  Parameters: 
    void addEntry(int index, string name, string desc, string status = "", 
                  bool rd = true, bool starred = false, bool novel = false) { 
    The "name" is used for scripting commands, capitalized for class objects. 
    "rd"=true means the default on this entry re-sets between menu invocations. 
    "novel" means that a line of dashes is inserted above the item. 
    Must be called only /after/ focusTrial is defined! 
 */ 
void Ensemble::initMenus() { 
   //IRfun::initNames();   //sets up curve and weight-method menus 
   //initPolicyNames();    //moved to main
   string pre; 
   pre = "Enter curve to fit (normalized to 1 when x = 0); enter 0/go to exit"; 
   curvesMenu->setPreamble(pre); 
   for (int i = 0; i < IRfun::NUM_CURVES; i++) { 
      IRfun::CURVES ci = IRfun::CURVES(i); 
      curvesMenu->addEntry(ci, IRfun::curveNames[ci],  IRfun::curveDescriptions[ci],
                        "0", false, false, false); 
   } 
   curvesMenu->setStatus(IRfun::INVEXP, "1");
   curvesMenu->setStarred(IRfun::INVEXP, true);
   
 
   pre = "Enter the tuple weighting function to use:"; 
   weightsMenu->setPreamble(pre); 
   for (int i = 0; i < IRfun::NUM_WEIGHTS; i++) { 
      IRfun::WEIGHTS wi = IRfun::WEIGHTS(i); 
      weightsMenu->addEntry(i, IRfun::weightNames[wi],  
                            IRfun::weightDescriptions[wi]); 
   } 
 
   pre = "\nChoose scale type, combination of origins, and scale factors:"; 
   scalesMenu->setPreamble(pre); 
   scalesMenu->addEntry(NO_SCALING, "NoScaling", "No scaling, cannot pin.", 
                        "", true, false, true); 
   scalesMenu->addEntry(LINEAR_SCALE, "LinearScale", string("Linear scale, ") 
                        + "can grade and/or pin", 
                        "", true, false, false); 
   scalesMenu->addEntry(MUL_SCALE, "MulScale", "Multiplies delta by 1/(1+gx)^pow",
                        "", true, false, false);
   scalesMenu->addEntry(MIX_SCALE, "MixScale", "Combine MulScale and subtracting g*eval",
                        "", true, false, false);
   scalesMenu->addEntry(DIVLOG_SCALE, "DivLogScale", "1/g*log(y) scaling", 
                        "", true, false, false); 
   scalesMenu->addEntry(LOG_SCALE, "LogScale", "1/(gy) scaling---gives log(gy)",  
                        "", true, false, false); 
   scalesMenu->addEntry(FRACTAL_SCALE, "FractalScale", "1/(g(y^c)) scaling (c < 1)", 
                        "", true, false, false); 
   scalesMenu->addEntry(FULL_FRACTAL_SCALE, "FullFractalScale", 
      "1/(1 + gy)^c scaling", "", true, true, false); 
   scalesMenu->addEntry(NO_PATCH, "noPatch", "No patch for tied evaluations", 
                        "", true, true, true); 
   scalesMenu->addEntry(MATCH_PROBS, "matchProbs", string("Match empirical ") 
                        + "tied probabilities", 
                        "", true, false, false); 
   scalesMenu->addEntry(BALANCE_TIES, "balanceTies",  
                        "Balance played indices of tied moves", 
                        "", true, false, false); 
   scalesMenu->addEntry(UP_TIED_TOP, "upTiedTop", "Add fix to tied top moves", 
                        "", true, false, false); 
   scalesMenu->addEntry(PUSH_TIED_TOP, "pushTiedTop", string("Progress fix ") 
                        + "to top ties and followers", 
                        "", true, false, false); 
   scalesMenu->addEntry(PUSH_ALL_TIES, "pushAllTies",  string("Progress fix ") 
                        + "to all ties and followers", 
                        "", true, false, false); 

   scalesMenu->addEntry(WEIGHT_EVALS_FIRST, "weightEvalsFirst", 
                        "Make evals as-perceived by player?", "yes",
                        true, false, true);

   map<APPLICATION_POLICIES, double> appp;
   appp[SEPARATE_REL2] = 1.0;
   //appp[LINK_REL2] = 1;
   SwingInfo swi(appp, true, false, true, false, false, 0, false, false, 0.0);
   scalesMenu->addEntry(SWING_POLICY, "swingPolicy", 
                        "Equation options for swing term(s)", string(swi), 
                        true, false, false);
   scalesMenu->addEntry(DEPTH_WINDOW, "depthWindow",
                        "Primary depth window:", "30 .. 30",
                        true, false, false);
   scalesMenu->addEntry(SWING_WINDOW, "swingWindow",
                        "Window for swing:", "5 .. 20",
                        true, false, false);
   scalesMenu->addEntry(ZERO_DEPTH, "zeroDepth",
                        "Left edge for weights over depths", "5",
                        true, false, false);
   scalesMenu->addEntry(JUDGMENT_DEPTH, "judgmentDepth",
                        "Depth to predict (0 for turn max)", "0",
                        true, false, false);

   scalesMenu->addEntry(CENTER_DELTA, "centerDelta", "Scale regardless of eval:", 
                        "off", true, false, true); 
   scalesMenu->addEntry(CENTER_EVAL, "centerEval", "Scale from overall eval:", 
                        "on", true, true, false); 
   scalesMenu->addEntry(STRADDLE_EVALS, "straddleEvals", string("Scale by ") 
                        + "eval and previous eval:", "off", true, false, false); 
   scalesMenu->addEntry(RADIUS,"radius","Highest delta treated at face value =", 
                        "0.00", true, false, true); 
   scalesMenu->addEntry(SCALE_POWER, "scalePower", "c in fractal scales =", 
                        "1.0", true, false, false); 
   scalesMenu->addEntry(GRADIENT, "gradient", "Gradient at plateau end =", 
                        "1.600", true, false, false); 
   scalesMenu->addEntry(NEG_GRADIENT, "negGradient", "Gradient at negative end =",
                        "1.200", true, false, false);
   scalesMenu->addEntry(BETA, "beta", "Slope mul for (delta-bx) subtraction",
                        "1.000", true, false, false);
   scalesMenu->addEntry(GAMMA, "gamma", "Comb. factor for MulScale & subtraction",
                        "1.000", true, false, false);
   scalesMenu->addEntry(NORM_FACTORS, "normFactors", 
                        //"Normalization factors (stockfish-7 = 1.0)",
                        "", 
                        "(*omodo*,0.96688)(*tockfish*,1.00000)",
                        true, false, false);
   scalesMenu->addEntry(DELTA_CAP, "deltaCap", "Cap on blunder deltas = ", 
                        //IRutil::ftoa(focusTrial->getDeltaCap(), 2), 
                        IRutil::ftoa(IRutil::DELTACAP, 2),
                        true, false, true); 
   scalesMenu->addEntry(PIN_TO_CAP, "pinToCap", "Zero differential at cap?", 
                        "no", true, false, false); 
   scalesMenu->addEntry(EQUAL_TOP_FIX, "equalTopFix", string("Delta for ") 
                        + "equal-top moves = ", "0.00", true, false, false); 
   scalesMenu->addEntry(PATCH_POWER, "patchPower", "Power for equal-top moves",
                        IRutil::ftoa(IRutil::CENTRALPATCHPOWER), false, false, false);
   string infix = "[" + scalesMenu->getStatus(DEPTH_WINDOW) + "," + scalesMenu->getStatus(SWING_WINDOW)
                      + "; " + scalesMenu->getStatus(JUDGMENT_DEPTH) + "]";
   string suffix = "(" + scalesMenu->getStatus(RADIUS) + ","  
                       + scalesMenu->getStatus(SCALE_POWER) + "," 
                       + scalesMenu->getStatus(GRADIENT) + ","
                       + scalesMenu->getStatus(NEG_GRADIENT) + ","
                       + scalesMenu->getStatus(BETA) + ","
                       + scalesMenu->getStatus(GAMMA) + ")";  //";"
                       //+ scalesMenu->getStatus(NORM_FACTORS) + ")";
   scalesMenu->addEntry(BASE_SCALE_NAME, "baseScaleName", "", 
                        "SimpleFullFractalScale" + infix + suffix, true, false, true); 
   scalesMenu->addEntry(FINISH_SCALE, "finishScale", string("Save Settings") 
                        + " and Finish", "", true, false, false); 
   scalesMenu->setPostamble(IRutil::DASHLINE); 
 
   pre = "Enter factors for equation options; condition swing; couple/decouple params";
   swingMenu->setPreamble(pre);
   swingMenu->addEntry(GO_SWING, "goSwing", "Submit options", "", true, false, true);
   swingMenu->addEntry(NO_SWING_TERM, "noSwing", "Zero out swing term", 
                       "0", false, false, true);
   swingMenu->addEntry(JOIN_TERMS, "joinTerms", "Swing with power a added to delta, then /s and ^c", 
                       "0", false, false, false);
   swingMenu->addEntry(LINK_TERMS, "linkTerms", "Swing/s with power a added to delta/s, then ^c",
                       "0", false, false, false);
   swingMenu->addEntry(SEPARATE_TERMS, "separateTerms", "Swing with power ac (or a) is separate term",
                       "1", false, true, false);
   swingMenu->addEntry(APPLY_TO_PROXY, "applyProxy", "Apply swing to proxy value",
                       "0", false, false, false);
   swingMenu->addEntry(ABS_SWING, "absoluteSwing", "Do not subtract first move's swing sw1", 
                       "0", false, false, true);
   swingMenu->addEntry(REL1_SWING, "rel1Swing", "Swing subtracts sw1 before test",
                       "0", false, false, false);
   swingMenu->addEntry(REL2_SWING, "rel2Swing", "Swing subtracts sw1 after test",
                       "1", false, true, false);
   swingMenu->addEntry(REL3_SWING, "rel3Swing", "Subtraction term has separate power",
                       "0", false, false, false);
   swingMenu->addEntry(COUPLE_PARAMS, "coupleParams", "Use s,c,a,hm in multiple terms",
                       "", false, true, true);
   swingMenu->addEntry(DECOUPLE_PARAMS, "decoupleParams", "Each term has own params",
                       "", false, false, false);
   swingMenu->addEntry(DEPTH_WTD, "depthWeighted", "Swing weights depend on depth",
                       "yes", false, false, true);
   swingMenu->addEntry(UNSCALED_SWING, "unscaledSwing", "Use swing from raw deltas",
                       "", false, false, true);
   swingMenu->addEntry(SCALED_SWING, "scaledSwing", "Use swing from scaled deltas",
                       "", false, true, false);
   swingMenu->addEntry(SIMPLE, "simpleSwing", "Swing values not divided by delta",
                       "", false, false, true);
   swingMenu->addEntry(PROPORTIONAL, "proportionalSwing", "Swing values divided by delta",
                       "", false, false, false);
   swingMenu->addEntry(DAMPED, "dampedSwing", "Swing values 'damped' at large deltas",
                       "", false, true, false);
   swingMenu->addEntry(BOXED, "boxedSwing", "Swing values damped inside delta box",
                       "", false, false, false);
   swingMenu->addEntry(BOXED_OPTION, "boxedOption", "Options 0-9 for boxing swing",
                       "0", false, false, true);
   swingMenu->addEntry(SCALE_HERE, "scaleHere", "Scale deltas (also) when applying curves",
                       "no", false, false, false);
   swingMenu->addEntry(TRANS_POWER, "transPower", "a in power (1 + a(1 - u))/u",
                       "0.0", false, false, false);
   swingMenu->setPostamble(IRutil::DASHLINE);

   pre = "Edit any parameter(s), or enter Elo rating to set central-fit parameters from it.";
   paramsMenu->setPreamble(pre);
   paramsMenu->addEntry(GO_SPEC, "goSpec", "Save with these values",
                        "", false, false, true);
   paramsMenu->addEntry(CURVE, "curves", "Curve(s)", curvesMenu->nameOf(IRfun::INVEXP) + ": "
                        + curvesMenu->getDescription(IRfun::INVEXP), false, false, true);
   paramsMenu->addEntry(WEIGHT_FN, "weightFn", "Weight function", weightsMenu->nameOf(IRfun::UNITWTS) + ": "
                        + weightsMenu->getDescription(IRfun::UNITWTS), false, false, false);
   //paramsMenu->addEntry(ARG_FORMATION, "argFormation", "Power c out, in, or proxy?", "in",
                        //false, false, false);
   paramsMenu->addEntry(RATING, "rating", "(Set from) Intrinsic Rating", "0000", false, false, true);
   paramsMenu->addEntry(SET_FROM_STRING, "setFromString", "Set parameters from string",
                        "", false, false, false);
   paramsMenu->addEntry(TRIALSPEC_NAME, "specName", "TrialSpec name",
                        "E0000", false, false, false);
   paramsMenu->addEntry(S_VALUE, "sValue", "Sensitivity s value", "0.050", false, false, true);
   paramsMenu->addEntry(C_VALUE, "cValue", "Consistency c value", "0.600", false, false, false);
   paramsMenu->addEntry(D_VALUE, "dValue", "Depth d value", "12.5", false, false, false);
   paramsMenu->addEntry(V_VALUE, "vValue", "Peak-variation v value", "0.050", false, false, false);
   paramsMenu->addEntry(A_VALUE, "aValue", "Swing-minus power a", "1.000", false, false, false);
   paramsMenu->addEntry(HM_VALUE, "hmValue", "Eval/swing-minus hm scaler", "1.000", false, false, false);
   paramsMenu->addEntry(HP_VALUE, "hpValue", "Eval/swing-plus hp scaler", "1.000", false, false, false);
   paramsMenu->addEntry(B_VALUE, "bValue", "Swing-plus power b in ab", "1.000", false, false, false);
   paramsMenu->addEntry(SLIDES, "slides", "Slide by another curve?", "no", false, false, true);
   paramsMenu->addEntry(SLIDE_CURVE, "slideCurve", "Curve to slide into at tail",
                        curvesMenu->nameOf(IRfun::FOLDEDLOGISTIC), false, false, false);
   paramsMenu->addEntry(SLIDE_LO, "slideLo", "Point where sliding starts", "0.00", false, false, false);
   paramsMenu->addEntry(SLIDE_MID, "slideMid", "Point where curves are equal", "2.00", false, false, false);
   paramsMenu->addEntry(SLIDE_HI, "slideHi", "Point where slider takes over", "5.00", false, false, false);
   paramsMenu->addEntry(SLIDE_POWER, "slidePower", "1 for linear, > 1 for sigmoid", "1.0", false, false, false);
   paramsMenu->addEntry(SLIDE_PROP, "slideProp", "Maximum proportion of slide curve", "1.0", false, false, false);
   paramsMenu->addEntry(MEMO_STEP, "memoStep",
                      "Memoize curve values every p.nn",
                      "0.010", false, false, true);
   paramsMenu->addEntry(MEMO_LIMIT, "memoLimit",
                      "Memoize values up to p.nn",
                      "0.00", false, false, false);
   paramsMenu->addEntry(SHOW_STEP, "showStep",
                      "Display curve values every p.nn",
                      "0.01", false, false, true);
   paramsMenu->addEntry(SHOW_LIMIT, "showLimit",
                      "Display values up to p.nn",
                      "3.00", false, false, false);
   paramsMenu->addEntry(SHOW_CURVE, "showCurve",
                      "Show values on screen",
                      "", false, false, false);



   //paramsMenu->addEntry(SPEC_JUDGMENT_DEPTH, "specJudgmentDepth", "Judgment depth (0 = turn max)",
                        //"0", false, false, true);
   pre = string("Change setting or enter ")
            + IRutil::itoa(GO_SPEC) + "/" + paramsMenu->nameOf(GO_SPEC)
            + " to save.";

   paramsMenu->setPostamble(IRutil::DASHLINE + string("\n") + pre);

   pre = "Choose model for first-line probability p and curve value a_i:"; 
   modelsMenu->setPreamble(pre); 
   modelsMenu->addEntry(Models::SHARES, "Shares", "Pr[move i] = p*a_i"); 
   modelsMenu->addEntry(Models::POWER_SHARES, "PowerShares", "Pr[move i] = p^{1/a_i}"); 
 
   outsMenu->setPreamble("Active output streams and files."); 
   outsMenu->addEntry("cout", ""); 
 
   compareMenu->setPreamble("Choose comparison:"); 
   compareMenu->addEntry(LEQ, "leq", "Turn value <= #"); 
   compareMenu->addEntry(EQ, "eq", "Turn value == #"); 
   compareMenu->addEntry(GEQ, "geq", "Turn value >= #"); 
 
   mainMenu->addEntry(NEW_TRIAL, "newTrial", "Define New Trial", 
                      "", false, false, true);   //true puts dashes above 
   mainMenu->addEntry(CHANGE_TRIAL, "changeTrial", 
                      "Change (equation model of) Focus Trial"); 
   mainMenu->addEntry(SHOW_TRIAL, "showTrial", 
                      "Show Active Trial and Filters"); 
   mainMenu->addEntry(LOAD_DELTA_SCALE, "deltaScale", string("Delta Scale---") 
                      + "Load or Define New"); 
   mainMenu->addEntry(ADD_TURNS, "addTurns", "Add More Game Turns"); 
   mainMenu->addEntry(CLEAR_TURNS, "clearTurns", 
                      "Clear Turns And Filtered Tuples"); 
 
   mainMenu->addEntry(NEW_FILTER, "newFilters", "Define New Move Filter", 
                      "", false, false, true);  //novel, so dashes above 
   mainMenu->addEntry(ATTACH_FILTERS, "attach", 
                      "Attach Filter(s) to Focus Trial"); 
   mainMenu->addEntry(DETACH_FILTERS, "detach", 
                      "Detach Filter(s) from Focus Trial"); 
   mainMenu->addEntry(CLEAR_FILTERS, "clearFilters", 
                      "Clear Filters from Focus Trial"); 
   mainMenu->addEntry(HIDE_FILTERS, "hideFilters", 
                      "Hide Filters"); 
   mainMenu->addEntry(NEW_SELECTOR, "newSelectors", "Define New Move Selector",
                      "", false, false, true);  //novel, so dashes above
   mainMenu->addEntry(TOGGLE_SELECTORS, "toggleSelectors", "Toggle Move Selector");
 
   mainMenu->addEntry(NEW_TRIAL_SPEC, "newTrialSpec", 
                      "Define and Load New Trial Spec", 
                      "", false, false, true); 
   mainMenu->addEntry(LOAD_TRIAL_SPEC, "loadTrialSpec", 
                      "Show Active Trial Specs and Load One"); 
   mainMenu->addEntry(HIDE_SPECS, "hideSpecs", 
                      "Hide Trial Specs"); 
 
   //mainMenu->addEntry(PERCFIT_TRIAL, "percfitTrial", 
                      //"Run Percentile Fit on Focus Trial", 
                      //"", false, false, true); 
   mainMenu->addEntry(RUN_FIT, "runFit", "Run Fit to Find Best (s,c,...)",
                      "", false, false, true); 
   mainMenu->addEntry(PERF_TEST, "perfTest", 
                      "Run Performance Test on Focus Trial"); 
   //mainMenu->addEntry(PERF_TEST_ALL, "perfTestAll", 
                      //"Run Perf. Test on All Active TrialSpecs"); 
 
   mainMenu->addEntry(ADD_OUTPUT_FILE, "addOutputFile", "Attach Output File", 
                      "", false, false, true); 
   mainMenu->addEntry(CLOSE_OUTPUT_FILE, "closeOutputFile", 
                      "Close Output File"); 
   mainMenu->addEntry(READ_COMMANDS, "readCommands", 
                      "Process Commands from File"); 
   //mainMenu->addEntry(RUN_DEMO, "runDemo", "Run Demo"); 
   mainMenu->addEntry(QUIT, "quit", "Quit"); 
 
   pre = "Choose one of the following filter options:"; 
   filtersMenu->setPreamble(pre); 
   filtersMenu->addEntry(NO_FILTER, "done", 
                         "Cancel, or stop adding filter disjuncts."); 
   filtersMenu->addEntry(EXISTING_FILTER, "existingFilter", 
                         "Load an already-defined filter."); 
   filtersMenu->addEntry(FN_FILTER, "FnFilter", 
                         "Filter with pre-written function"); 
   filtersMenu->addEntry(NOT_FILTER, "NotFilter", 
                         "NOT of another filter (load or define new)"); 
   filtersMenu->addEntry(AND_FILTER, "AndFilter", 
                         "AND of other filters (load or define new)"); 
   filtersMenu->addEntry(OR_FILTER, "OrFilter", 
                         "OR of other filters (load or define new)"); 
 
   filtersMenu->addEntry(PLAYER_IS, "PlayerIs", 
                         "Games involving player (both sides' moves)", 
                         "", false, false, true); 
   filtersMenu->addEntry(PLAYER_IS_ONE_OF, "PlayerIsOneOf", 
                         "Games involving players (both sides' moves)"); 
   filtersMenu->addEntry(PLAYER_IS_ON_MOVE, "PlayerToMove", 
                         "Player on move is..."); 
   filtersMenu->addEntry(PLAYER_ON_MOVE_IS_ONE_OF, "PlayersToMove", 
                         "Player on move is one of..."); 
   filtersMenu->addEntry(ON_MOVE_FACING, "OnMoveFacing", 
                         "Game turns facing player..."); 
   filtersMenu->addEntry(ON_MOVE_FACING_ONE_OF, "OnMoveFacingOneOf", 
                         "Game turns facing one of..."); 
   filtersMenu->addEntry(WHITE_IS, "WhiteIs", 
                         "White is... (both sides' moves)"); 
   filtersMenu->addEntry(BLACK_IS, "BlackIs", 
                         "Black is... (both sides' moves)"); 
 
   filtersMenu->addEntry(EVENT_IS, "EventIs", "Event is...", "", 
                         false, false, true); 
   filtersMenu->addEntry(DATE_IS, "DateIs", "Date is (Arena format)..."); 
   filtersMenu->addEntry(EVENT_DATE_IS, "EventDateIs", "Event date is (Arena format)...");
   filtersMenu->addEntry(YEAR_IS, "YearIs", "Year is (4-digits)..."); 
 
   filtersMenu->addEntry(WHITE_ELO, "WhiteElo", "White Elo is at least / at most...", "",
                         false, false, true);
   filtersMenu->addEntry(BLACK_ELO, "BlackElo", "Black Elo is at least / at most...");
   filtersMenu->addEntry(PLAYER_ELO, "PlayerElo", 
                         "Elo of player to move is at least / at most...");
   filtersMenu->addEntry(ELO_DIFF, "EloDiff",
                         "Player Elo - opponent Elo is at least / at most...");
   filtersMenu->addEntry(ELO_DIFF_WITHIN, "EloDiffWithin", "Difference of Elos is within...");

   filtersMenu->addEntry(EVAL_WHITE, "EvalWhite", 
                         "Eval to White is...", "", false, false, true); 
   filtersMenu->addEntry(PREV_EVAL_WHITE, "PrevEvalWhite", 
                         "Previous eval to White is..."); 
   filtersMenu->addEntry(EVAL_WITHIN, "EvalWithin", 
                         "Evaluation is within..."); 
   filtersMenu->addEntry(PREV_EVAL_WITHIN, "PrevEvalWithin", 
                         "Eval of previous turn is within..."); 
   filtersMenu->addEntry(NEXT_EVAL_WITHIN, "NextEvalWithin",
                         "Eval of next turn is within...");
   filtersMenu->addEntry(TURN_NO, "MoveNo", 
                         "Move number is at least / at most..."); 
   filtersMenu->addEntry(NUM_LEGAL_MOVES, "NumLegalMoves", 
                         "Number of legal moves is at least / at most..."); 
   filtersMenu->addEntry(DELTA_I, "DeltaIs", 
                         "Delta[i...] is at least / at most..."); 
   filtersMenu->addEntry(DELTA_DIFF, "DeltaDiff", 
                         "Delta[i] - Delta[j] is at least / at most..."); 
   filtersMenu->addEntry(SECOND_DELTA, "SecondDelta", 
                         "Next-best move is inferior by at least / at most..."); 
   filtersMenu->addEntry(DELTA_N, "LastDeltaIs", 
                         "Nth-best move is inferior by at least / at most..."); 
 
   filtersMenu->addEntry(REP_COUNT, "RepCount", "Turn not in repeating sequence",
                         "", false, false, true);

   filtersMenu->addEntry(PLAYED_MOVE_INDEX, "PlayedMoveIndex", 
                         "Played Move Index is at least / at most..."); 
   filtersMenu->addEntry(PLAYED_MOVE_IS_SELECTED, "PlayedMoveSelected",
                         "Played move is selected by given MoveSelector");
   filtersMenu->addEntry(ENGINE_MOVE_IS_SELECTED, "EngineMoveSelected",
                         "Engine move is selected by given MoveSelector");
   filtersMenu->addEntry(EQUAL_TOP_MOVE_IS_SELECTED, "EqualTopMoveSelected",
                         "Equal top move is selected by given MoveSelector");
   filtersMenu->addEntry(SOME_MOVE_IS_SELECTED, "SomeLegalMoveSelected",
                         "Some move is selected by given MoveSelector");
   filtersMenu->addEntry(FALLOFF, "Falloff",  
                         "Delta of Played Move is at least / at most..."); 
   filtersMenu->addEntry(WEIGHT, "WeightIs", 
                         "Turn weight is at least / at most..."); 
   filtersMenu->addEntry(PROB_I, "ProbIs", 
                         "Est. prob. of move[i...] is at least / at most..."); 

   pre = "Choose one of the following move-selector options:";
   selectorsMenu->setPreamble(pre);
   selectorsMenu->addEntry(NO_SELECTOR, "done",
                         "Cancel, or stop adding selector disjuncts.");
   selectorsMenu->addEntry(EXISTING_SELECTOR, "existingSelector",
                         "Load an already-defined selector.");
   selectorsMenu->addEntry(FN_SELECTOR, "FnSelector",
                         "Selector with pre-written function");
   selectorsMenu->addEntry(NOT_SELECTOR, "NotSelector",
                         "NOT of another selector (load or define new)");
   selectorsMenu->addEntry(AND_SELECTOR, "AndSelector",
                         "AND of other selectors (load or define new)");
   selectorsMenu->addEntry(OR_SELECTOR, "OrSelector",
                         "OR of other selectors (load or define new)");
   selectorsMenu->addEntry(MAP_SELECTOR, "MappedMoveSelector",
                         "Map of turns to moves from other selector");
   selectorsMenu->addEntry(MOVE_EVAL_SELECTOR, "MoveEvalSelector",
                         "Move eval at depth d is <=> threshold");
   selectorsMenu->addEntry(MOVE_RAW_DELTA_SELECTOR, "MoveRawDeltaSelector",
                         "Move delta at depth d is <=> threshold");
   selectorsMenu->addEntry(MOVE_RAW_SWING_SELECTOR, "MoveRawSwingSelector",
                         "Move raw swing up to depth D is <=> threshold");
   selectorsMenu->addEntry(MOVE_SCALED_SWING_SELECTOR, "MoveScaledSwingSelector",
                         "Move scaled swing up to depth D is <=> threshold");

/*
   enum METHOD {
      VWALK, GSL_NM4, GSL_NM6, GSL_NM7, GSL_SIM_ANN, CMINPACK_LMDIF, CMINPACK_HYBRD, NUM_METHODS
   };
   enum SKED {
      UNIT_SKED, SQRT_SKED, LIN_SKED, QUAD_SKED, INVVAR_SKED, NUM_SKEDS
   };
*/
   methodMenu->setPreamble("Choose fitting method, HYBRD only for exact solutions.");
   methodMenu->addEntry(Minimizer::VWALK, "vwalk", "Two-dimensional bitonic search");
   methodMenu->addEntry(Minimizer::GSL_NM4, "GSLNMold", "GSL Nelder-Mead, old version");
   methodMenu->addEntry(Minimizer::GSL_NM6, "GSLNM", "GSL Nelder-Mead, newer version");
   methodMenu->addEntry(Minimizer::GSL_NM7, "GSLNMrand", "GSL Nelder-Mead with random orientations");
   methodMenu->addEntry(Minimizer::GSL_SIM_ANN, "GSLSA", "GSL Simulated Annealing");
   methodMenu->addEntry(Minimizer::CMINPACK_LMDIF, "LMDIF", "Levenberg-Marquardt difference method (not yet working)");
   methodMenu->addEntry(Minimizer::CMINPACK_LMDIF1, "LMDIF1", "Levenberg-Marquardt, simplified call (not yet working)");
   methodMenu->addEntry(Minimizer::CMINPACK_HYBRD, "HYBRD", "Hybrid Powell difference method (not yet working)");
   methodMenu->addEntry(Minimizer::CMINPACK_HYBRD1, "HYBRD1", "Hybrid Powell, simplified call (not yet working)");
   methodMenu->addEntry(Minimizer::MPFIT_LMDIF, "MPFITLM", "Levenberg-Marquardt, MPFIT version (not yet working)");

   skedMenu->setPreamble("Choose weighting scheme for index values");
   skedMenu->addEntry(Minimizer::UNIT_SKED, "unitsked", "Unit weight for each index");
   skedMenu->addEntry(Minimizer::SQRT_SKED, "sqrtsked", "Square-root weights after squaring");
   skedMenu->addEntry(Minimizer::LIN_SKED, "linsked", "Linear weights after squaring (sqrt before)");
   skedMenu->addEntry(Minimizer::QUAD_SKED, "quadsked", "Linear weights before squaring");
   skedMenu->addEntry(Minimizer::INVVAR_SKED, "invvarsked", "Weighted by inverse variance");
   skedMenu->addEntry(Minimizer::SQRT_ALLWT, "sqrtallwt", "Square-root all-weight after squaring");
   skedMenu->addEntry(Minimizer::LIN_ALLWT, "linallwt", "Linear all-weight after squaring (sqrt before)");
   skedMenu->addEntry(Minimizer::QUAD_ALLWT, "quadallwt", "Linear all-weight before squaring");



   fitMenu->addEntry(Minimizer::PERCFIT, "percFit", 
                     "Fit focus trial's percentiles", "0.00", false, false, true); 
   fitMenu->addEntry(Minimizer::ML, "maxLikely", 
                     "Maximum likelihood of played moves", 
                     "0.00", false, false, false);   //not starred, no dashes above 
   fitMenu->addEntry(Minimizer::BINS, "bins",
                     "Fit frequency in percentile bins", "0.00",
                     false, false, false);
   fitMenu->addEntry(Minimizer::FALLOFF, "falloff",
                     "Fit scaled falloff",
                     "1.00", false, true, true);
   fitMenu->addEntry(Minimizer::FIRST_LINE, "firstLine",
                     "Fit first index",
                     "1.00", false, true, false);
   fitMenu->addEntry(Minimizer::SECOND_LINE, "secondLine",
                     "Fit second index",
                     "1.00", false, true, false);
   fitMenu->addEntry(Minimizer::THIRD_LINE, "thirdLine",
                     "Fit third index",
                     "0.00", false, false, false);
   fitMenu->addEntry(Minimizer::ETV, "equalTopValue",
                     "Fit equal-top value moves to index",
                     IRutil::itoa(IRutil::NCUTOFF) + ": 1.00", false, true, false);
   fitMenu->addEntry(Minimizer::INDEX_FIT, "indexFit",
                     "Fit indices [m thru n] by sked",
                     "[1,4] sqrtsked: 0.00", false, false, false);
   fitMenu->addEntry(Minimizer::INDEX_DIFF, "indexDiff",
                     "Fit +- diff in [m thru n] by sked",
                     "[1,4] sqrtsked: 0.0", false, false, false);
   fitMenu->addEntry(Minimizer::ERROR1, "error1",
                     "Fit error X.mm to Y.nn",
                     "[0.51, 1.00] sqrtallwt: 0", false, false, false);
   fitMenu->addEntry(Minimizer::ERROR2, "error2",
                     "Fit error X.mm to Y.nn",
                     "[1.01, 999.99] sqrtallwt: 0", false, false, false);


   fitMenu->addEntry(MIN_METHOD, "minMethod", "Minimization method",
                     methodMenu->nameOf(Minimizer::GSL_NM6), true, false, true);
   fitMenu->addEntry(FUNNEL_FACTORS, "funnelFactors", "mu in f + mu*g, map mu to mu/div",
                     "0.0 div by 2.0", true, false, false);
   fitMenu->addEntry(START_SPEC, "startSpec", "", "", false, false, false);


   fitMenu->addEntry(S_BOUNDS, "sBounds", "Bounds for s are", 
                     "0.0001 .. 1.024", false, true, true); 
   fitMenu->addEntry(C_BOUNDS, "cBounds", "Bounds for c are",
                     "0.0000 .. 10.0000", false, true, false); 
   fitMenu->addEntry(D_BOUNDS, "dBounds", "Bounds for d are",
                     //"0.000 .. 30.0", true, false, false);
                     //"-20.5 .. 50.5", false, false, false);
                     "12.5 .. 12.5", false, false, false);
   fitMenu->addEntry(V_BOUNDS, "vBounds", "Bounds for v are",
                     //"0.000 .. 10.0", true, false, false);
                     //"-1.0000 .. 1.0000", false, false, false);
                     "0.05 .. 0.05", false, false, false);
   fitMenu->addEntry(A_BOUNDS, "aBounds", "Bounds for a are",
                     //"0.0000 .. 10.0000", false, false, false);
                     "0.0000 .. 10.0000", false, true, false);
   fitMenu->addEntry(HM_BOUNDS, "hmBounds", "Bounds for hm are",
                     "0.0000 .. 100.0000", false, true, false);
   fitMenu->addEntry(HP_BOUNDS, "hpBounds", "Bounds for hp are",
                     "1.0000 .. 1.0000", false, false, false);
   fitMenu->addEntry(B_BOUNDS, "bBounds", "Bounds for b are",
                     "1.0000 .. 1.0000", false, false, false);

   //fitMenu->addEntry(FIT_JUDGMENT_DEPTH, "fitJudgmentDepth", "(0 for turn max depth)",
                     //"0", false, false, false);
   fitMenu->addEntry(MAX_ITERATIONS, "maxIterations", "max # of iterations",
                     "2000", false, false, true);
   fitMenu->addEntry(NUM_RETRIES, "numRetries", "= # tries at same temp in SA",
                     "50", false, false, false);
   fitMenu->addEntry(PRECISION_X, "xprec", "Precision on x-axes",
                     "0.0001", false, false, false);
   fitMenu->addEntry(PRECISION_Y, "yprec", "Precision of function values",
                     "0.0001", false, false, false);
   fitMenu->addEntry(PRECISION_G, "gprec", "Precision of other geometry",
                     "0.00001", false, false, false);
   //fitMenu->addEntry(WALKOUT, "walkOut", "Walk out from spec point?",
                     //"yes", true, false, false);
   fitMenu->addEntry(WALKOUT_STEP, "walkOutStep", "Initial walkout step",
                     "0.01", true, false, false);
   fitMenu->addEntry(EPSFCN, "epsfcn", "Minpack epsfcn, or initemp/10000 in SA",
                     "0.001", true, false, false);
   fitMenu->addEntry(GO, "go", "Run Fit With These Settings!", "",
                     false, false, true);

   fitMenu->addEntry(BOOT_NUM, "bootNum", "Number of Bootstrap Trials", "0",
                     true, false, false);
   fitMenu->addEntry(KEEP_SPEC_IN_BOOT, "keepSpecInBoot", "Keep regressed spec in bootstrap?", "no",
                     false, false, false);
   fitMenu->addEntry(VERBOSE, "verbose", "Verbose output?", 
                     "yes", true, false, false); 

   pre = "Enter number to change setting, " 
            + IRutil::itoa(GO + fitMenu->getFDI()) 
            + "/" + fitMenu->nameOf(GO) + " to run fit on focus trial."; 
   fitMenu->setPreamble(pre); 



   testMenu->addEntry(GO_TEST, "goTest", "Run test with these settings", 
                      "", true, false, true);
   testMenu->addEntry(USE_FOCUS_SPEC, "useFocusSpec", "Use current TrialSpec?",
                      "yes", true, false, true);
   testMenu->addEntry(MISS_IS_MOVE_NPLUSONE, "missIsNP1",
                      "Treat miss as Move N+1?", "no", true, false, false);
   testMenu->addEntry(FORCE_UNIT_WEIGHTS, "forceUnitWeights", 
                      "Override spec to use unit weights?",
                      "no", true, false, false);
   testMenu->addEntry(SHOW_UNWEIGHTED, "showUnweighted",
                      "Duplicate output to show unit weights?",
                      "no", false, false, true);
   testMenu->addEntry(SHOW_UNSCALED, "showUnscaled",
                      "Duplicate output with unscaled deltas?",
                      "no", false, false, false);
   testMenu->addEntry(NUM_INDICES, "numIndices", 
                      "Number of Kth-best lines to show",
                      "15", true, false, true);
   testMenu->addEntry(EQUAL_TOP_INDEX_LIMIT, "equalTopIndexLimit",
                      "Index limit on equal-top-value moves",
                      IRutil::itoa(IRutil::NCUTOFF), false, false, false);
   testMenu->addEntry(NUM_BOOTSTRAP_TRIALS, "numBootTests",
                      "Number of bootstrap trials", 
                      "0", true, false, true);
   testMenu->addEntry(NUM_RESAMPLE_TRIALS, "numResampleTrials",
                      "Number of resampling trials",
                      "0", true, false, true);
   testMenu->addEntry(NUM_RESAMPLE_GAMES, "numResampleGames",
                      "Number of games to resample",
                      "9", false, false, false);
   testMenu->addEntry(NUM_RESAMPLE_TURNS, "numResampleTurns",
                      "Number of turns to resample",
                      "0", false, false, false);
   testMenu->addEntry(ONE_PLAYER_PER_GAME, "onePlayerPerGame",
                      "Choose one side of each game?",
                      "yes", false, false, false);
   testMenu->addEntry(ZMM_FILE, "zmmFile", "File for move-match z-scores",
                      "zmm.txt", false, false, true);
   testMenu->addEntry(ZEV_FILE, "zevFile", "File for equal-value match z-scores",
                      "zev.txt", false, false, false);
   testMenu->addEntry(ZAD_FILE, "zadFile", "File for average-difference z-scores",
                      "zad.txt", false, false, false);
   testMenu->addEntry(MOVES_FILE, "movesFile", "File for probability data on moves",
                      "movesDump.txt", false, false, false);
   testMenu->addEntry(MOVES_LIMIT, "movesLimit", "Limit on # of positions written",
                      "1000", false, false, false);
   testMenu->addEntry(SHOW_INDIVIDUAL_MOVES, "showMoves",
                      "List each move and its probability?",
                      "no", false, false, false);

   pre = string("Enter number to change setting, ")
            + IRutil::itoa(GO_TEST) + "/" + testMenu->nameOf(GO_TEST)
            + " to run statistical tests.";
   testMenu->setPreamble(pre);
   testMenu->setPostamble(IRutil::DASHES);

 
   pre = "Choose demo to run, or " + IRutil::itoa(EnumMenu::CANCEL_CHOICE) 
            + "/" + demosMenu->CANCEL_NAME + " to cancel."; 
   demosMenu->setPreamble(pre); 
   demosMenu->addEntry(Demos::ELISTA_DEMO, "elistaDemo", 
                       "Test Elista 2006 games 1-6 with focus trial-spec."); 
   demosMenu->addEntry(Demos::SAN_LUIS_MEXICO_DEMO, "sanLuisMexicoDemo", 
                       "Topalov at San Luis '05 vs. Anand at Mexico '07."); 
   demosMenu->addEntry(Demos::SWING_DEMO, "swingDemo", 
                       "Test 'swing' effects of unprobed earlier ply depths."); 
   demosMenu->addEntry(Demos::DEMORALIZATION_DEMO, "demoralizationDemo", 
                       "Do we play better when ahead, worse when behind?"); 
} 
 
 
void Ensemble::interactFromStream(istream* istrp, const string& matchString = "") { 
                                  //bool suppressQuit) { 
   if (justUsedCin->status && istrp != &cin) { 
      //IRutil::finishLine(cin); 
      justUsedCin->status = false; 
   } 
   string line; 
   INP = istrp; 
   if (matchString != "") { 
      getline(*INP,line);   //not logged 
      while ((!IRutil::delimitedMatch(matchString,line)) && (!atEOF())) { 
         getline(*INP,line); 
      } 
   } 
   //last line we got should be a comment line, so we can throw it away 
   string cal = IRutil::getTime(); 
   // loggedWrite(IRutil::IRCOMMENT + "Reading commands at time " + cal + " (" 
   //                       + IRutil::getRawTime() + ")\n"); 
 
   bool interacting = true; 
   while (interacting) { 
      int choice = mainMenu->readChoice(); 
      if (mainMenu->success(choice) && (choice != QUIT)) { 
		  //TAMAL
         //try { 
            doMainMenuItem(choice); 
        // } catch (exception &e) { 
       //     cerr << "Error " << e.what() << endl; 
      //   } 
      } else if (choice == QUIT || choice == EnumMenu::STREAM_END_CHOICE) { 
         interacting = false; 
      } else { 
         cout << "Choose " + IRutil::itoa(QUIT + mainMenu->getFDI()) + "/" 
                           + mainMenu->nameOf(QUIT) 
                           + " if you wish to quit." << endl; 
      } 
   } 
   (*INP).clear(); 
   (*INP).ignore(numeric_limits<streamsize>::max(),'\n'); 
   INP = &cin; 
} 
 
 
void Ensemble::interact() { 
   interactFromStream(INP, ""); 
} 
 
 
 
double Ensemble::readS() const { 
   double s; 
   if (usingCin()) { 
      cout << "Enter sensitivity s or enter Elo rating: "; 
   } 
   loggedRead(s,false); 
   return s; 
} 
 
double Ensemble::readC() const { 
   double c; 
   if (usingCin()) { 
      cout << "Enter consistency c: "; 
   } 
   loggedRead(c,false); 
   return c; 
} 

double Ensemble::readD() const {
   double d;
   if (usingCin()) {
      cout << "Enter (central) depth d: ";
   }
   loggedRead(d,false);
   return d;
}

double Ensemble::readV() const {
   double v;
   if (usingCin()) {
      cout << "Enter var^n coeff v: ";
   }
   loggedRead(v,false);
   return v;
}

double Ensemble::readA() const {
   double a;
   if (usingCin()) {
      cout << "Enter (negative) swing exponent a: ";
   }
   loggedRead(a,false);
   return a;
}

double Ensemble::readHM() const {
   double hm;
   if (usingCin()) {
      cout << "Enter minus-eval/swing multiplier hm: ";
   }
   loggedRead(hm,false);
   return hm;
}

double Ensemble::readHP() const {
   double hp;
   if (usingCin()) {
      cout << "Enter plus-eval/swing multiplier hp: ";
   }
   loggedRead(hp,false);
   return hp;
}

double Ensemble::readB() const {
   double b;
   if (usingCin()) {
      cout << "Enter (positive) swing/slack power/term a: ";
   }
   loggedRead(b,false);
   return b;
}

/*
size_t Ensemble::readJD() const {
   size_t jd;
   if (usingCin()) {
      cout << "Enter data depth to use for judgments, 0 for turn max: ";
   }
   loggedRead(jd,false);
   return jd;
}
*/




pair<int,int> Ensemble::readBounds() const {
   int lo,hi;
   if (usingCin()) {
      cout << "Enter lo and hi bounds for depth, as ints sep by space: ";
   }
   loggedRead(lo,false);
   loggedRead(hi,false);
   return pair<int,int>(lo,hi);
}

void Ensemble::resetParamsMenu() {
   paramsMenu->setStatus(TRIALSPEC_NAME, focusTrial->getSpec().name);
   paramsMenu->setStatus(S_VALUE, IRutil::ftoa(focusTrial->getSpec().s));
   paramsMenu->setStatus(C_VALUE, IRutil::ftoa(focusTrial->getSpec().c));
   paramsMenu->setStatus(D_VALUE, IRutil::ftoa(focusTrial->getSpec().d));
   paramsMenu->setStatus(V_VALUE, IRutil::ftoa(focusTrial->getSpec().v));
   paramsMenu->setStatus(A_VALUE, IRutil::ftoa(focusTrial->getSpec().a));
   paramsMenu->setStatus(HM_VALUE, IRutil::ftoa(focusTrial->getSpec().hm));
   paramsMenu->setStatus(HP_VALUE, IRutil::ftoa(focusTrial->getSpec().hp));
   paramsMenu->setStatus(B_VALUE, IRutil::ftoa(focusTrial->getSpec().b));
   //paramsMenu->setStatus(SPEC_JUDGMENT_DEPTH, IRutil::ftoa(focusTrial->getSpec().judgmentDepth));
}

 
 
TrialSpec Ensemble::makeTrialSpec() const { 
   IRfun::CURVES curveChoice = IRfun::CURVES(IRfun::INVEXP); 
   IRfun::WEIGHTS weightChoice = IRfun::WEIGHTS(IRfun::UNITWTS); 
   map<IRfun::CURVES,double> curveBook;
   string curvesStr = "";
   for (int i = 0; i < IRfun::CURVES(IRfun::NUM_CURVES); i++) {
      double mul = IRutil::extractDoubles(curvesMenu->getStatus(IRfun::CURVES(i)))[0];
      IRfun::CURVES curve = IRfun::CURVES(i);
      if (mul > 0) {
         curveBook[curve] = mul;
         curvesStr += "(" + IRfun::curveNames[curve] + ":" + IRutil::ftoa(mul) + ")";
      }
   }
   map<IRfun::CURVES,double>::const_iterator cbit = curveBook.begin();
   map<IRfun::CURVES,double>::const_iterator cbite = curveBook.end();
   IRfun::CURVES curve;
   double mul;
   paramsMenu->setStatus(CURVE, curvesStr);
   double floatItem;
   double s,c,d,v,a,hm,hp,b;
   vector<double> vals;
   vector<double>::const_iterator vit, vite;
   bool slide = IRutil::isYes(paramsMenu->getStatus(SLIDES));
   IRfun::CURVES slideCurveChoice = IRfun::CURVES(curvesMenu->indexOf(paramsMenu->getStatus(SLIDE_CURVE)));
   double slideLo = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_LO))[0];
   double slideMid = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_MID))[0];
   double slideHi = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_HI))[0];
   double slidePower = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_POWER))[0];
   double slideProp = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_PROP))[0];
   double memoStep = IRutil::extractDoubles(paramsMenu->getStatus(MEMO_STEP))[0];
   double memoLimit = IRutil::extractDoubles(paramsMenu->getStatus(MEMO_LIMIT))[0];
   double showStep = IRutil::extractDoubles(paramsMenu->getStatus(SHOW_STEP))[0];
   double showLimit = IRutil::extractDoubles(paramsMenu->getStatus(SHOW_LIMIT))[0];
   double deltaCap = focusTrial->getScale()->getDeltaCap();
   TrialSpec ts;

   IRutil::nullstream nullstrm;
   ostream& ccout = (usingCin()) ? cout : nullstrm;
   int rating; //could be negative...
   string argFormation, name, ans;
   string curveName;
   string weightsName;
   bool setFromRating = false;
   int choice, choice2, intItem;
   bool entering = true;
   bool innerEntering;
   while (entering) {
      choice = paramsMenu->readChoice();
      switch(choice) {
       case GO_SPEC:
         s = atof(paramsMenu->getStatus(S_VALUE).c_str());
         c = atof(paramsMenu->getStatus(C_VALUE).c_str());
         d = atof(paramsMenu->getStatus(D_VALUE).c_str());
         v = atof(paramsMenu->getStatus(V_VALUE).c_str());
         a = atof(paramsMenu->getStatus(A_VALUE).c_str());
         hm = atof(paramsMenu->getStatus(HM_VALUE).c_str());
         hp = atof(paramsMenu->getStatus(HP_VALUE).c_str());
         b = atof(paramsMenu->getStatus(B_VALUE).c_str());
         name = IRutil::trim(paramsMenu->getStatus(TRIALSPEC_NAME));
         //judgmentDepth = atoi(paramsMenu->getStatus(SPEC_JUDGMENT_DEPTH).c_str());
         //argFormation = paramsMenu->getStatus(ARG_FORMATION);
         curveName = paramsMenu->getStatus(CURVE);
         //curveName = IRutil::trim(curveName.substr(0,curveName.find(':')));
         //curveChoice = IRfun::CURVES(curvesMenu->indexOf(curveName));
         curveChoice = cbit->first;
         weightsName = paramsMenu->getStatus(WEIGHT_FN);
         weightsName = IRutil::trim(weightsName.substr(0,weightsName.find(':')));
         weightChoice = IRfun::WEIGHTS(weightsMenu->indexOf(weightsName));
         slide = IRutil::isYes(paramsMenu->getStatus(SLIDES));
         slideCurveChoice = IRfun::CURVES(curvesMenu->indexOf(paramsMenu->getStatus(SLIDE_CURVE)));
         slideLo = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_LO))[0];
         slideMid = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_MID))[0];
         slideHi = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_HI))[0];
         slidePower = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_POWER))[0];
         slideProp = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_PROP))[0];
         memoStep = atof(paramsMenu->getStatus(MEMO_STEP).c_str());
         memoLimit = atof(paramsMenu->getStatus(MEMO_LIMIT).c_str());

         entering = false;
         //TrialSpec ts(curveChoice,s,c,d,v,w,em,ep,a,weightChoice,judgmentDepth,name);
         //return ts;
         break;
       case CURVE:
         choice2 = -1;
         innerEntering = true;
         while (innerEntering && choice2 != -5) {
            choice2 = curvesMenu->readChoice(true, true);  //invokes specialGo in readChoice
            if ((choice2 == -6 || IRfun::INVEXP <= choice2) && choice2 < IRfun::NUM_CURVES) {
               if (usingCin()) {
                  cout << "Enter float weight (0 to exclude): ";
               }
               loggedRead(floatItem, false);
               if (usingCin()) { cout << endl; }
               intItem = (choice2 == -6 ? 0 : choice2);
               curvesMenu->setStatus(intItem, IRutil::ftoa(floatItem));
               if (floatItem != 0) {
                  curvesMenu->setStarred(intItem,true);
               } else {
                  curvesMenu->setStarred(intItem,false);
               }
            }
            innerEntering = (choice2 == -6 || choice2 > 0);  
         }
         curveChoice = IRfun::CURVES(choice2);
         //paramsMenu->setStatus(CURVE, curvesMenu->nameOf(choice2) + ": "
                                    //+ curvesMenu->getDescription(choice2));
         curveBook.clear();
         curvesStr = "";
         for (int i = 0; i < IRfun::CURVES(IRfun::NUM_CURVES); i++) {
            mul = IRutil::extractDoubles(curvesMenu->getStatus(IRfun::CURVES(i)))[0];
            curve = IRfun::CURVES(i);
            if (mul > 0) {
               curveBook[curve] = mul;
            }
         }
         if (curveBook.size() == 0) {
            cerr << "No curve selected, using pure INVEXP." << endl;
            curveBook[IRfun::INVEXP] = 1.0;
         }
         cbite = curveBook.end();
         for (cbit = curveBook.begin(); cbit != cbite; ++cbit) {
            curve = IRfun::CURVES(cbit->first);
            mul = cbit->second;
            curvesStr += "(" + IRfun::curveNames[curve] + ":" + IRutil::ftoa(mul) + ")";
         }
         cbit = curveBook.begin();
         curveChoice = cbit->first;
         paramsMenu->setStatus(CURVE, curvesStr);
         break;
       case WEIGHT_FN:
         choice2 = weightsMenu->readChoice();
         weightChoice = IRfun::WEIGHTS(choice2);
         paramsMenu->setStatus(WEIGHT_FN, weightsMenu->nameOf(choice2) + ": " 
                                        + weightsMenu->getDescription(choice2));
         break;

       case SLIDES:
         if (usingCin()) {
            cout << "Slide to another curve toward the tail? ";
         }
         loggedRead(ans,false);
         ans = IRutil::trim(ans);
         paramsMenu->setStatus(SLIDES,ans);
         break;
       case SLIDE_CURVE:
         if (usingCin()) {
            cout << "Choose slide curve---one-shot choice only: " << endl;
         }
         choice2 = -1;
         while (IRfun::INVEXP > choice2 || choice2 >= IRfun::NUM_CURVES) {
            choice2 = curvesMenu->readChoice(true, true);
         }
         slideCurveChoice = IRfun::CURVES(choice2);
         paramsMenu->setStatus(SLIDE_CURVE, curvesMenu->nameOf(slideCurveChoice));
         break;
       case SLIDE_LO:
         if (usingCin()) {
            cout << "Enter starting point of slide: ";
         }
         loggedReadBounded(slideLo,0,deltaCap,false);
         paramsMenu->setStatus(SLIDE_LO, IRutil::ftoa(slideLo));
         break;
       case SLIDE_MID:
         if (usingCin()) {
            cout << "Enter midpoint of slide: ";
         }
         loggedReadBounded(slideMid,0,deltaCap,false);
         paramsMenu->setStatus(SLIDE_MID, IRutil::ftoa(slideMid));
         break;
       case SLIDE_HI:
         if (usingCin()) {
            cout << "Enter point at which tail curve takes over: ";
         }
         loggedReadBounded(slideHi,slideMid,deltaCap,false);
         paramsMenu->setStatus(SLIDE_HI, IRutil::ftoa(slideHi));
         break;
       case SLIDE_POWER:
         if (usingCin()) {
            cout << "Enter 1 for straight line, > 1 for sigmoid: ";
         }
         loggedRead(slidePower,false);
         paramsMenu->setStatus(SLIDE_POWER, IRutil::ftoa(slidePower));
         break;
       case SLIDE_PROP:
         if (usingCin()) {
            cout << "Enter maximum proportion up to 1 for the slide spec: ";
         }
         loggedReadBounded(slideProp,0,1,false);
         paramsMenu->setStatus(SLIDE_PROP, IRutil::ftoa(slideProp));
         break;

/*
       case ARG_FORMATION:
         if (usingCin()) {
            cout << "Form args as (.+.)^c, (.^c,.^c), or proxy? Enter out, in, or proxy: ";
         }
         loggedRead(argFormation);
         paramsMenu->setStatus(ARG_FORMATION, argFormation);
         break;
*/
       case RATING:
         if (usingCin()) {
            cout << "Enter Elo rating; parameters will match it: ";
         }
         loggedRead(rating);
         paramsMenu->setStatus(RATING, IRutil::itoa(rating));
         s = IRfun::sOfElo(rating);
         c = IRfun::cOfElo(rating);
         d = IRfun::dOfElo(rating);
         v = IRfun::vOfElo(rating);
         a = IRfun::aOfElo(rating);
         hm = IRfun::hmOfElo(rating);
         hp = IRfun::hpOfElo(rating);
         b = IRfun::bOfElo(rating);
         name = "E" + IRutil::itoa(IRutil::round(rating));
         paramsMenu->setStatus(S_VALUE, IRutil::ftoa(s));
         paramsMenu->setStatus(C_VALUE, IRutil::ftoa(c));
         paramsMenu->setStatus(D_VALUE, IRutil::ftoa(d));
         paramsMenu->setStatus(V_VALUE, IRutil::ftoa(v));
         paramsMenu->setStatus(A_VALUE, IRutil::ftoa(a));
         paramsMenu->setStatus(HM_VALUE, IRutil::ftoa(hm));
         paramsMenu->setStatus(HP_VALUE, IRutil::ftoa(hp));
         paramsMenu->setStatus(B_VALUE, IRutil::ftoa(b));
         paramsMenu->setStatus(TRIALSPEC_NAME, name);
         break;
       case SET_FROM_STRING:
         if (usingCin()) {
            cout << "Paste any string with up to 8 numbers: ";
         }
         ans = loggedGetline();
         if (IRutil::trim(ans) == "") { ans = loggedGetline(); }
         vals = IRutil::extractDoubles(ans);
         vit = vals.begin();
         vite = vals.end();
         s = (vit != vite ? *vit++ : atof(paramsMenu->getStatus(S_VALUE).c_str()));
         c = (vit != vite ? *vit++ : atof(paramsMenu->getStatus(C_VALUE).c_str()));
         d = (vit != vite ? *vit++ : atof(paramsMenu->getStatus(D_VALUE).c_str()));
         v = (vit != vite ? *vit++ : atof(paramsMenu->getStatus(V_VALUE).c_str()));
         a = (vit != vite ? *vit++ : atof(paramsMenu->getStatus(A_VALUE).c_str()));
         hm = (vit != vite ? *vit++ : atof(paramsMenu->getStatus(HM_VALUE).c_str()));
         hp = (vit != vite ? *vit++ : atof(paramsMenu->getStatus(HP_VALUE).c_str()));
         b = (vit != vite ? *vit++ : atof(paramsMenu->getStatus(B_VALUE).c_str()));
         paramsMenu->setStatus(S_VALUE, IRutil::ftoa(s));
         paramsMenu->setStatus(C_VALUE, IRutil::ftoa(c));
         paramsMenu->setStatus(D_VALUE, IRutil::ftoa(d));
         paramsMenu->setStatus(V_VALUE, IRutil::ftoa(v));
         paramsMenu->setStatus(A_VALUE, IRutil::ftoa(a));
         paramsMenu->setStatus(HM_VALUE, IRutil::ftoa(hm));
         paramsMenu->setStatus(HP_VALUE, IRutil::ftoa(hp));
         paramsMenu->setStatus(B_VALUE, IRutil::ftoa(b));
         break;
       case TRIALSPEC_NAME:
         if (usingCin()) {
            cout << "Enter descriptive name for TrialSpec: ";
         }
         loggedRead(name, true);  //end line with entered name
         name = IRutil::trim(name);
         paramsMenu->setStatus(TRIALSPEC_NAME, name);
         break;
       case S_VALUE:
         s = readS();
         paramsMenu->setStatus(S_VALUE, IRutil::ftoa(s));
         break;
       case C_VALUE:
         c = readC();
         paramsMenu->setStatus(C_VALUE, IRutil::ftoa(c));
         break;
       case D_VALUE:
         d = readD();
         paramsMenu->setStatus(D_VALUE, IRutil::ftoa(d));
         break;
       case V_VALUE:
         v = readV();
         paramsMenu->setStatus(V_VALUE, IRutil::ftoa(v));
         break;
       case A_VALUE:
         a = readA();
         paramsMenu->setStatus(A_VALUE, IRutil::ftoa(a));
         break;
       case HM_VALUE:
         hm = readHM();
         paramsMenu->setStatus(HM_VALUE, IRutil::ftoa(hm));
         break;
       case HP_VALUE:
         hp = readHP();
         paramsMenu->setStatus(HP_VALUE, IRutil::ftoa(hp));
         break;
       case B_VALUE:
         b = readB();
         paramsMenu->setStatus(B_VALUE, IRutil::ftoa(b));
         break;
       //case SPEC_JUDGMENT_DEPTH:
         //judgmentDepth = readJD();
         //paramsMenu->setStatus(SPEC_JUDGMENT_DEPTH, IRutil::itoa(judgmentDepth));
         //break;
       case MEMO_STEP:
         ccout << "Enter memo interval for curve in p.nn units: ";
         loggedReadBounded(memoStep,0.001,1.0,false);
         paramsMenu->setStatus(choice, IRutil::ftoa(memoStep));
         break;
       case MEMO_LIMIT:
         ccout << "Show curve values up to p.nn: ";
         loggedReadBounded(memoLimit,0.00,10.00,false);
         paramsMenu->setStatus(choice, IRutil::ftoa(memoLimit));
         break;
       case SHOW_STEP:
         ccout << "Enter memo interval for curve in p.nn units: ";
         loggedReadBounded(showStep,0.001,1.0,false);
         paramsMenu->setStatus(choice, IRutil::ftoa(showStep));
         break;
       case SHOW_LIMIT:
         ccout << "Show curve values up to p.nn: ";
         loggedReadBounded(showLimit,0.00,10.00,false);
         paramsMenu->setStatus(choice, IRutil::ftoa(showLimit));
         break;

       case SHOW_CURVE:
         s = atof(paramsMenu->getStatus(S_VALUE).c_str());
         c = atof(paramsMenu->getStatus(C_VALUE).c_str());
         d = atof(paramsMenu->getStatus(D_VALUE).c_str());
         v = atof(paramsMenu->getStatus(V_VALUE).c_str());
         a = atof(paramsMenu->getStatus(A_VALUE).c_str());
         hm = atof(paramsMenu->getStatus(HM_VALUE).c_str());
         hp = atof(paramsMenu->getStatus(HP_VALUE).c_str());
         b = atof(paramsMenu->getStatus(B_VALUE).c_str());
         name = IRutil::trim(paramsMenu->getStatus(TRIALSPEC_NAME));
         curveName = paramsMenu->getStatus(CURVE);
         curveChoice = cbit->first;
         weightsName = paramsMenu->getStatus(WEIGHT_FN);
         weightsName = IRutil::trim(weightsName.substr(0,weightsName.find(':')));
         weightChoice = IRfun::WEIGHTS(weightsMenu->indexOf(weightsName));
         slide = IRutil::isYes(paramsMenu->getStatus(SLIDES));
         slideCurveChoice = IRfun::CURVES(curvesMenu->indexOf(paramsMenu->getStatus(SLIDE_CURVE)));
         slideLo = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_LO))[0];
         slideMid = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_MID))[0];
         slideHi = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_HI))[0];
         slidePower = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_POWER))[0];
         slideProp = IRutil::extractDoubles(paramsMenu->getStatus(SLIDE_PROP))[0];
         memoStep = atof(paramsMenu->getStatus(MEMO_STEP).c_str());
         //memoLimit = atof(paramsMenu->getStatus(MEMO_LIMIT).c_str());
         showStep = atof(paramsMenu->getStatus(SHOW_STEP).c_str());
         showLimit = atof(paramsMenu->getStatus(SHOW_LIMIT).c_str());

         ts = TrialSpec(curveChoice,curveBook,weightChoice,name,s,c,d,v,a,hm,hp,b, //judgmentDepth,
                        slide, slideCurveChoice, slideLo, slideMid, slideHi, slidePower, slideProp,
                        memoStep, 0.0);
         cout << ts.showCurvePoints(showStep,showLimit) << endl;
         break;
       default:
         cout << "Invalid entry; please try again: ";
      }
   }
   //curveBook has been maintained on the fly
   ts = TrialSpec(curveChoice,curveBook,weightChoice,name,s,c,d,v,a,hm,hp,b, //judgmentDepth,
		  slide, slideCurveChoice, slideLo, slideMid, slideHi, slidePower, slideProp,
                  memoStep, memoLimit);
   return ts;
} 
 
 
LineScale* Ensemble::makeDeltaScale() const { 
   LineScale* ls;   //base scale constructed from menu, always a LineScale 
   LineScale* df;   //final scale returned 
   map<APPLICATION_POLICIES, double> appp;
   //appp[LINK_REL2] = 1;   //matches default in main()
   appp[SEPARATE_REL2] = 1.0;   //matches default in main()
   SwingInfo* swp = new SwingInfo(appp, true, false, true, false, false, 0, false, false, 0.0);
   IRutil::nullstream nullstrm; 
   ostream& ccout = (usingCin()) ? cout : nullstrm; 
   string ans, desc, status, prompt; 
   size_t pos,pos2,pos3;
   string capstr = scalesMenu->getStatus(DELTA_CAP);
   double deltaCap = atof(capstr.c_str());
   double radius, scalePower, gradient, negGradient, equalTopFix, patchPower, beta, gamma;
   double floatItem; 
   map<string,double> normFactors;
   DELTA_PATCHES pp; 
   bool wef;     //weight evals first
   string wefstr = "";
   //string swp;   //swing policy
   size_t userLowDepth, userHighDepth, userSwingLow, userSwingHigh, zeroDepth, judgmentDepth;
 
   // The most complicated menu interaction in the program, and I prefer 
   // while(entering) to while(choice != "go")... 
   // To share code updating the scale name, I implement fall-thru: 
   bool fallThru = false; 
   string baseName, patchPolicy, infix, suffix; 
   int baseClass, policyChoice; 
 
   //scalesMenu->resetDefaults(); 
   int choice; 
   bool entering = true; 
   while (entering) { 
      choice = scalesMenu->readChoice(); 
      switch(choice) { 
       case NO_SCALING: 
       case LINEAR_SCALE: 
       case MUL_SCALE:
       case MIX_SCALE:
       case DIVLOG_SCALE: 
       case LOG_SCALE: 
       case FRACTAL_SCALE: 
       case FULL_FRACTAL_SCALE: 
         for (int j = NO_SCALING; j < NUM_DELTA_SCALES; j++) { 
            scalesMenu->setStarred(j, false); 
         } 
         scalesMenu->setStarred(choice,true); 
         if (choice == NO_SCALING) { 
            scalesMenu->setStatus(BASE_SCALE_NAME, "NoScaling"); 
         } 
         if (choice == LOG_SCALE) { 
            scalesMenu->setStatus(SCALE_POWER, "1.0"); 
            ccout << "LogScale is FractalScale with scalePower = 1.0." << endl; 
         } 
         fallThru = true;  //!! to re-set the base-scale name. 
 
       case NO_PATCH: 
       case MATCH_PROBS: 
       case BALANCE_TIES: 
       case UP_TIED_TOP: 
       case PUSH_TIED_TOP: 
       case PUSH_ALL_TIES: 
         if (!fallThru) { 
            for (int j = NO_PATCH; j < NUM_DELTA_PATCHES; j++) { 
               scalesMenu->setStarred(j, false); 
            } 
         } 
         scalesMenu->setStarred(choice, true); 
         fallThru = true; 
        
       case CENTER_DELTA: 
       case CENTER_EVAL: 
       case STRADDLE_EVALS: 
         if (!fallThru) { 
            prompt = ((choice == CENTER_DELTA) ? 
                           "Include best move as center, regardless of eval?" 
                        : ((choice == CENTER_EVAL) ? 
                              "Include center on eval of current position?" 
                            : "Include center on eval of previous position?")); 
            ccout << prompt << " (y/n) "; 
            loggedRead(ans,false); 
            if (IRutil::isYes(ans) || IRutil::trim(ans) == "on") { 
               scalesMenu->setStarred(choice,true); 
               scalesMenu->setStatus(choice,"on"); 
            } else { 
               scalesMenu->setStarred(choice,false); 
               scalesMenu->setStatus(choice,"off"); 
            } 
            break; 
         } 
       case WEIGHT_EVALS_FIRST:
         if (!fallThru) {
            ccout << "Weight evals by player depth first? (y/n) ";
            loggedRead(ans,false);
            scalesMenu->setStatus(choice, IRutil::isYes(ans) ? "yes" : "no");
            fallThru = true;
        }
       case SWING_POLICY:
         if (!fallThru) {
            //ccout << "Can be \"none\" or any string of scale+fixed+relative[123]+join/link/sep/proxy+boxed/damped/prop: ";
            //loggedRead(ans,false);
            //ans = IRutil::trim(ans);
            //scalesMenu->setStatus(choice, ans);
            delete(swp);
            swp = makeSwingInfo();
            scalesMenu->setStatus(choice, string(*swp));
            fallThru = true;
         }
       case DEPTH_WINDOW:
         if (!fallThru) {
            ccout << "Enter lowest and highest depths considered: " << endl;
            loggedReadBounded(userLowDepth,0,100,false);
            loggedReadBounded(userHighDepth,userLowDepth,100,false);
            scalesMenu->setStatus(choice, IRutil::itoa(userLowDepth) + " .. "
                                     + IRutil::itoa(userHighDepth));
            fallThru = true;
         }
       case SWING_WINDOW:
         if (!fallThru) {
            ccout << "Enter lowest and highest depths for swing: " << endl;
            loggedReadBounded(userSwingLow,0,100,false);
            loggedReadBounded(userSwingHigh,userSwingLow,100,false);
            scalesMenu->setStatus(choice, IRutil::itoa(userSwingLow) + " .. "
                                     + IRutil::itoa(userSwingHigh));
            fallThru = true;
         }
       case ZERO_DEPTH:
         if (!fallThru) {
            ccout << "Enter depth for zero point of Poisson distribution: " << endl;
            loggedReadBounded(zeroDepth,0,100,false);
            scalesMenu->setStatus(choice, IRutil::itoa(zeroDepth));
            fallThru = true;
         }
       case JUDGMENT_DEPTH:
         if (!fallThru) {
            ccout << "Enter depth to predict (0 for turn max): " << endl;
            loggedReadBounded(judgmentDepth,0,100,false);
            scalesMenu->setStatus(choice, IRutil::itoa(judgmentDepth));
            fallThru = true;
         }
       case RADIUS: 
         if (!fallThru) { 
            ccout << "Enter max margin considered part of plateau, " 
                  << "e.g. 0.75 pawns: "; 
            loggedReadBounded(radius,0,deltaCap,false); 
            scalesMenu->setStatus(choice, IRutil::ftoa(radius,2)); 
            fallThru = true; 
         }  
       case SCALE_POWER: 
         if (!fallThru) { 
            if (scalesMenu->isStarred(LOG_SCALE)) { 
               ccout << "Can't change scale power for log scale, sorry." 
                     << endl; 
            } else { 
               ccout << "Enter new c for 1/y^c or 1/log(y^c) scaling: "; 
               loggedReadBounded(scalePower,0,100,false); 
               scalesMenu->setStatus(choice, IRutil::ftoa(scalePower)); 
            } 
            fallThru = true; 
         } 
       case GRADIENT: 
         if (!fallThru) { 
            ccout << "Enter steepness at end of plateau " 
                  << "(> 1.0 means steeper): "; 
            loggedReadBounded(gradient,0,100,false); 
            scalesMenu->setStatus(choice, IRutil::ftoa(gradient)); 
            fallThru = true;
         } 
       case NEG_GRADIENT:
         if (!fallThru) {
            ccout << "Enter steepness at negative end "
                  << "(> 1.0 means steeper): ";
            loggedReadBounded(negGradient,0,100,false);
            scalesMenu->setStatus(choice, IRutil::ftoa(negGradient));
            fallThru = true;
         }
       case BETA:
         if (!fallThru) {
            ccout << "Enter b for delta - bx scaling"
                  << "(> 1.0 means steeper): ";
            loggedReadBounded(beta,0,100,false);
            scalesMenu->setStatus(choice, IRutil::ftoa(beta));
            fallThru = true;
         }
       case GAMMA:
         if (!fallThru) {
            ccout << "Enter combination factor for MulScale: ";
            loggedReadBounded(gamma,0,100,false);
            scalesMenu->setStatus(choice, IRutil::ftoa(gamma));
            fallThru = true;
         }
       case DELTA_CAP:
         if (!fallThru) {
            ccout << "Enter new cap on blunder deltas (max "
                  << IRutil::ftoa(IRutil::DELTACAP) << "): ";
            loggedRead(deltaCap,false);
            scalesMenu->setStatus(choice, IRutil::ftoa(deltaCap, 2));
         }

         //Now we must recall which base-name is starred:
         baseClass = NO_SCALING;
         while (!scalesMenu->isStarred(baseClass)) { baseClass++; }
         policyChoice = NO_PATCH;
         while (!scalesMenu->isStarred(policyChoice)) { policyChoice++; }
         baseName = scalesMenu->nameOf(baseClass);   //note: is capitalized
         patchPolicy = scalesMenu->nameOf(policyChoice);
         wefstr = (IRutil::isYes(scalesMenu->getStatus(WEIGHT_EVALS_FIRST)) ? ", WEF" : "");
         capstr = scalesMenu->getStatus(DELTA_CAP);
         //swp = scalesMenu->getStatus(SWING_POLICY);
         infix = "[" + scalesMenu->getStatus(DEPTH_WINDOW) + ", " 
                     + scalesMenu->getStatus(SWING_WINDOW)
                     + "; " + scalesMenu->getStatus(JUDGMENT_DEPTH) + "]";
         suffix = "(" + scalesMenu->getStatus(RADIUS) + ","
                      + scalesMenu->getStatus(SCALE_POWER) + ","
                      + scalesMenu->getStatus(GRADIENT) + ","
                      + scalesMenu->getStatus(NEG_GRADIENT) + ","
                      + scalesMenu->getStatus(BETA) + ","
                      + scalesMenu->getStatus(GAMMA) + ")";
         scalesMenu->setStatus(BASE_SCALE_NAME, baseName + ", " + patchPolicy
                               + wefstr + ", cap " + capstr + "; " + string(*swp) + "\n" + infix + suffix);
         fallThru = false;
         break;

       case NORM_FACTORS:
         ccout << "Enter identifying substring for engine: ";
         ans = "";
         while (ans == "") {
            loggedRead(ans,false);
            ans = IRutil::trim(ans);
         }
         ccout << "Enter normalization value as multiplier: ";
         loggedRead(floatItem,false);
         desc = scalesMenu->getDescription(choice);
         if (desc.find("Normalization") != string::npos) {
            scalesMenu->setDescription(choice,""); 
         }
         status = scalesMenu->getStatus(choice);
         pos = status.find(ans);
         if (pos != string::npos) {  //changing existing entry
            pos2 = status.find(",", pos);
            pos3 = status.find(")", pos2);
            status.replace(pos2+1,pos3-pos2-1,IRutil::ftoa(floatItem));
            scalesMenu->setStatus(choice,status);
         } else {
            scalesMenu->setStatus(choice, status + "(*" + ans + "*," + IRutil::ftoa(floatItem) + ") ");
         }
         break;
       case PIN_TO_CAP: 
         ccout << "Make differential approach 0 at delta-cap? (y/n) "; 
         loggedRead(ans,false); 
         scalesMenu->setStatus(choice, IRutil::isYes(ans) ? "yes" : "no"); 
         break; 
       case EQUAL_TOP_FIX: 
         ccout << "Enter new value for equal-top fudge factor, e.g. 0.02: "; 
         loggedRead(equalTopFix,true);  //break line here in log file 
         scalesMenu->setStatus(choice, IRutil::ftoa(equalTopFix, 3)); 
         break; 
       case PATCH_POWER:
         ccout << "Enter new value for patch power, e.g. 0.58: ";
         loggedRead(patchPower,true);  //break line here in log file
         scalesMenu->setStatus(choice, IRutil::ftoa(patchPower, 4));
         break;
       case BASE_SCALE_NAME: 
         ccout << "Enter name for base scale (do again if you " 
               << "change parameters): "; 
         loggedRead(ans,true); //inserts newline in log 
         scalesMenu->setStatus(choice, IRutil::trim(ans)); 
         break; 
       case FINISH_SCALE: 
         entering = false; 
         break; 
       default: 
         ccout << "No other options, must make valid choice, " 
               << FINISH_SCALE << "/" << scalesMenu->nameOf(FINISH_SCALE) 
               << " to end." << endl; 
         break; 
      } 
   } //end of while loop 
 
   deltaCap = atof((scalesMenu->getStatus(DELTA_CAP)).c_str()); 
 
   if (scalesMenu->isStarred(NO_SCALING)) { 
      //scalesMenu->resetDefaults(); 
      theUnitLineScale->setDeltaCap(deltaCap);
      return theUnitLineScale; 
   } 
   //else 
   int ppi = NO_PATCH; 
   while (ppi < NUM_DELTA_PATCHES && !scalesMenu->isStarred(ppi)) { ppi++; } 
   pp = (ppi == NUM_DELTA_PATCHES) ? NO_PATCH : DELTA_PATCHES(ppi); 
   wef = IRutil::isYes(scalesMenu->getStatus(WEIGHT_EVALS_FIRST));
   //swp = scalesMenu->getStatus(SWING_POLICY);
 
   radius = atof((scalesMenu->getStatus(RADIUS)).c_str()); 
   scalePower = atof((scalesMenu->getStatus(SCALE_POWER)).c_str()); 
   gradient = atof((scalesMenu->getStatus(GRADIENT)).c_str()); 
   negGradient = atof((scalesMenu->getStatus(NEG_GRADIENT)).c_str());
   normFactors = IRutil::parseStarredPairs(scalesMenu->getStatus(NORM_FACTORS));
   equalTopFix = atof((scalesMenu->getStatus(EQUAL_TOP_FIX)).c_str()); 
   patchPower = atof((scalesMenu->getStatus(PATCH_POWER)).c_str());
   baseName = scalesMenu->getStatus(BASE_SCALE_NAME); 
   zeroDepth = atoi((scalesMenu->getStatus(ZERO_DEPTH)).c_str());
   judgmentDepth = atoi((scalesMenu->getStatus(JUDGMENT_DEPTH)).c_str());
   userLowDepth = size_t(IRutil::extractDoubles(scalesMenu->getStatus(DEPTH_WINDOW))[0]);
   userHighDepth = size_t(IRutil::extractDoubles(scalesMenu->getStatus(DEPTH_WINDOW))[1]);
   userSwingLow = size_t(IRutil::extractDoubles(scalesMenu->getStatus(SWING_WINDOW))[0]);
   userSwingHigh = size_t(IRutil::extractDoubles(scalesMenu->getStatus(SWING_WINDOW))[1]);
   beta = atof((scalesMenu->getStatus(BETA)).c_str());
   gamma = atof((scalesMenu->getStatus(GAMMA)).c_str());
   
cerr << "Zero depth: " << zeroDepth << "; judgment depth " << judgmentDepth << "; ";
cerr << "Depth window: " << scalesMenu->getStatus(DEPTH_WINDOW) << "; Swing window "
<< userSwingLow << ".." << userSwingHigh << endl;
 
   if (scalesMenu->isStarred(LINEAR_SCALE)) { 
      ls = new LinearScale(baseName, wef, swp, pp, patchPower, equalTopFix, normFactors,
                           zeroDepth, userLowDepth, userHighDepth, userSwingLow, 
                           userSwingHigh, judgmentDepth, radius, scalePower, gradient); 
   } else if (scalesMenu->isStarred(MUL_SCALE)) {
      ls = new MulScale(baseName, wef, swp, pp, patchPower, equalTopFix, normFactors,
                        zeroDepth, userLowDepth, userHighDepth, userSwingLow, userSwingHigh,
                        judgmentDepth, radius, scalePower, gradient, negGradient,
                        (negGradient != gradient));
   } else if (scalesMenu->isStarred(MIX_SCALE)) {
      ls = new MixScale(baseName, wef, swp, pp, patchPower, equalTopFix, normFactors,
                        zeroDepth, userLowDepth, userHighDepth, userSwingLow, userSwingHigh,
                        judgmentDepth, radius, scalePower, gradient, negGradient,
                        (negGradient != gradient), beta, gamma);
   } else if (scalesMenu->isStarred(DIVLOG_SCALE)) { 
      ls = new DivLogScale(baseName, wef, swp, pp, patchPower, equalTopFix, normFactors,
                           zeroDepth, userLowDepth, userHighDepth, userSwingLow,
                           userSwingHigh, judgmentDepth, radius, scalePower, gradient); 
   } else if (scalesMenu->isStarred(LOG_SCALE)) { 
      ls = new FractalScale(baseName, wef, swp, pp, patchPower, equalTopFix, normFactors,
                            zeroDepth, userLowDepth, userHighDepth, userSwingLow, 
                            userSwingHigh, judgmentDepth, radius, scalePower, gradient); 
      //repeating code with next line to make changes easier 
   } else if (scalesMenu->isStarred(FRACTAL_SCALE)) { 
      ls = new FractalScale(baseName, wef, swp, pp, patchPower, equalTopFix, normFactors,
                            zeroDepth, userLowDepth, userHighDepth, userSwingLow,
                            userSwingHigh, judgmentDepth, radius, scalePower, gradient); 
   } else if (scalesMenu->isStarred(FULL_FRACTAL_SCALE)) { 
      ls = new FullFractalScale(baseName, wef, swp, pp, patchPower, equalTopFix, normFactors,
                                zeroDepth, userLowDepth, userHighDepth, userSwingLow,
                                userSwingHigh, judgmentDepth, scalePower, gradient, negGradient); 
   } else { 
      cerr << "Bug in Scales menu." << endl; 
   } 
   if (scalesMenu->isStarred(CENTER_DELTA)) { 
      if (scalesMenu->isStarred(CENTER_EVAL)) { 
         if (scalesMenu->isStarred(STRADDLE_EVALS)) { 
            df = new TernaryScale(ls, new TranslateByEval(ls), 
                                  new StraddleEvals(ls)); 
         } else { 
            df = new BinaryScale(ls, new TranslateByEval(ls)); 
         } 
      } else { 
         if (scalesMenu->isStarred(STRADDLE_EVALS)) { 
            df = new BinaryScale(ls, new StraddleEvals(ls)); 
         } else { 
            df = ls; 
         } 
      } 
   } else { 
      if (scalesMenu->isStarred(CENTER_EVAL)) { 
         if (scalesMenu->isStarred(STRADDLE_EVALS)) { 
            df = new BinaryScale(new TranslateByEval(ls), 
                                 new StraddleEvals(ls)); 
         } else { 
            df = new TranslateByEval(ls); 
         } 
      } else { 
         if (scalesMenu->isStarred(STRADDLE_EVALS)) { 
            df = new StraddleEvals(ls); 
         } else { 
            df = new SimpleFullFractalScale(string("Simple")+baseName,
                     ls->weightsEvalsFirst(), swp, pp, patchPower, equalTopFix,
                     normFactors, ls->getZeroDepth(), ls->getLowDepth(),
                     ls->getHighDepth(), ls->getSwingLow(), ls->getSwingHigh(),
                     ls->getJudgmentDepth(), 1.0, gradient, negGradient);

/*
            df = new UnitLineScale(baseName, ls->weightsEvalsFirst(), pp, patchPower,
                    //atof((scalesMenu->getStatus(EQUAL_TOP_FIX)).c_str()),
                    equalTopFix, normFactors, ls->getZeroDepth(), ls->getLowDepth(), 
                    ls->getHighDepth(), ls->getSwingLow(), ls->getSwingHigh(),
                    ls->getJudgmentDepth());
*/
         } 
      } 
   } 
 
   if (IRutil::isYes(scalesMenu->getStatus(PIN_TO_CAP))) { 
      df = new PinToCap(df, radius, deltaCap); 
   } 
 
   df->setWEF(wef);
   df->setSwingPolicy(swp);
   df->setLowDepth(userLowDepth);
   df->setHighDepth(userHighDepth);
   df->setSwingLow(userSwingLow);
   df->setSwingHigh(userSwingHigh);
   df->setZeroDepth(zeroDepth);
   df->setJudgmentDepth(judgmentDepth);
   df->setDeltaCap(deltaCap);
   //scalesMenu->resetDefaults();
   return df; 
} 



SwingInfo* Ensemble::makeSwingInfo() const {
   IRutil::nullstream nullstrm;
   ostream& ccout = (usingCin()) ? cout : nullstrm;
   int choice = -1;
   map<APPLICATION_POLICIES,double> swingBook;
   SwingInfo* swp;
   swingMenu->resetDefaults();
   APPLICATION_POLICIES ap;
   SWING_OPTIONS option1, option2;
   bool depthDependentSwings = IRutil::isYes(swingMenu->getStatus(DEPTH_WTD));
   bool unscaledSwings = swingMenu->isStarred(UNSCALED_SWING);
   bool damped = swingMenu->isStarred(DAMPED); //IRutil::isYes(swingMenu->getStatus(DAMPED));
   bool prop = swingMenu->isStarred(PROPORTIONAL); //IRutil::isYes(swingMenu->getStatus(PROPORTIONAL));
   bool boxed = swingMenu->isStarred(BOXED); //IRutil::isYes(swingMenu->getStatus(BOXED));
   size_t boxKind = atoi(swingMenu->getStatus(BOXED_OPTION).c_str());
   bool decouple = swingMenu->isStarred(DECOUPLE_PARAMS);
   bool scaleHere = IRutil::isYes(swingMenu->getStatus(SCALE_HERE));
   double transpower = IRutil::extractDoubles(swingMenu->getStatus(TRANS_POWER))[0];
   int intItem;
   double floatItem;
   string ans;
   double mul, mul1, mul2;
   int i,j;
   bool entering = true;

   while (entering) {
      choice = swingMenu->readChoice();
      switch(choice) {
       case GO_SWING:
         depthDependentSwings = IRutil::isYes(swingMenu->getStatus(DEPTH_WTD));
         unscaledSwings = swingMenu->isStarred(UNSCALED_SWING);
         damped = swingMenu->isStarred(DAMPED);
         prop = swingMenu->isStarred(PROPORTIONAL);
         boxed = swingMenu->isStarred(BOXED);
         boxKind = atoi(swingMenu->getStatus(BOXED_OPTION).c_str());
         decouple = swingMenu->isStarred(DECOUPLE_PARAMS);
         scaleHere = IRutil::isYes(swingMenu->getStatus(SCALE_HERE));
         transpower = IRutil::extractDoubles(swingMenu->getStatus(TRANS_POWER))[0];
         mul = IRutil::extractDoubles(swingMenu->getStatus(NO_SWING_TERM))[0];
         if (mul > 0.0) {
            swingBook[NO_SWING] = mul;
         }
         for (i = JOIN_TERMS; i <= APPLY_TO_PROXY; i++) {
            for (j = ABS_SWING; j <= REL3_SWING; j++) {
               option1 = SWING_OPTIONS(i);
               option2 = SWING_OPTIONS(j);
               ap = combinePolicies(option1,option2);
               mul1 = IRutil::extractDoubles(swingMenu->getStatus(option1))[0];
               mul2 = IRutil::extractDoubles(swingMenu->getStatus(option2))[0];
               mul = mul1*mul2;
               if (mul > 0.0) {
                  swingBook[ap] = mul;
               }
            }
         }
         if (swingBook.size() == 0) {
            cerr << "No swing policy selected, please try again." << endl;
            break;
         }

         swp = new SwingInfo(swingBook, depthDependentSwings, unscaledSwings,
                             damped, prop, boxed, boxKind, decouple, scaleHere, transpower);
         entering = false;
         break;
       case NO_SWING_TERM:
       case JOIN_TERMS:
       case LINK_TERMS:
       case SEPARATE_TERMS:
       case APPLY_TO_PROXY:
       case ABS_SWING:
       case REL1_SWING:
       case REL2_SWING:
       case REL3_SWING:
         ccout << "Enter float weight (0 to exclude): ";
         loggedRead(floatItem, false);
         swingMenu->setStatus(choice, IRutil::ftoa(floatItem));
         if (floatItem == 0.0) {   //OK comparison
            swingMenu->setStarred(choice,false);
         } else {
            swingMenu->setStarred(choice,true);
         }
         break;

       case COUPLE_PARAMS:
         swingMenu->setStarred(COUPLE_PARAMS, true);
         swingMenu->setStarred(DECOUPLE_PARAMS, false);
         break;
       case DECOUPLE_PARAMS:
         swingMenu->setStarred(DECOUPLE_PARAMS, true);
         swingMenu->setStarred(COUPLE_PARAMS, false);
         break;

       case DEPTH_WTD:
         ccout << "Weight swings differently across depths via d and v? ";
         loggedRead(ans , false);
         swingMenu->setStatus(choice, IRutil::isYes(ans) ? "yes" : "no");
         break;

       case UNSCALED_SWING:
         swingMenu->setStarred(UNSCALED_SWING, true);
         swingMenu->setStarred(SCALED_SWING, false);
         break;
       case SCALED_SWING:
         swingMenu->setStarred(SCALED_SWING, true);
         swingMenu->setStarred(UNSCALED_SWING, false);
         break;

       case SIMPLE:
         swingMenu->setStarred(SIMPLE, true);
         swingMenu->setStarred(PROPORTIONAL, false);
         swingMenu->setStarred(DAMPED, false);
         swingMenu->setStarred(BOXED, false);
         break;
       case PROPORTIONAL:
         swingMenu->setStarred(SIMPLE, false);
         swingMenu->setStarred(PROPORTIONAL, true);
         swingMenu->setStarred(DAMPED, false);
         swingMenu->setStarred(BOXED, false);
         break;
       case DAMPED:
         swingMenu->setStarred(SIMPLE, false);
         swingMenu->setStarred(PROPORTIONAL, false);
         swingMenu->setStarred(DAMPED, true);
         swingMenu->setStarred(BOXED, false);
         break;
       case BOXED:
         swingMenu->setStarred(SIMPLE, false);
         swingMenu->setStarred(PROPORTIONAL, false);
         swingMenu->setStarred(DAMPED, false);
         swingMenu->setStarred(BOXED, true);
	 break;

       case BOXED_OPTION:
         ccout << "Enter option 0--9 (\"see manual\"): ";
         loggedReadBounded(intItem,0,9,false);
         swingMenu->setStatus(choice, IRutil::itoa(intItem));
         break;
       case SCALE_HERE:
         cout << "Scale deltas here, instead/on-top of other scaling? ";
         loggedRead(ans);
         swingMenu->setStatus(choice, IRutil::isYes(ans) ? "yes" : "no");
         break;
       case TRANS_POWER:
         ccout << "Enter a for logistic translation by (a + 1)/(a + exp(-u)): ";
         loggedReadBounded(floatItem,0,100,false);
         swingMenu->setStatus(choice, IRutil::ftoa(floatItem));
         break;
       default:
         ccout << "Invalid option, please try again..." << endl;
      }
   }
   return swp;
}

 


/** Parse lines matching this pattern: 
          Delta = (d.dd,d.dd, ...  ,*d.dd, ... ,d.dd) or 
          Delta = (d.dd,d.dd, ...  ,d.dd, ... ,d.dd)* 
    Ignores tag "Delta". 
    Hard-writes the capping of deltas by IRutil::DELTACAP (= 10.00). 
*/ 
int Ensemble::parseDeltas(string& line, vector<double>* deltas) const { 
   int playedMoveIndex = IRutil::playedMoveNotInTopN; 
   int startPos = line.find("("); 
   int endPos = line.find(")"); 
   line = line.substr(startPos+1,endPos-startPos-1); 
   char* pch = strtok((char*)line.c_str(),","); 
   int deltaCount = 0; 
   while (pch != NULL) {  // && deltaCount < IRutil::NCUTOFF) 
      if(pch[0] == '*') { 
         playedMoveIndex = deltaCount; 
         deltas->push_back(min(atof(pch+1), IRutil::DELTACAP)); 
      } else { 
         deltas->push_back(min(atof(pch), IRutil::DELTACAP)); 
      } 
      deltaCount++; 
      pch = strtok(NULL, ","); 
   } 
   return playedMoveIndex; 
} 

void Ensemble::readTurnsFromFileGlob(const string& fileGlobInput,
                                     bool referenceOnly, bool selectionOnly) const{
   string fileGlob = IRutil::trim(fileGlobInput);
   glob_t globbuf;
   //GLOB_TILDE expands "~" in the pattern to the home directory
   //If fileGlob has a '/' in it then figure this is only seek user wants.
   //If fileGlob begins with "../" then we log path up to "/"
   if (fileGlob.size() >= 3 && fileGlob.substr(0,3) == "../") {
      string cwd = IRutil::getmycwd();
      size_t pathEnd = cwd.find_last_of('/');
      string fullpath = cwd.substr(0,pathEnd);
      fileGlob = fullpath + fileGlob.substr(2); //includes the "/"
   }
   loggedWrite(fileGlob, true);
   vector<string> refFiles;   //checked for dupes only in this shot
         
   string lastpath = "";
   bool seeking = true;
   bool foundFiles = false;
   while (seeking) {
      glob(fileGlob.c_str(), GLOB_TILDE, NULL, &globbuf);
      for (int i = 0; i < globbuf.gl_pathc; ++i) {
         string str(globbuf.gl_pathv[i]);
         size_t pathEnd = str.find_last_of('/');  //!!! change for Windows
         string newpath = (pathEnd == string::npos ? "" : str.substr(0,pathEnd+1));
         string name = (pathEnd == string::npos ? str : str.substr(pathEnd+1));
         if (newpath != lastpath) {
            cout << "Files matched on new path " << newpath << ":" << endl;
            cout << name << endl;
         } else {
            cout << name << endl;
         }
         lastpath = newpath;
      }
      for (int i = 0; i < globbuf.gl_pathc; ++i) {
         string fileName = globbuf.gl_pathv[i];
         size_t pathEnd = fileName.find_last_of('/');
         string rawName = (pathEnd == string::npos ? fileName : fileName.substr(pathEnd+1));
         ifstream file(globbuf.gl_pathv[i]);
         vector<string>::iterator fbegin = (referenceOnly ? refFiles.begin() : loadedFiles.begin());
         vector<string>::iterator fend = (referenceOnly ? refFiles.end() : loadedFiles.end());
         if (!file.is_open()) {
            cout << "Cannot open glob match " << fileName << endl;
         } else if (find(fbegin,fend,rawName) != fend) {
            string rds = (rawName == "SF7Turns.aif" ? "un-needed occurrence of "
                                                    : "duplicate file ");
            cout << "Skipping " << rds << rawName << endl;
         } else {
            string refstr = (referenceOnly ? " for reference trial only..." : "");
            cout << "Reading file " << rawName << refstr << endl;
            readInputFile(file, referenceOnly, selectionOnly);
            foundFiles = true;
            if (referenceOnly) {
               refFiles.push_back(rawName);
            } else {
               loadedFiles.push_back(rawName);
            }
         }
      }
      if (foundFiles && (!referenceOnly)) {
         loadedGlobs = (loadedGlobs == "" ? fileGlob : loadedGlobs + ";" + fileGlob);
      }
      seeking = (fileGlob.find_last_of('/') == string::npos);
      fileGlob = dataPath + fileGlob; 
      foundFiles = false;
   }
   globfree( &globbuf );
}

void Ensemble::readTurns(istream& IN) const {   //outside the INP limitation 
   string fileGlob; 
   cout << "Enter name of file or glob." << endl; 
   IN >> fileGlob;
   //loggedWrite(fileGlob,true);  //now done in callee after substituting for "../" if present
   readTurnsFromFileGlob(fileGlob,false,false);
} 
 
/*
list<TurnInfo*>* Ensemble::readInputFile(const string& fileName, bool referenceOnly,
                                              bool selectionOnly) const { 
   ifstream file; 
   file.open((const char*)fileName.c_str(), ios::in); 
   if (!file.is_open()) { 
      cout << "Cannot read the input file." << endl; 
      return new list<TurnInfo*>(); 
   } 
   return readInputFile(file, referenceOnly, selectionOnly); 
} 
*/
 
/** Process AIF file and produced TurnInfo and GameInfo objects.
    TurnInfo stores 'raw' information of all turns in the file 
    GameInfo stores information related to games, from mainly PGN file.
    KWR: Changed to store evals as ints in centipawns.  Also changed to
    assume moves are in game sequence, and to look back in current game
    for first occurrence of repeating position, marking all intervening
    moves as being "inRep".
 */ 
list<TurnInfo*>* Ensemble::readInputFile(istream& infile, bool referenceOnly,
                                              bool selectionOnly) const { 
 
   //next is semi-debugging but should be preserved. 
   string line = ""; 
   int lineNumber = 0; 
   int turnNumber = 0; 
   //int prevTurnNumber = 1000;   //??
   int AIFoffset = 1;  //AIF format numbers depths from 1
   
   double currEval = 0.0; 
   double prevEval = 0.0; 
   double deltaFalloff, deltaFalloffCapped; 
   TurnInfo* lastTurn = NULL; 
   //vector<Move>* consideredMovesVec = new vector<Move>(); //has moves in column order, passed by value
   //vector<int> evalsCP;     //pushed back as a copy
   vector <TurnInfo> gameTurns; 
   list<TurnInfo*>* returnTurns = new list<TurnInfo*>();
   list<TurnInfo*>* fillTurns = (selectionOnly ? returnTurns : pTurns);
   GameInfo* pGameInfo = NULL; 
      
   while(getline(infile,line)) {   //outer loop over AIF *file* (or files?)
      line = IRutil::trim(line);
      lineNumber++; 
      size_t gameBegin = line.find("[GameID ");//Beginning of PGN-header part
      bool legacy = false;
      if (gameBegin == string::npos) {
         gameBegin = line.find("[Event ");  //Legacy beginning
         legacy = (gameBegin != string::npos);
      }
      size_t turnBegin = line.find("[GID "); 

      int numPV;
      int minHighDepth; 
      int maxHighDepth; //used for moves as well

      if ((gameBegin == string::npos) && (turnBegin == string::npos)) {   
         //skip---not game or turn beginning 
         continue; 
      } 
      else if (gameBegin != string::npos) {   //Game Info, commence inner loop 
//cerr << "Game ";

         string gameID;
         string engineID;
         string platform;
         int numThreads = 1;
         int hash = 512; 
         int plyDepth = 0;  //legacy
         string egt = "";
         string modestr = "??";
         string eventName = "??"; 
         string site = "??"; 
         IRutil::SimpleDate date(0,0,0); 
         int round = 1; 
         string whitePlayer = ""; 
         string blackPlayer = ""; 
         string result = "*";   //TAMAL: convert to enum? 
         string eco = "??"; 
         int whiteElo = 0; 
         int blackElo = 0; 
         int plyCount = 0; 
         IRutil::SimpleDate eventDate(0,0,0); 
         string eventType = "?!?";
         int eventRounds = 0;
         string eventCountry = "??";
         string eventCategory = "??";
         string source = ""; 
         IRutil::SimpleDate sourceDate(0,0,0); 
         string timeControl = "??";  //e.g. [TimeControl "40/4800:20/2400:1200"]
         string whiteTeam = "??";
         string blackTeam = "??";
         string whiteTeamCountry = "??";
         string blackTeamCountry = "??";
         string whiteFIDEID = "??";
         string blackFIDEID = "??";

         string tmp = "";
         //process GameHeader here 
         //Use switch case 
         
         if (!legacy) {
            gameID = IRutil::getBetweenDelm(line,'\"','\"'); 

         //PGN spec requires a blank line between header and moves.
         //It seems that for PGN export, the blank line must have no spaces.
         //KWR: No---a blank line is ^\s*$.  Spaces must be tolerated.  So we trim.
         //
         //IMPT: Does not enforce any ordering of PGN/AIF fields.
         //Unlike perl/Python script, does not load any field anonymously.

            getline(infile,line); 
            line = IRutil::trim(line);
            lineNumber++; 
         }
//cerr << gameID << endl;
         while(!line.empty()) {   //stops on blank line
            if (line.find("[EngineID ") != string::npos) {
               engineID = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[Platform ") != string::npos) {
               platform = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[Threads ") != string::npos) {
               tmp = IRutil::getBetweenDelm(line,'\"','\"');
               numThreads = atoi(tmp.c_str());
            }
            else if (line.find("[Hash ") != string::npos) {
               tmp = IRutil::getBetweenDelm(line,'\"','\"');
               hash = atoi(tmp.c_str());
            }
            else if (line.find("[MultiPV ") != string::npos) {
               tmp = IRutil::getBetweenDelm(line,'\"','\"');
               numPV = atoi(tmp.c_str());
            }
            else if (line.find("[DepthRange ") != string::npos) {
               tmp = IRutil::getBetweenDelm(line,'\"',':');
               minHighDepth = atoi(tmp.c_str());
               tmp = IRutil::getBetweenDelm(line,':','\"');
               maxHighDepth = atoi(tmp.c_str());
            }
            else if (line.find("[PlyDepth ") != string::npos) {  //legacy
               string plyDepthStr = IRutil::getBetweenDelm(line,'\"','\"');
               if (plyDepthStr.compare("??") == 0) {
                  plyDepth = -1;
               } else {
                  plyDepth = atoi(plyDepthStr.c_str());
               }
               minHighDepth = plyDepth;
               maxHighDepth = plyDepth;
            }
            else if (line.find("[EGT ") != string::npos) {
               egt = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[Mode ") != string::npos) {
               modestr = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[Event ") != string::npos) {
               eventName = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[Site ") != string::npos) { 
               site = IRutil::getBetweenDelm(line,'\"','\"'); 
            }
            else if (line.find("[Date ") != string::npos) { 
               date = IRutil::SimpleDate 
                  (IRutil::getBetweenDelm(line,'\"','\"'), 
                  IRutil::ARENA_FORMAT); 
            }
            else if (line.find("[Round ") != string::npos) { 
               string roundStr = IRutil::getBetweenDelm(line,'\"','\"'); 
               if (roundStr.compare("??") == 0) {
                  round = -1; 
               } else {
                  round = atoi(roundStr.c_str()); 
               }
            }
            else if (line.find("[White ") != string::npos) {
               whitePlayer = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[Black ") != string::npos) {
               blackPlayer = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[Result ") != string::npos) { 
               result = IRutil::getBetweenDelm(line,'\"','\"'); 
            } 
            else if (line.find("[ECO ") != string::npos) { 
               eco = IRutil::getBetweenDelm(line,'\"','\"'); 
            } 
            else if (line.find("[WhiteElo ") != string::npos) { 
               string whiteEloStr = IRutil::getBetweenDelm(line,'\"','\"'); 
               if (whiteEloStr.compare("??") == 0) {
                  whiteElo = -1; 
               } else {
                  whiteElo = atoi(whiteEloStr.c_str()); 
               }
            } 
            else if (line.find("[BlackElo ") != string::npos) { 
               string blackEloStr = IRutil::getBetweenDelm(line,'\"','\"'); 
               if (blackEloStr.compare("??") == 0) {
                  blackElo = -1; 
               } else {
                  blackElo = atoi(blackEloStr.c_str()); 
               }
            } 
            else if (line.find("[PlyCount ") != string::npos) { 
               plyCount = atoi((IRutil::getBetweenDelm(line,'\"','\"')).c_str()); 
            } 
            else if (line.find("[EventDate ") != string::npos) { 
               eventDate = IRutil::SimpleDate 
                  (IRutil::getBetweenDelm(line,'\"','\"'), 
                  IRutil::ARENA_FORMAT); 
            } 
            else if (line.find("[EventType ") != string::npos) {
               eventType = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[EventRounds ") != string::npos) {
               string er = IRutil::getBetweenDelm(line,'\"','\"');
               eventRounds = atoi(er.c_str());
            }
            else if (line.find("[EventCountry ") != string::npos) {
               eventCountry = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[EventCategory ") != string::npos) {
               eventCategory = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[Source ") != string::npos) {
               source = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[SourceDate ") != string::npos) { 
               sourceDate = IRutil::SimpleDate 
                  (IRutil::getBetweenDelm(line,'\"','\"'), 
                  IRutil::ARENA_FORMAT); 
            }
            else if (line.find("[TimeControl ") != string::npos) {
	       timeControl = IRutil::getBetweenDelm(line,'\"','\"');
	    }
            else if (line.find("[WhiteTeam ") != string::npos) {
               whiteTeam = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[BlackTeam ") != string::npos) {
               blackTeam = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[WhiteTeamCountry ") != string::npos) {
               whiteTeamCountry = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[BlackTeamCountry ") != string::npos) {
               blackTeamCountry = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[WhiteFideId ") != string::npos) {
               whiteFIDEID = IRutil::getBetweenDelm(line,'\"','\"');
            }
            else if (line.find("[BlackFideId ") != string::npos) {
               blackFIDEID = IRutil::getBetweenDelm(line,'\"','\"');
            } else { 
               //unknown header---choose to ignore rather than load anonymously  !!!
            } 
            getline(infile,line); 
            line = IRutil::trim(line);
            lineNumber++; 
            if (lineNumber % IRutil::LINESMODULUS == 0) {
               cerr << lineNumber << " lines read" << endl;
            }
         } 

         if (legacy && numPV == 0) {    //!!!
cerr << "Setting numPV = 50 for this game" << endl;
            numPV = 50;
         }

         pGameInfo = new GameInfo(gameID,engineID,platform,numThreads,hash,numPV,
            minHighDepth,maxHighDepth,egt,modestr,eventName,site,date,round,
            whitePlayer,blackPlayer,result,eco,whiteElo,blackElo,plyCount,
            eventDate,eventType,eventRounds,eventCountry,eventCategory,
            source,sourceDate,timeControl,whiteTeam,blackTeam,whiteTeamCountry,
            blackTeamCountry,whiteFIDEID,blackFIDEID);
         pGames->push_back(pGameInfo);
            
         continue; // We don't want to create a TurnInfo exactly now.  

      }    //end of interior loop over lines 
      else // We are processing the TurnInfo part of an AIF file
           // Since we control all of AIF, we dictate a strict line order for
           // greater efficiency.
           //
/*
[GID "AUT-chT 1314;Austria;2014.01.30;4.6;Baramidze, David;Kuljasevic, Davorin;1-0"]
[EID "Komodo 9.3 64-bit "]
[Turn "9-w"]
[MovePlayed "h3"]
[EngineMove "e5"]
[Eval "-009"]
[PrevEval "n.a."]
[NextEval "-015"]
[Depth "17"]
[NodeCount "7964964"]
[FEN "rn1q1rk1/pb2ppbp/1p1p1np1/2p5/2P1P3/2NP1NP1/PP3PBP/R1BQ1RK1 w - - 0 9"]
[FiftyMR "1"]
[RepCount "0"]
[RepLine1 ""]
[RepLine2 ""]
[NumLegalMoves "36"]
[LegalMoves ".."

[GameID "Anand;Gelfand;2007.09.13;World;1"]
[MoveNo "9-b"]
[MovePlayed "O-O"]
[MovePlayedSAN "0-0"]
[EngineMove "Ne5xf3"]
[EngineMoveSAN "Nxf3"]
[FEN  "r1bqk2r/ppp1bppp/3p4/4n3/8/2P1BN2/PPPQ1PPP/2KR1B1R b kq - 6 9"]
[RepCount "0"]
[Eval " +009"]
[PrevEval " +019"]
[NextEval " +019"]
[LegalMoves "..."]
[LegalMovesSAN "..."]
[NumLegalMoves "36"]
[FiftyMR "6"]
[RepLine1 ""]
[RepLine2 ""]

*/
      { 
//cerr << "Mv";
         while (line.find("[GID ") == string::npos
                      && line.find("[GameID ") == string::npos) { //legacy
            if (getline(infile,line)) {
               lineNumber++;
               if (lineNumber % IRutil::LINESMODULUS == 0) {
                  cerr << lineNumber << " lines read" << endl;
               }
            } else {
               break;
            }
         }
         bool bgID = (line.find("[GID ") != string::npos
                      || line.find("[GameID ") != string::npos); //legacy
         if (!bgID) { break; }  //kludge for end-of-file
         string gID = (bgID ? IRutil::getBetweenDelm(line,'\"','\"') : "??"); 
         getline(infile,line); 
         lineNumber++; 
         bool beID = (line.find("[EID ") != string::npos);
         bool legacy = !beID; //legacy has no EID for individual moves
         string eID = (beID ? IRutil::getBetweenDelm(line,'\"','\"') : "??");
         if (beID) { getline(infile,line); lineNumber++; }
         string turnNumberStr = "";
         int turnNumber = 1;
         string whoMoves = "";
         bool whiteMove = false;
         bool bmn = (line.find("[Turn ") != string::npos 
                        || line.find("[MoveNo ") != string::npos);
         if (bmn) {
            turnNumberStr = IRutil::getBetweenDelm(line,'\"','-'); 
            turnNumber = atoi(turnNumberStr.c_str());
            string whoMoves = IRutil::getBetweenDelm(line,'-','\"');
            whiteMove = (whoMoves[0] == 'w');
            getline(infile,line); 
            lineNumber++; 
         }
         //Legacy AIF has LAN first then SAN; use latter to overwrite.
         bool bmp = (line.find("[MovePlayed ") != string::npos);
         string movePlayed = (bmp ? IRutil::trim(IRutil::getBetweenDelm(line,'\"','\"')) : "??"); 
         if (bmp) { getline(infile,line); lineNumber++; }
         bmp = (line.find("[MovePlayedSAN ") != string::npos);
	 if (bmp) {
	    movePlayed = IRutil::trim(IRutil::getBetweenDelm(line,'\"','\"'));
            getline(infile,line);
            lineNumber++;
         }
         if (movePlayed == "0-0") { movePlayed == "O-O"; }
         if (movePlayed == "0-0-0") { movePlayed == "O-O-O"; }
         bool bem = (line.find("[EngineMove ") != string::npos);
         string engineMove = (bem ? IRutil::trim(IRutil::getBetweenDelm(line,'\"','\"')) : "??"); 
         if (bem) { getline(infile,line); lineNumber++; }
         bem = (line.find("[EngineMoveSAN ") != string::npos);
         if (bem) {
            engineMove = IRutil::trim(IRutil::getBetweenDelm(line,'\"','\"'));
            getline(infile,line);
            lineNumber++;
         }
         if (engineMove == "0-0") { engineMove == "O-O"; }
         if (engineMove == "0-0-0") { engineMove == "O-O-O"; }
         string movePlayedLAN = "";
         string engineMoveLAN = "";
         bmp = (line.find("[MovePlayedLAN ") != string::npos);
         if (bmp) {
            movePlayedLAN = IRutil::trim(IRutil::getBetweenDelm(line,'\"','\"'));
            getline(infile,line);
            lineNumber++;
         }
         bmp = (line.find("[EngineMoveLAN ") != string::npos);
         if (bmp) {
            engineMoveLAN = IRutil::trim(IRutil::getBetweenDelm(line,'\"','\"'));
            getline(infile,line);
            lineNumber++;
         }

         bool bfen = (line.find("[FEN ") != string::npos);
         string fenCurrPos = (bfen ? IRutil::getBetweenDelm(line,'\"','\"') : "??");
         if (bfen) { getline(infile,line); lineNumber++; }
         bool brc = (line.find("[RepCount ") != string::npos);
         string repCountString = "";
         int repCount = 0;
         if (brc) {
            repCountString = IRutil::getBetweenDelm(line,'\"','\"');
            repCount = atoi(repCountString.c_str());
            getline(infile,line);
            lineNumber++;
         } //now files synch'ed again on eval part
         bool beval = (line.find("[Eval ") != string::npos);
         string evalStr = "";
         int eval = 0.0;
	 string prevEvalStr = "";
	 int prevEval = 0.0;
         string nextEvalStr = "";
         int nextEval = 0.0;
         if (beval) {
            evalStr = IRutil::getBetweenDelm(line,'\"','\"');
            eval = atoi(evalStr.c_str());
            getline(infile,line);
            lineNumber++;
         }
         bool bpeval = (line.find("[PrevEval ") != string::npos);
         if (bpeval) {
            prevEvalStr = IRutil::getBetweenDelm(line,'\"','\"');
            prevEval = (prevEvalStr != "n.a.") ? atoi(prevEvalStr.c_str()) : IRutil::NAVAL;
            getline(infile,line);
            lineNumber++;
         }
         bool bneval = (line.find("[NextEval ") != string::npos);
         if (bneval) {
            nextEvalStr = IRutil::getBetweenDelm(line,'\"','\"');
            nextEval = (nextEvalStr != "n.a.") ? atoi(nextEvalStr.c_str()) : IRutil::NAVAL;
            getline(infile,line);
            lineNumber++;
         } //now legacy AIF has no Depth field
         bool bdepth = (line.find("[Depth ") != string::npos);
         int depth;
         if (bdepth) {
            string depthStr = IRutil::getBetweenDelm(line,'\"','\"');
            depth = atoi(depthStr.c_str());
            getline(infile,line);
            lineNumber++;
         } else {
            depth = minHighDepth;  //defined from GameID section and uniform
         }
         bool bnc = (line.find("[NodeCount ") != string::npos);
         int nodeCount = 0;
         if (bnc) {
            string nodeCountStr = IRutil::getBetweenDelm(line,'\"','\"');
            nodeCount = atoi(evalStr.c_str());
            getline(infile,line);
            lineNumber++;
         } //FEN line might come after this too
         bfen = (line.find("[FEN ") != string::npos);
         if (bfen) {
            fenCurrPos = IRutil::getBetweenDelm(line,'\"','\"'); 
            getline(infile,line); 
            lineNumber++; 
         }
         if (fenCurrPos == "??") { cerr << "FEN not found!" << endl; }
         //Remaining fields treated as pretty random
         int fiftyMR,numLegalMoves;
         string repLine1,repLine2;
         string legalMoves; //want in SAN hence may assign twice
         while(line.find(IRutil::DASHES) == string::npos) {
            if (line.find("[RepCount ") != string::npos) {
               repCountString = IRutil::getBetweenDelm(line,'\"','\"');
               repCount = atoi(repCountString.c_str());
            } else if (line.find("[FiftyMR ") != string::npos) {
               string fiftyMRStr = IRutil::getBetweenDelm(line,'\"','\"');
               fiftyMR = atoi(fiftyMRStr.c_str());
            } else if (line.find("[RepLine1 ") != string::npos) {
               repLine1 = IRutil::getBetweenDelm(line,'\"','\"');
            } else if (line.find("[RepLine2 ") != string::npos) {
               repLine2 = IRutil::getBetweenDelm(line,'\"','\"');
            } else if (line.find("[NumLegalMoves ") != string::npos) {
               string nlmstr = IRutil::getBetweenDelm(line,'\"','\"');
               numLegalMoves = atoi(nlmstr.c_str());
            } else if (line.find("[LegalMoves ") != string::npos) {
               legalMoves = IRutil::getBetweenDelm(line,'\"','\"'); 
            } else if (line.find("[LegalMovesSAN ") != string::npos) {
               legalMoves = IRutil::getBetweenDelm(line,'\"','\"');
            }
            getline(infile,line); 
            lineNumber++; 
            if (lineNumber % IRutil::LINESMODULUS == 0) {
               cerr << lineNumber << " lines read" << endl;
            }

         }
//cerr << "a";

         getline(infile,line);// This line should contain the depth information 
         lineNumber++; 

         size_t lowDepth = 30;  //to be minimized, value not material
         size_t highDepth = 0;
         //char* pch;
         int mlo,mhi;   //lowest and highest depth for the move

         line = IRutil::trim(line);
         istringstream depthsLine(line);
         string item;
         if (depthsLine >> item) {
            mlo = atoi(item.c_str());
            mhi = mlo;
         } else {
            cerr << "Line with no depths encountered." << endl;
         }
         //char* testing = (char*)line.c_str(); 
         //pch = strtok(testing," "); 
         //if (pch != NULL) { 
            //lo = atoi(pch); 
            //pch = strtok(NULL," ");    //uses previous saved pointer
            //hi = lo;// For handling issues of only single depth. 
         //} 
         while (depthsLine >> item) {
            mhi = atoi(item.c_str());
            //hi = atoi(pch); 
            //pch = strtok(NULL," "); 
         } 
 
         getline(infile,line);// second line containing -------------- 
         lineNumber++; 
         if (lineNumber % IRutil::LINESMODULUS == 0) {
            cerr << lineNumber << " lines read" << endl;
         }

         vector<int> maxEvalPerDepth;  //must min for Black moves.
 
         int playedMoveIndex = -1; 
         vector<Move>* consideredMovesVec = new vector<Move>();

         vector<vector<int> >* depthEvalsCP = new vector<vector<int> >();

         string movestr = "";
         Position pos(fenCurrPos);
         Move mov;
         Move mpl;
         string smv;
         while (repLine1.find(',') != string::npos) {
            repLine1.replace(repLine1.find(','), 1, " ");
         }
         istringstream iss(repLine1);
         vector<Move>* repMoves = new vector<Move>();
         while (iss >> smv) {
            if (smv == "1." || smv == "2." || smv == "3." || smv == "4.") { 
               continue; //legacy
            }
            repMoves->push_back(Move(pos.move2TAN(smv)));
         }
//cerr << "b";
         while(1)   //loop broken by break for double-dashes?
         { 
            vector<int> evalsCP;
            string evalstr = "";
            getline(infile,line); 
            line = IRutil::trim(line);
            lineNumber++; 
            if (lineNumber % IRutil::LINESMODULUS == 0) { 
               cerr << lineNumber << " lines read" << endl; 
            }
            if (line.empty() || line.find("========") != string::npos) 
               break; 
 
            istringstream ess(line);
            string mv;
//cerr << ".";
            if (ess >> mv) {
               
               mov.setTAN(pos.move2TAN(mv));
               mpl.setTAN(pos.move2TAN(movePlayed));
               if (mov == mpl) {   //so Re1 matches Re1+
                  playedMoveIndex = consideredMovesVec->size(); //current not final size
               }
               consideredMovesVec->push_back(mov);
               movestr += mv + ":";
            } //remaining entries are evals
            
            int currDepth = 0; 
            int naActive = -1; // we got na, looking for next meaningful value 
            string eitem = "";
            string pt = "";
            int b;
            int multiplier = 1;    // X = 10, C = 100, x = -10, c = -100
            while (ess >> eitem && (!(IRutil::trim(eitem).empty()))) {
               if (eitem == "n.a.") {
                  b = IRutil::NAVAL;// "n.a." identifier 
               } else if (eitem == "PRUN") {                
                  b = IRutil::PRUNVAL; //" PRUN " identifier 
               } else if (eitem == "NREC") { 
                  b = IRutil::NRECVAL; //" NREC " identifier 
               } else { //real value but may still have leading M,-M or trailing XxCc
                  lowDepth = min(currDepth,int(lowDepth));
                  highDepth = max(currDepth, int(highDepth));
                  if (eitem[3] == 'X') {
                     multiplier = 10;
                     pt = eitem.substr(0,3);  //3 means 3 chars not position 3
                     b = atoi(pt.c_str());
                  } else if (eitem[3] == 'x') {
                     multiplier = -10;
                     pt = eitem.substr(0,3);  
                     b = atoi(pt.c_str());
                  } else if (eitem[3] == 'C') {
                     multiplier = 100;
                     pt = eitem.substr(0,3); 
                     b = atoi(pt.c_str());
                  } else if (eitem[3] == 'c') {
                     multiplier = -100;
                     pt = eitem.substr(0,3);
                     b = atoi(pt.c_str());
                  } else if (eitem[3] == 'M') {
                     multiplier = 1000;
                     pt = eitem.substr(0,3);
                     b = 99;   //will give sub-mate val of 99,000
                  } else if (eitem[3] == 'm') {
                     multiplier = -1000;
                     pt = eitem.substr(0,3);
                     b = 99;
                  } else if (eitem.substr(0,2) == "+M") {  
                     pt = eitem.substr(2);    //might be longer than 2 more chars
                     b = IRutil::MATEVALCP - atoi(pt.c_str());
                  } else if (eitem.substr(0,2) == "-M") {
                     pt = eitem.substr(2);
                     b = atoi(pt.c_str()) - IRutil::MATEVALCP;
                  } else {   //simple value!
                     b = atoi(eitem.c_str());
                  }
                  b *= multiplier;
               }  
               evalsCP.push_back(b); 
               multiplier = 1; 
               currDepth++; 
            } 
 
            //Update maxEvalPerDepth Now  
            depthEvalsCP->push_back(evalsCP); 
         } 
         if (playedMoveIndex == -1) { 
             //cerr << "played Move Index not found " << endl; 
             //cerr << "Current Line Number: " << lineNumber<<endl; 
             //cerr << "FEN: " << fenCurrPos << endl;
             //cerr << "Move played: " << movePlayed << " in " << movestr << endl;
             //exit(1); 
         } 

         getline(infile,line);  //should be blank line in old & new format
         lineNumber++;
 
         //At this point, we have information for a particular move. 
         // We will push that to turns vector.   !!!

         lowDepth += AIFoffset;
         highDepth += AIFoffset;
 
/*
   TurnInfo(const GameInfo* pGmInfo, const int lo, const int hi,
            const string& gid, const string& eid, const int tNumber, const bool wtm,
            const string& plydMove, const string& engMove,
            const int curEval, const int preEval, const int nexEval,
            const int d, const int nc,  const string& fenCurrPos, const int fmr,
            const int repCount, const string& rl1, const string& rl2,
            const size_t numLegalMov, const string& legMoves,
            vector<vector<int> >* devals,
            const int playedMoveInd, bool extraRepeatFlag = false)
*/
			 
         TurnInfo* pSingleTurn = new TurnInfo( 
            pGameInfo, mlo, mhi, gID, eID, turnNumber, whiteMove,
            movePlayed, engineMove, 
            eval, prevEval, nextEval, depth, nodeCount, fenCurrPos, fiftyMR,
            repCount, repMoves, repLine2, numLegalMoves, legalMoves, 
            consideredMovesVec, depthEvalsCP, playedMoveIndex, false);
            
         if (referenceOnly) {   //no need to link up turns
            pReferenceTurns->push_back(pSingleTurn);
         } else {
            if (prevEval == IRutil::NAVAL) {   //first turn in game
                pGameInfo->gameTurns->push_back(pSingleTurn);
                fillTurns->push_back(pSingleTurn);
            } else {  //lastTurn must be assigned from same game
               if (lastTurn != NULL) {
                  lastTurn->nextTurn = pSingleTurn;
                  pSingleTurn->prevTurn = lastTurn;
                  fillTurns->push_back(pSingleTurn); 
               } else {
                  cerr << "Saved a segfault on turn " << string(*pSingleTurn) << endl;
               }
            }
         } 
         lastTurn = pSingleTurn;

         //depthEvalsCP->clear(); 

         //Now mark repetitions.  Definition is all moves from the first
         //occurrence of a position, up to---but not including---its last
         //occurrence, are marked as repetitions (if not already marked).
         //Last occurrence is marked only if it is last move of game.
         //This implies that only the first move that breaks a repeating
         //sequence is unmarked.

         if (legacy && repCount > 0) {
            list<TurnInfo*>* ptr = referenceOnly ? pReferenceTurns : fillTurns;
            string fenpos = fenCurrPos.substr(0,fenCurrPos.find(" -"));
            string fenpos2;
            list<TurnInfo*>::iterator itr = --(ptr->end());
            if (nextEvalStr == " n.a.") { 
               (*itr)->setRep(true); //only automatic on last move of game
            }
            while (itr != ptr->begin()) {
               const GameInfo* gi = (*(--itr))->pGameInfo;
		  fenpos2 = (*itr)->fenCurrentPos.substr(0, (*itr)->fenCurrentPos.find(" -"));
               if (gi != pGameInfo || fenpos == fenpos2) {
                  break;
               } else {
                  (*itr)->setRep(true);
               }
            }
            fenpos2 = (*itr)->fenCurrentPos.substr(0, (*itr)->fenCurrentPos.find(" -"));
            if (fenpos == fenpos2) {
               (*itr)->setRep(true);
            } else {
               cerr << "Repetition bound not found for " << endl
                    << string(*pSingleTurn) << endl << endl
                    << string(**itr) << endl;
            }
         }
      }
   }
cerr << "Done reading " << lineNumber << " lines." << endl;
   return fillTurns;
}

 
 
/** Used to check that the input is read correctly. 
 */ 
void Ensemble::printDeltas(const string& name) const { 
   focusTrial->dumpDeltas(name);
} 
 
void Ensemble::printTurns(const string& name) const { 
   ofstream* file = new ofstream(name.c_str(), ios::app); 
   if(!file->is_open()) { 
      cerr << "Cannot stat the output file, returning..." << endl; 
      return; 
   } //else 
   for(list<TurnInfo*>::const_iterator tu = pTurns->begin(); 
      tu != pTurns->end(); tu++) { 
 
      (*file) << string(**tu) << endl << endl; 
   } 
} 
 
 
void Ensemble::newTrial() { 
   string trialName; 
   string ans; 
   double doubleAns; 
   int intAns; 
   bool scaleDeltas; 
   Models::MODEL model = Models::MODEL(modelsMenu->readChoice()); 
   cout << "Enter spec (curve, weighting, initial point) for trial---\n"; 
   TrialSpec ts = makeTrialSpec(); 
   specs->clearStars(); 
   specs->addItem(ts,"",false,true); 
   cout << "Impose distortion fix? (y/n) "; 
   loggedRead(ans,false); 
   ans = IRutil::trim(ans); 
   bool fixDistortion = IRutil::isYes(ans); 
 
   cout << "Adjust delta scale? (y/n): "; 
   loggedRead(ans,false); 
   scaleDeltas = IRutil::isYes(IRutil::trim(ans)); 
   DeltaScale* ds; 
   scales->clearStars(); 
   SwingInfo* swi = new SwingInfo(map<APPLICATION_POLICIES,double>(), true, false, true,
                                  false, false, 0, false, false, 0.0);
   if (scaleDeltas) { 
      //ds = makeDeltaScale(doubleAns);  //must pass in cap if trial not made 
      ds = makeDeltaScale();
      ds->setDeltaCap(doubleAns);
   } else { 
      ds = new UnitScale(false, swi, NO_PATCH, IRutil::CENTRALPATCHPOWER, 0.00,
                         map<string,double>(), 1, 30, 30, 6, 20, 0, doubleAns);  
   } 
   scales->addItem(ds,"",false,true); 
 
   cout << "Enter name for trial: "; 
   loggedRead(trialName,true);   //end line defining trial 
   trialName = IRutil::trim(trialName); 
   focusTrial = new Trial(trialName,pTurns,ts, //percs,
                          model,fixDistortion,scaleDeltas,ds); 
   //focusTrial->addFilteredTuples(); 
   filters->clearStars(); 
   trials->clearStars(); 
   trials->addItem(focusTrial,"",false,true);  //adds when name is new, *s it 
   if (pTurns->size() == 0) { 
      readTurns(*INP);  //difference from addTurns() is latter filters too. 
   } 
} 
 
void Ensemble::changeTrial() {
   Models::MODEL model = Models::MODEL(modelsMenu->readChoice());
   focusTrial->setModel(model);
   referenceTrial->setModel(model);
   string ans = (focusTrial->getFixPolicy() ? "y" : "n");
   cout << "Impose distortion fix? (y/n) (currently " + ans + ") ";
   loggedRead(ans,false);
   ans = IRutil::trim(ans);
   bool fixDistortion = IRutil::isYes(ans);
   focusTrial->setFixPolicy(fixDistortion);
   referenceTrial->setFixPolicy(fixDistortion);
   ans = (focusTrial->getMoveNNPolicy() ? "y" : "n");
   cout << "Treat miss as Move NN? (y/n) (currently " + ans + ") ";
   loggedRead(ans,false);
   ans = IRutil::trim(ans);
   bool moveNNPolicy = IRutil::isYes(ans);
   focusTrial->setMoveNNPolicy(moveNNPolicy);
   referenceTrial->setMoveNNPolicy(moveNNPolicy);
}

void Ensemble::loadNamedTrial() { 
   if (trials->empty()) { 
      cout << "No trials to choose from, sorry." << endl; 
      return; 
   } //else 
   int i = trials->readChoice(); 
   if (trials->success(i)) { 
      string name = trials->nameOf(i); 
      focusTrial = (*trials)[name]; 
      trials->clearStars(); 
      trials->setStarred(name,true); 
   } else { 
      while (i == EnumMenu::INVALID_CHOICE) { 
         cout << "Invalid choice---please try again: " << endl; 
         i = trials->readChoice(false);  //so menu doesn't display again 
      } 
   } 
   //in cancel/more-options/abort cases, do nothing... 
} 
 
void Ensemble::loadDeltaScale(bool refToo) { 
   int choice = scales->readChoice(); 
   DeltaScale* ds; 
   if (scales->success(choice)) { 
      string name = scales->nameOf(choice); 
      ds = (*scales)[name]; 
      focusTrial->setScale(ds); 
      if (refToo) { 
         cout << "Changing reference trial scale too...";
         referenceTrial->setScale(ds); 
      }
      scales->clearStars(); 
      scales->setStarred(name,true); 
   } else if (choice == EnumMenu::MORE_CHOICE) { 
      //ds = makeDeltaScale(focusTrial->getDeltaCap()); 
      ds = makeDeltaScale();
      focusTrial->setScale(ds); 
      if (refToo) {
         cout << "Changing reference trial to new scale too...";
         referenceTrial->setScale(ds);
      }
      scales->clearStars(); 
      scales->addItem(ds,"",false,true); 
   } else { 
      //do nothing 
   } 
   //reset();   //unnecessary?
} 
 
 
void Ensemble::loadNamedTrialSpec() { 
   int choice; 
   if (specs->empty()) { 
      cout << "No active trial specs to choose from, showing inactive ones..." 
           << endl; 
      choice = EnumMenu::MORE_CHOICE; 
   } else { 
      choice = specs->readChoice(); 
   } 
   if (specs->success(choice)) { 
      string name = specs->nameOf(choice); 
      TrialSpec ts = (*specs)[name]; 
      focusTrial->setSpec(ts); 
      referenceTrial->setSpec(ts);
      resetParamsMenu();
      specs->clearStars(); 
      specs->setStarred(name,true); 
   } else if (choice == EnumMenu::MORE_CHOICE && !hiddenSpecs->empty()) { 
      choice = hiddenSpecs->readChoice(); 
      if (hiddenSpecs->success(choice)) { 
         string name = hiddenSpecs->nameOf(choice); 
         TrialSpec ts = (*hiddenSpecs)[name]; 
         focusTrial->setSpec(ts); 
         referenceTrial->setSpec(ts);
         resetParamsMenu();
         specs->clearStars(); 
         specs->addItem(ts,"",false,true);       //makes it active and stars it 
         hiddenSpecs->removeItem(name); 
      } else { 
         cout << "Invalid choice, canceling." << endl; 
         //do nothing. 
      } 
   } else if (hiddenSpecs->empty()) { 
      cout << "No inactive specs to choose from, returning..." << endl; 
   } else { 
      //do nothing 
   } 
} 
 
 
void Ensemble::hideSpecs() { 
   string ans = "yes"; 
   bool cancel = false; 
   int choice; 
   while (IRutil::isYes(ans) && specs->size() > 1) { 
      choice = specs->readChoice(); 
      if (specs->success(choice)) { 
         if (specs->isStarred(choice)) {     // (specs->nameOf(choice))) { 
            cout << "Can't inactivate the current spec, sorry." << endl; 
         } else { 
            string name = specs->nameOf(choice); 
            hiddenSpecs->addItem((*specs)[name], "", false, false); 
            specs->removeItem(name); 
         } 
      } else { 
         cout << "Invalid choice, returning..."; 
         cancel = true; 
      } 
      if (usingCin() && !cancel) { cout << "Inactivate another? "; } 
      loggedRead(ans); 
   } 
   if ((cancel || specs->size() == 1) && usingCin()) { 
      cout << "Had to leave the loaded spec active." << endl; 
   } 
} 
 
/*
   Minimizer(Trial* trial, METHOD gmethod, map<MINIMAND,double> gmini,
             size_t ifs, size_t ife, SKED ifsked, size_t ids, size_t ide, SKED idsked,
             double e1lo, double e1hi, double e2lo, double e2hi,
             double mu, double mud, bool upv,
             const TrialSpec loSpec, const TrialSpec hSpec, const TrialSpec pivSpec,
             unsigned int max_iter, size_t num_retries,
             double precx, double precy, double precg,
             bool wout = false, double woutstep = 0.02,
             double bn = 0, bool ksib = false, bool vb = false,
             vector<ostream*>* gouts = new vector<ostream*>())

   enum METHOD {
      VWALK, GSL_NM4, GSL_NM6, GSL_NM7, GSL_SIM_ANN, CMINPACK_LMDIF, CMINPACK_HYBRD, NUM_METHODS
   };
   enum SKED {
      UNIT_SKED, SQRT_SKED, LIN_SKED, QUAD_SKED, INVVAR_SKED,
      SQRT_ALLWT, LIN_ALLWT, QUAD_ALLWT, NUM_SKEDS
   };
   enum MINIMAND {
      PERCFIT, ML,  //PERCFITOLD, PERCFITOLDL1,
         FALLOFF, FIRST_LINE, ETV, SECOND_LINE, THIRD_LINE, FOURTH_LINE, FIFTH_LINE,
         INDEXFIT, INDEXDIFF, ERROR1, ERROR2,
         //INDEXFITMASS, INDEXDIFFMASS, INDEXFITINVVAR, INDEXFITPROP,
         FIRSTL1A, ETVL1A, BINS, NUM_MINIMANDS
   };
*/

Minimizer::SKED Ensemble::parseSked(string x) const {
   for (int i = Minimizer::UNIT_SKED; i < Minimizer::NUM_SKEDS; i++) {
      if (x.find(skedMenu->nameOf(Minimizer::SKED(i))) != string::npos) {
         return Minimizer::SKED(i);
      }
   }
   return Minimizer::UNIT_SKED;
}
 
Minimizer* Ensemble::makeMinimizer() const { 
   IRutil::nullstream nullstrm; 
   ostream& ccout = (usingCin()) ? cout : nullstrm; 
   string ans; 
   int choice = 0; 
   int choice2 = 0;
   Minimizer::METHOD method = Minimizer::METHOD(methodMenu->indexOf(fitMenu->getStatus(MIN_METHOD)));
   size_t equalTopIndexLimit = IRutil::extractDoubles(fitMenu->getStatus(Minimizer::ETV))[0];
   Minimizer::SKED ifsked = parseSked(fitMenu->getStatus(Minimizer::INDEX_FIT));
   Minimizer::SKED idsked = parseSked(fitMenu->getStatus(Minimizer::INDEX_DIFF));
   Minimizer::SKED e1sked = parseSked(fitMenu->getStatus(Minimizer::ERROR1));
   Minimizer::SKED e2sked = parseSked(fitMenu->getStatus(Minimizer::ERROR2));
                                           //Minimizer::GSL_MULTIMIN;
   //Minimizer::MINIMAND mini;
   map<Minimizer::MINIMAND, double> minimap; //constructed here
   Minimizer* mm; 
   double loS, hiS, loC, hiC, loD, hiD, loV, hiV, loA, hiA, loHM, hiHM, loHP, hiHP, loB, hiB;
   size_t ifs, ife, ids, ide;
   double e1lo, e1hi, e2lo, e2hi;
   IRfun::CURVES slideCurve;
   double slideLo, slideMid, slideHi, slidePower, slideProp;
   double mumul, mudiv, precx, precy, precg, step, epsfcn;
   bool slides, gm, wo, si, vb, ul, upv, ksib;
   bool entering = true;
   bool innerEntering;
   size_t bootNum = 0;
   //size_t fjd;   //0 means turn maximum depth used for judgment
   size_t maxIter = 2000;
   size_t numRetries = 50;
   int intItem, intItem2, intItem3;
   double floatItem, floatItem2, floatItem3;
   TrialSpec ts = focusTrial->getSpec();
   fitMenu->resetDefaults(); 
   string tss = string(ts);
   TrialSpec loSpec, hiSpec, pivSpec;
   map<IRfun::CURVES, double> cb;

   string strparams = ts.getDescription();
   fitMenu->setStatus(START_SPEC, ts.getName() + ": " + strparams);
   
   while (entering) { 
      choice = fitMenu->readChoice(); 
      switch(choice) { 
       case Minimizer::PERCFIT: 
       //case Minimizer::PERCFITOLD: 
       //case Minimizer::PERCFITOLDL1: 
       case Minimizer::ML: 
       case Minimizer::BINS:
/*
       case Minimizer::INDEXFITMASS: 
       case Minimizer::INDEXDIFFMASS:
       case Minimizer::INDEXFITINVVAR: 
       case Minimizer::INDEXFITPROP: 
*/
       case Minimizer::FALLOFF:
       case Minimizer::FIRST_LINE:
       case Minimizer::SECOND_LINE:
       case Minimizer::THIRD_LINE:
       //case Minimizer::FOURTH_LINE:
       //case Minimizer::FIFTH_LINE:

       //case Minimizer::FIRSTL1A: 
       //case Minimizer::ETVL1A: 
         //fitMenu->clearStars(); 
         ccout << "Enter float weight, 0 to exclude: ";
         loggedRead(floatItem);
         fitMenu->setStatus(choice, IRutil::ftoa(floatItem));
         if (floatItem != 0) {   //OK comparison
            //minimap[choice] = floatItem;
            fitMenu->setStarred(choice,true);
         } else {
            fitMenu->setStarred(choice,false);
         }
         break; 
   
       case Minimizer::ETV:
         ccout << "Enter 0-based inclusive index limit: ";
         loggedReadBounded(intItem, 0, IRutil::NCUTOFF,false);
         ccout << "Enter float weight, 0 to exclude: ";
         loggedRead(floatItem);
         fitMenu->setStatus(choice, IRutil::itoa(intItem) + ": " + IRutil::ftoa(floatItem));
         if (floatItem != 0) {   //OK comparison
            //minimap[choice] = floatItem;
            fitMenu->setStarred(choice,true);
         } else {
            fitMenu->setStarred(choice,false);
         }
         break;

       case Minimizer::INDEX_FIT:
         ccout << "Enter first index, 0-based: ";
         loggedReadBounded(intItem, 0, IRutil::NCUTOFF,false);
         ccout << "Enter end index, 0-based: ";
         loggedReadBounded(intItem2, intItem,IRutil::NCUTOFF,false);
         innerEntering = true;
         while (innerEntering) {
            choice2 = skedMenu->readChoice();
            if (0 <= choice2 && choice2 < Minimizer::NUM_SKEDS) {
               innerEntering = false;
            } else {
               ccout << "Invalid choice; please try again: " << endl;
            }
         }
         ccout << "Enter float weight, 0 to exclude: ";
         loggedRead(floatItem);
         ifsked = Minimizer::SKED(choice2);
         fitMenu->setStatus(choice, "[" + IRutil::itoa(intItem) + ", " + IRutil::itoa(intItem2)
                               + "] " + skedMenu->nameOf(choice2) + ": " + IRutil::ftoa(floatItem));
         if (floatItem != 0) {   //OK comparison
            //minimap[choice] = floatItem;
            fitMenu->setStarred(choice,true);
         } else {
            fitMenu->setStarred(choice,false);
         }
         break;
       case Minimizer::INDEX_DIFF:
         ccout << "Enter first index, 0-based: ";
         loggedReadBounded(intItem, 0, IRutil::NCUTOFF,false);
         ccout << "Enter end index, 0-based: ";
         loggedReadBounded(intItem2, intItem,IRutil::NCUTOFF,false);
         innerEntering = true;
         while (innerEntering) {
            choice2 = skedMenu->readChoice();
            if (0 <= choice2 && choice2 < Minimizer::NUM_SKEDS) {
               innerEntering = false;
            } else {
               ccout << "Invalid choice; please try again: " << endl;
            }
         }
         ccout << "Enter float weight, 0 to exclude: ";
         loggedRead(floatItem);
         fitMenu->setStatus(choice, "[" + IRutil::itoa(intItem) + ", " + IRutil::itoa(intItem2)
                               + "] " + skedMenu->nameOf(choice2) + ": " + IRutil::ftoa(floatItem));
         if (floatItem != 0) {   //OK comparison
            //minimap[choice] = floatItem;
            fitMenu->setStarred(choice,true);
         } else {
            fitMenu->setStarred(choice,false);
         }
         break;
       case Minimizer::ERROR1:
         ccout << "Enter min. value p.nn for error: ";
         loggedReadBounded(floatItem2, 0.00, 2*IRutil::MATEVAL, false);
         ccout << "Enter max. value for error, " << (2*IRutil::MATEVAL) << " for none: ";
         loggedReadBounded(floatItem3, floatItem2, 2*IRutil::MATEVAL, false);
         innerEntering = true;
         while (innerEntering) {
            choice2 = skedMenu->readChoice();
            if (0 <= choice2 && choice2 < Minimizer::NUM_SKEDS) {
               innerEntering = false;
            } else {
               ccout << "Invalid choice; please try again: " << endl;
            }
         }
         e1sked = Minimizer::SKED(choice2);
         ccout << "Enter float weight, 0 to exclude: ";
         loggedRead(floatItem);
         fitMenu->setStatus(choice, "[" + IRutil::ftoa(floatItem2) + ", " + IRutil::ftoa(floatItem3)
                               + "] " + skedMenu->nameOf(choice2) + ": " + IRutil::ftoa(floatItem));
         if (floatItem != 0) {   //OK comparison
            //minimap[choice] = floatItem;
            fitMenu->setStarred(choice,true);
         } else {
            fitMenu->setStarred(choice,false);
         }
         break;

       case Minimizer::ERROR2:
         ccout << "Enter min. value p.nn for error: ";
         loggedReadBounded(floatItem2, 0.00, 2*IRutil::MATEVAL, false);
         ccout << "Enter max. value for error, " << (2*IRutil::MATEVAL) << " for none: ";
         loggedReadBounded(floatItem3, floatItem2, 2*IRutil::MATEVAL, false);
         innerEntering = true;
         while (innerEntering) {
            choice2 = skedMenu->readChoice();
            if (0 <= choice2 && choice2 < Minimizer::NUM_SKEDS) {
               innerEntering = false;
            } else {
               ccout << "Invalid choice; please try again: " << endl;
            }
         }
         e2sked = Minimizer::SKED(choice2);   //only difference from previous block
         ccout << "Enter float weight, 0 to exclude: ";
         loggedRead(floatItem);
         fitMenu->setStatus(choice, "[" + IRutil::ftoa(floatItem2) + ", " + IRutil::ftoa(floatItem3)
                               + "] " + skedMenu->nameOf(choice2) + ": " + IRutil::ftoa(floatItem));
         if (floatItem != 0) {   //OK comparison
            //minimap[choice] = floatItem;
            fitMenu->setStarred(choice,true);
         } else {
            fitMenu->setStarred(choice,false);
         }
         break;
       case FUNNEL_FACTORS:
         ccout << "Enter positive starting \"mu\" multiplier or 0 to exclude: ";
         loggedRead(floatItem);
         fitMenu->setStatus(choice, IRutil::ftoa(floatItem));
         if (floatItem != 0) {   //OK comparison
            ccout << "Enter divisor for update: ";
            loggedRead(floatItem2);
            fitMenu->setStatus(choice, IRutil::ftoa(floatItem) + ", update dividing by " + IRutil::ftoa(floatItem2));
            fitMenu->setStarred(choice,true);
         } else {
            fitMenu->setStarred(choice,false);
         }
         break;

       case GO: 
         LOGP->flush();

         loS = IRutil::extractDoubles(fitMenu->getStatus(S_BOUNDS))[0]; 
         hiS = IRutil::extractDoubles(fitMenu->getStatus(S_BOUNDS))[1]; 
         loC = IRutil::extractDoubles(fitMenu->getStatus(C_BOUNDS))[0]; 
         hiC = IRutil::extractDoubles(fitMenu->getStatus(C_BOUNDS))[1]; 
         loD = IRutil::extractDoubles(fitMenu->getStatus(D_BOUNDS))[0];
         hiD = IRutil::extractDoubles(fitMenu->getStatus(D_BOUNDS))[1];
         loV = IRutil::extractDoubles(fitMenu->getStatus(V_BOUNDS))[0];
         hiV = IRutil::extractDoubles(fitMenu->getStatus(V_BOUNDS))[1];
         loA = IRutil::extractDoubles(fitMenu->getStatus(A_BOUNDS))[0];
         hiA = IRutil::extractDoubles(fitMenu->getStatus(A_BOUNDS))[1];
         loHM = IRutil::extractDoubles(fitMenu->getStatus(HM_BOUNDS))[0];
         hiHM = IRutil::extractDoubles(fitMenu->getStatus(HM_BOUNDS))[1];
         loHP = IRutil::extractDoubles(fitMenu->getStatus(HP_BOUNDS))[0];
         hiHP = IRutil::extractDoubles(fitMenu->getStatus(HP_BOUNDS))[1];
         loB = IRutil::extractDoubles(fitMenu->getStatus(B_BOUNDS))[0];
         hiB = IRutil::extractDoubles(fitMenu->getStatus(B_BOUNDS))[1];

         precx = atof(fitMenu->getStatus(PRECISION_X).c_str());

         if (hiS - loS <= precx && hiC - loC <= precx && hiD - loD <= precx && hiV - loV <= precx
             && hiA - loA <= precx && hiHM - loHM <= precx && hiHP - loHP <= precx && hiB - loB <= precx) {
            cerr << "Please unleash at least one of the variables." << endl;
            break;
         }

         //fjd = atoi((fitMenu->getStatus(FIT_JUDGMENT_DEPTH)).c_str());
         ifs = IRutil::extractDoubles((fitMenu->getStatus(Minimizer::INDEX_FIT)).c_str())[0];
         ife = IRutil::extractDoubles((fitMenu->getStatus(Minimizer::INDEX_FIT)).c_str())[1];
         //SKED choices maintained inductively
         ids = IRutil::extractDoubles((fitMenu->getStatus(Minimizer::INDEX_DIFF)).c_str())[0];
         ide = IRutil::extractDoubles((fitMenu->getStatus(Minimizer::INDEX_DIFF)).c_str())[1];

         e1lo = IRutil::extractDoubles((fitMenu->getStatus(Minimizer::ERROR1)).c_str())[0];
         e1hi = IRutil::extractDoubles((fitMenu->getStatus(Minimizer::ERROR1)).c_str())[1];
         e2lo = IRutil::extractDoubles((fitMenu->getStatus(Minimizer::ERROR2)).c_str())[0];
         e2hi = IRutil::extractDoubles((fitMenu->getStatus(Minimizer::ERROR2)).c_str())[1];

         mumul = IRutil::extractDoubles((fitMenu->getStatus(FUNNEL_FACTORS)).c_str())[0];
         mudiv = IRutil::extractDoubles((fitMenu->getStatus(FUNNEL_FACTORS)).c_str())[1];
         maxIter = atoi((fitMenu->getStatus(MAX_ITERATIONS)).c_str());
         numRetries = atoi((fitMenu->getStatus(NUM_RETRIES)).c_str());
         //prec = atof((fitMenu->getStatus(PRECISION)).c_str()); 
         //precx = atof(fitMenu->getStatus(PRECISION_X).c_str());
	 precy = atof(fitMenu->getStatus(PRECISION_Y).c_str());
	 precg = atof(fitMenu->getStatus(PRECISION_G).c_str());
         step = atof((fitMenu->getStatus(WALKOUT_STEP)).c_str()); 
         epsfcn = atof((fitMenu->getStatus(EPSFCN)).c_str());
         //gm = IRutil::isYes(fitMenu->getStatus(GEOMETRIC_MEANS)); 
         //wo = IRutil::isYes(fitMenu->getStatus(WALKOUT)); 
         //si = IRutil::isYes(fitMenu->getStatus(S_INNER)); 
         vb = IRutil::isYes(fitMenu->getStatus(VERBOSE)); 
         ul = IRutil::isYes(fitMenu->getStatus(MIN_METHOD));
         bootNum = atoi(fitMenu->getStatus(BOOT_NUM).c_str());
         ksib = IRutil::isYes(fitMenu->getStatus(KEEP_SPEC_IN_BOOT));

         cb = ts.curveBook;
         loSpec = TrialSpec(ts.curveChoice,cb,ts.weightMethodChoice,"loSpec",
                            loS,loC,loD,loV,loA,loHM,loHP,loB, ts.slides,
                            ts.slideCurveChoice, ts.slideLo, ts.slideMid,
                            ts.slideHi, ts.slidePower, ts.slideProp, ts.memoStep, 0.0); //don't memoize
         hiSpec = TrialSpec(ts.curveChoice,cb,ts.weightMethodChoice,"hiSpec",
                            hiS,hiC,hiD,hiV,hiA,hiHM,hiHP,hiB, ts.slides,
                            ts.slideCurveChoice, ts.slideLo, ts.slideMid,
                            ts.slideHi, ts.slidePower, ts.slideProp, ts.memoStep, 0.0);
         pivSpec = TrialSpec(ts.curveChoice,cb,ts.weightMethodChoice,ts.getName(),
                             ts.s,ts.c,ts.d,ts.v,ts.a,ts.hm,ts.hp,ts.b, ts.slides,
                             ts.slideCurveChoice, ts.slideLo, ts.slideMid,
                             ts.slideHi, ts.slidePower, ts.slideProp, ts.memoStep, ts.memoCap);
   

         for (size_t ch = Minimizer::PERCFIT; ch <= Minimizer::THIRD_LINE; ch++) {
            float mul = atof((fitMenu->getStatus(Minimizer::MINIMAND(ch))).c_str());
            if (mul != 0) {   //OK comparison
               minimap[Minimizer::MINIMAND(ch)] = mul;
            }
         }

         equalTopIndexLimit = IRutil::extractDoubles(fitMenu->getStatus(Minimizer::ETV))[0];
         floatItem = IRutil::extractDoubles(fitMenu->getStatus(Minimizer::ETV))[1];
         if (floatItem != 0) {   //OK comparison
            minimap[Minimizer::ETV] = floatItem;
         }
         for (size_t ch = Minimizer::INDEX_FIT; ch <= Minimizer::ERROR2; ch++) {
            float mul = IRutil::extractDoubles(fitMenu->getStatus(Minimizer::MINIMAND(ch)))[2];
            if (mul != 0) {   //OK comparison
               minimap[Minimizer::MINIMAND(ch)] = mul;
            }
         }

         if (minimap.size() == 0) {
            cout << "No test selected.  Please give at least one test a nonzero weight." << endl;
            break;
         }

       
         //choice = 1;
         //while (!(fitMenu->isStarred(choice))) { choice++; }
         //mini = Minimizer::MINIMAND(choice);   //!!! todo: makew this more robust
 
         //only place a Minimizer is created
         focusTrial->setSpec(ts);
         referenceTrial->setSpec(ts);
         //resetParamsMenu();
         mm = new Minimizer(focusTrial, method, minimap, equalTopIndexLimit,
                            ifs, ife, ifsked, ids, ide, idsked, 
                            e1lo, e1hi, e1sked, e2lo, e2hi, e2sked,
                            mumul, mudiv, loSpec, hiSpec, pivSpec,
                            maxIter, numRetries, precx, precy, precg,
                            step > 0.0, step, epsfcn, bootNum, ksib, vb, outs);
         entering = false;
         break; 

       case MIN_METHOD:
         choice2 = methodMenu->readChoice();
         fitMenu->setStatus(choice, methodMenu->nameOf(choice2));
         method = Minimizer::METHOD(choice2);
         break;
       //case GEOMETRIC_MEANS: 
       //case WALKOUT: 
       //case S_INNER: 
       case VERBOSE: 
         ccout << "Yes or No? (y/n) "; 
         loggedRead(ans); 
         ans = IRutil::trim(ans); 
         fitMenu->setStatus(choice, IRutil::isYes(ans) ? "yes" : "no"); 
         break; 
       case S_BOUNDS: 
         ccout<<"Enter lower and upper bounds for `s' on next line, or 1 0 to freeze spec point value:"<<endl; 
         loggedRead(loS,false); 
         loggedRead(hiS,false); 
         if (loS < hiS) {
            fitMenu->setStarred(choice,true);
         } else {
            if (loS > hiS) {
               loS = hiS = ts.s;
            } else {
               hiS = loS;
            }
            fitMenu->setStarred(choice,false);
         }
         fitMenu->setStatus(choice, IRutil::ftoa(loS) + " .. "
                                  + IRutil::ftoa(hiS));
         break; 
       case C_BOUNDS: 
         ccout << "Enter lower and upper bounds for `c' on next line, or 1 0 to freeze spec point value:" << endl; 
         loggedRead(loC,false); 
         loggedRead(hiC,false); 
         if (loC < hiC) {
            fitMenu->setStarred(choice,true);
         } else {
            if (loC > hiC) {
               loC = hiC = ts.c;
            } else {
               hiC = loC;
            }
            fitMenu->setStarred(choice,false);
         }
         fitMenu->setStatus(choice, IRutil::ftoa(loC) + " .. "
                                  + IRutil::ftoa(hiC));
         break; 
       case D_BOUNDS:
         ccout << "Enter lower and upper bounds for `d' on next line, or 1 0 to freeze spec point value:" << endl;
         loggedRead(loD,false);
         loggedRead(hiD,false);
         if (loD < hiD) {
            fitMenu->setStarred(choice,true);
         } else {
            if (loD > hiD) {
               loD = hiD = ts.d;
            } else {
               hiD = loD;
            }
            fitMenu->setStarred(choice,false);
         }
         fitMenu->setStatus(choice, IRutil::ftoa(loD) + " .. "
                                  + IRutil::ftoa(hiD));
         break;
       case V_BOUNDS:
         ccout << "Enter lower and upper bounds for `v' on next line, or 1 0 to freeze spec point value:" << endl;
         loggedRead(loV,false);
         loggedRead(hiV,false);
         if (loV < hiV) {
            fitMenu->setStarred(choice,true);
         } else {
            if (loV > hiV) {
               loV = hiV = ts.v;
            } else {
               hiV = loV;
            }
            fitMenu->setStarred(choice,false);
         }
         fitMenu->setStatus(choice, IRutil::ftoa(loV) + " .. "
                                  + IRutil::ftoa(hiV));
         break;
       case A_BOUNDS:
         ccout << "Enter lower and upper bounds for `a' on next line, or 1 0 to freeze spec point value:" << endl;
         loggedRead(loA,false);
         loggedRead(hiA,false);
         if (loA < hiA) {
            fitMenu->setStarred(choice,true);
         } else {
            if (loA > hiA) {
               loA = hiA = ts.a;
            } else {
               hiA = loA;
            }
            fitMenu->setStarred(choice,false);
         }
         fitMenu->setStatus(choice, IRutil::ftoa(loA) + " .. "
                                  + IRutil::ftoa(hiA));
         break;
       case HM_BOUNDS:
         ccout << "Enter lower and upper bounds for `hm' on next line, or 1 0 to freeze spec point value:" << endl;
         loggedRead(loHM,false);
         loggedRead(hiHM,false);
         if (loHM < hiHM) {
            fitMenu->setStarred(choice,true);
         } else {
            if (loHM > hiHM) {
               loHM = hiHM = ts.hm;
            } else {
               hiHM = loHM;
            }
            fitMenu->setStarred(choice,false);
         }
         fitMenu->setStatus(choice, IRutil::ftoa(loHM) + " .. "
                                  + IRutil::ftoa(hiHM));
         break;
       case HP_BOUNDS:
         ccout << "Enter lower and upper bounds for `hp' on next line, or 1 0 to freeze spec point value:" << endl;
         loggedRead(loHP,false);
         loggedRead(hiHP,false);
         if (loHP < hiHP) {
            fitMenu->setStarred(choice,true);
         } else {
            if (loHP > hiHP) {
               loHP = hiHP = ts.hp;
            } else {
               hiHP = loHP;
            }
            fitMenu->setStarred(choice,false);
         }
         fitMenu->setStatus(choice, IRutil::ftoa(loHP) + " .. "
                                  + IRutil::ftoa(hiHP));
         break;
       case B_BOUNDS:
         ccout << "Enter lower and upper bounds for `b' on next line, or 1 0 to freeze spec point value:" << endl;
         loggedRead(loB,false);
         loggedRead(hiB,false);
         if (loB < hiB) {
            fitMenu->setStarred(choice,true);
         } else {
            if (loB > hiB) {
               loB = hiB = ts.b;
            } else {
               hiB = loB;
            }
            fitMenu->setStarred(choice,false);
         }
         fitMenu->setStatus(choice, IRutil::ftoa(loB) + " .. "
                                  + IRutil::ftoa(hiB));
         break;
       case START_SPEC:
         ts = makeTrialSpec();
         tss = string(ts);
         strparams = ts.getDescription();
         fitMenu->setStatus(START_SPEC, ts.getName() + ": " + strparams);
         //fitMenu->setStatus(FIT_JUDGMENT_DEPTH, IRutil::itoa(ts.judgmentDepth));
         focusTrial->setSpec(ts);  //done also in "GO..."
         referenceTrial->setSpec(ts);
         //resetParamsMenu();
         break;
       //case FIT_JUDGMENT_DEPTH:
         //ccout << "Enter depth for judgment (0 for turn max): ";
         //loggedRead(fjd, false);
         //fitMenu->setStatus(choice, IRutil::itoa(fjd));
         //break;
       case MAX_ITERATIONS:
         ccout << "Enter limit on number of iterations: ";
         loggedRead(maxIter, false);
         fitMenu->setStatus(choice, IRutil::itoa(maxIter));
         break;
       case NUM_RETRIES:
         ccout << "Enter number of retries (per temp level in SA): ";
         loggedRead(numRetries, false);
         fitMenu->setStatus(choice, IRutil::itoa(numRetries));
         break;
       case PRECISION_X: 
         ccout << "Precision for 'x' lines: "; 
         loggedRead(precx,false); 
         fitMenu->setStatus(choice, IRutil::ftoa(precx));
         break;
       case PRECISION_Y:
         ccout << "Precision for 'y' values: ";
         loggedRead(precy,false);
         fitMenu->setStatus(choice, IRutil::ftoa(precy));
         break;
       case PRECISION_G:
         ccout << "Precision for geometry: " << endl;
         loggedRead(precg,false);
         fitMenu->setStatus(choice, IRutil::ftoa(precg));
         break; 
       case WALKOUT_STEP:
         ccout << "Enter new initial walkOut step: " << endl;
         loggedRead(step,false);
         fitMenu->setStatus(choice, IRutil::ftoa(step));
         break;
       case EPSFCN:
         ccout << "Enter epsfcn: " << endl;
         loggedRead(epsfcn,false);
         fitMenu->setStatus(choice, IRutil::ftoa(epsfcn));
         break;
       case BOOT_NUM:
         ccout << "Enter number of bootstrap trials: " << endl;
         loggedRead(bootNum,false);
         fitMenu->setStatus(choice, IRutil::itoa(bootNum));
         break;
       case KEEP_SPEC_IN_BOOT:
         ccout << "Keep regressed parameters in bootstrap trials?" << endl;
         loggedRead(ans,false);
         ans = IRutil::trim(ans);
         fitMenu->setStatus(choice, IRutil::isYes(ans) ? "yes" : "no");
         break;
       //case COPY_SCALE_TO_REFERENCE:
         //ccout << "Copy current scale to reference? (y/n) ";
         //loggedRead(ans);
         //ans = IRutil::trim(ans);
         //fitMenu->setStatus(choice, IRutil::isYes(ans) ? "yes" : "no");
       case EnumMenu::CANCEL_CHOICE: 
         cout << "Can't cancel, sorry---please try again." << endl; 
         break; 
       default: 
         cout << "Invalid choice, please try again." << endl;  //not ccout 
         break; 
      } 
      ccout << endl; 
   } 
   fitMenu->resetDefaults(); 
   return mm; 
} 
 
void Ensemble::runFit() {   
//Conceptualize as updating the TrialSpec.
   LOGP->flush();
   IRutil::nullstream nullstr; 
   ostream& ccout = usingCin() ? cout : nullstr; 
   string ans; 
   if (focusTrial->numDecisions() == 0) { 
      cout << "Empty data: please change filters and/or add game turns." << endl;  //not ccout 
   } else { 

      //reset static values 
      IRutil::numNewtons = 0; IRutil::maxNewtons = 0; IRutil::numVRCalls = 0; 
 
      TrialSpec ts0 = focusTrial->getSpec();  //used for all trials

      Minimizer* mm = makeMinimizer();  //only place Minimizer is used
                                        //includes the bootstrap number in mm.

      if (mm->getMaxIter() <= 0) {     //user only wants to print one value
         double val = mm->minimand();
         for (vector<ostream*>::iterator it = outs->begin();
              it != outs->end(); it++) {
            (**it) << "Minimand value: " << val << " at " << string(focusTrial->getSpec()) << endl;
         }
         return;
      } //else


      for (vector<ostream*>::iterator it = outs->begin();
           it != outs->end(); it++) {
         (**it) << endl << IRutil::DASHES << endl
                << "Fit of aggregate " << loadedGlobs << " giving files" << endl;
         for (size_t f = 0; f < loadedFiles.size(); f++) {
            (**it) << loadedFiles.at(f) << endl;
         }
         (**it) << IRutil::DASHES << endl << endl;
      }

      TrialSpec tsMM = mm->getPivotSpec();   //focusTrial->getSpec();
      focusTrial->setSpec(tsMM);

/*---------------
      TrialSpec ts = focusTrial->getSpec();  //new copy 
      if (mm->isSFirst()) { 
         minS = mm->minimize1(); 
         //minC = mm->getSpec().c;     //why doesn't this work? Side-effects... 
         minC = mm->bestCFor(minS); 
      } else { 
         minC = mm->minimize1(); 
         //minS = mm->getSpec().s; 
         minS = mm->bestSFor(minC); 
      } 
----------------*/


      TrialSpec ts = mm->minimize();         //new copy

      paramsMenu->setStatus(S_VALUE, IRutil::ftoa(ts.s));
      paramsMenu->setStatus(C_VALUE, IRutil::ftoa(ts.c));
      paramsMenu->setStatus(D_VALUE, IRutil::ftoa(ts.d));
      paramsMenu->setStatus(V_VALUE, IRutil::ftoa(ts.v));
      paramsMenu->setStatus(A_VALUE, IRutil::ftoa(ts.a));
      paramsMenu->setStatus(HM_VALUE, IRutil::ftoa(ts.hm));
      paramsMenu->setStatus(HP_VALUE, IRutil::ftoa(ts.hp));
      paramsMenu->setStatus(B_VALUE, IRutil::ftoa(ts.b));
      //paramsMenu->setStatus(SPEC_JUDGMENT_DEPTH, IRutil::ftoa(ts.judgmentDepth));



      if (focusTrial->getModel() == Models::POWER_SHARES) { 
         cout << endl << "#vectorRoot calls = " << IRutil::numVRCalls  
              << ", #Newtons = " << IRutil::numNewtons  
              << ", max #Newtons in any call = " << IRutil::maxNewtons 
           << endl << "Average #Newtons per call = " 
           << ((1.0 * IRutil::numNewtons) / double(IRutil::numVRCalls)) 
           << ",  Max value of root = " << IRutil::maxRoot << endl; 
            //not ccout? not for-loop over all "out"s? 
      } 
 
      IRfun::WEIGHTS wmc = ts.weightMethodChoice; 
      ccout << "Please name the computed best-fit spec: "; 
      loggedRead(ans,true); 
      ans = IRutil::trim(ans); 
      ccout << ans << endl;
      ts.setName(ans); 
      specs->clearStars(); 
      specs->addItem(ts,"",false,true);  //stars it 
      focusTrial->setSpec(ts); 
      referenceTrial->setSpec(ts); //vital to compute IPR
      resetParamsMenu();
      //Next line ought not to be an issue once equations are settled.
      //Workaround: re-load current DeltaScale with copy to reference enabled
      //if (refToo) { referenceTrial->setScale(focusTrial->getScale()); }
      string scalestr = "(x10,000) "; //(mm->getKind() == Minimizer::ML) ? "" : "(x10,000) "; 
      //note: Spec and scale on reference trial not really important
      //PerfData pfElo = (focusTrial->getFixPolicy() < 0) ?  
          //referenceTrial->perfTest(false,false) 
        //: referenceTrial3->perfTest(false,false); 

      for (vector<ostream*>::iterator it = outs->begin();
           it != outs->end(); it++) {
         (**it) << endl << IRutil::DASHES << endl
                << "Minimization"  // by " << fitMenu->nameOf(mm->getKind())
            << " converted the first " << tsMM.getKind() //curvesMenu->nameOf(tsMM.curveChoice)
            << " TrialSpec into the second:" << endl
            << tsMM.paramsPosition() << endl << ts.paramsPosition() << endl;
         (**it) << "with minimand value " << mm->minimand(false);
         (**it) <<  " from tests " << mm->getTestValStr() << endl << IRutil::DASHES << endl;
      }

      PerfData pfElo = referenceTrial->perfTest(false,false);  //gives sw1 error on a few turns
      PerfData pfSigmas = focusTrial->perfTest(false,false); 

      IPRstats is(pfElo,pfSigmas,ts);

      ccout << endl << "Basic Results: " << endl << setprecision(4) 
           << ts.getName() << " & & " << is.ipr.measuredValue << " & "
           << is.ipr.projected2SigmaLeft << "--" << is.ipr.projected2SigmaRight << " & "
           << is.ipr.projected2SigmaLeftAdj << "--" << is.ipr.projected2SigmaRightAdj << " & & "
           << focusTrial->numDecisions() << "\\\\  % IPRauto: "
           << is.iprAuto.measuredValue << " +- " << is.iprAuto.projectedSigma << "  / "
           << is.iprAdjByAuto.measuredValue << endl;




/*
                << is.irdpr2sd << "--" << is.irdpr2su << " & "
                << is.irdpr28sd << "--" << is.irdpr28su << " & & "
                << focusTrial->numDecisions() << "\\\\  % "
                << is.irpr << " +- " << (is.ira2su - is.ira2sd)/4 << "  / "
                << is.irj << endl;

*/
//Now do bootstrap runs.  

      size_t bootNum = mm->getBootNum();
      mm->setSilent();  //turns off verbose if on
      vector<IPRstats> iprv;
      cout << "Doing " << bootNum << " bootstrap trials..." << endl;
      for (int t = 0; t < bootNum; t++) {
         focusTrial->resample(focusTrial->numDecisions(), true);  //with replacement
         //focusTrial->setSpec(ts0);  //makes walkOut from original point
         focusTrial->setSpec(ts);  //makes walkOut from result point
         referenceTrial->setSpec(ts);
         TrialSpec tst = mm->minimize();
         focusTrial->setSpec(tst);
         referenceTrial->setSpec(tst); //vital to compute IPR
         PerfData pfElot = referenceTrial->perfTest(false,false);
         PerfData pfSigmast = focusTrial->perfTest(false,false);
         IPRstats ist(pfElot,pfSigmast,tst);
         iprv.push_back(ist);
         if ((t+1) % 10 == 0) { cout << "Finished trial " << (t+1) << endl; } //minimand calls print #
      }
      cerr << endl;
      focusTrial->resetBootWeights();  //does *not* re-filter
      focusTrial->setSpec(ts);
      referenceTrial->setSpec(ts);
      resetParamsMenu();
      double bootIPRsum = 0.0;
      double bootSumS = 0.0;
      double bootSumC = 0.0;
      for (int i = 0; i < iprv.size(); i++) {
         bootIPRsum += iprv.at(i).ipr.measuredValue;
         bootSumS += iprv.at(i).ts.s;
         bootSumC += iprv.at(i).ts.c;
      }
      double bootIPR = (bootNum > 0 ? bootIPRsum/double(iprv.size()) : is.ipr.measuredValue);
      double bootS = (bootNum > 0 ? bootSumS/double(iprv.size()) : is.ts.s);
      double bootC = (bootNum > 0 ? bootSumC/double(iprv.size()) : is.ts.c);
      double bootIPRvarxn = 0.0;
      double bootSvarxn = 0.0;
      double bootCvarxn = 0.0;
      for (int i = 0; i < iprv.size(); i++) {
         bootIPRvarxn += IRutil::sqr(iprv.at(i).ipr.measuredValue - bootIPR);
         bootSvarxn += IRutil::sqr(iprv.at(i).ts.s - bootS);
         bootCvarxn += IRutil::sqr(iprv.at(i).ts.c - bootC);
      }
      double bootIPRsigma = (iprv.size() > 0 ? sqrt(bootIPRvarxn/double(iprv.size())) : 0.0);
      double bootSsigma = (iprv.size() > 0 ? sqrt(bootSvarxn/double(iprv.size())) : 0.0);
      double bootCsigma = (iprv.size() > 0 ? sqrt(bootCvarxn/double(iprv.size())) : 0.0);



      iprv.clear();

      for (vector<ostream*>::const_iterator it = outs->begin();
           it != outs->end(); it++) {
         (**it) << "Best-fit score " << scalestr << "and spec: " << mm->minimand()
                << endl << ts.oneLine() << endl << IRutil::DASHES << endl
                << "IPR: " << setprecision(4) << is.ipr.measuredValue
                << " from " << pfElo.scaledFalloffWtd.projectedFreq
                << ", 2-sigma range [" << is.ipr.projected2SigmaLeft << "," << is.ipr.projected2SigmaRight << "]"
                << ", 2.8-sigma [" << is.iprAdj.projected2SigmaLeftAdj << "," << is.iprAdj.projected2SigmaRightAdj 
                << "]" << endl
                << "IPR if " << focusTrial->numDecisions()
                << " positions faced were test suite: " << is.iprAuto.measuredValue
                << ", st. dev. " << setprecision(2) << (is.iprAuto.projected2SigmaRight - is.iprAuto.projected2SigmaLeft)/4
                << endl
                << "AdjIPR: " << setprecision(4) << is.iprAdjByAuto.measuredValue << " via " << setprecision(6)
                << pfSigmas.scaledFalloffWtd.measuredFreq << "/"
                << pfSigmas.scaledFalloffWtd.projectedFreq << " = " << is.autoRatio
                << setprecision(2)
                << ": " << is.iprAdjByAuto.projected2SigmaLeft << "--" << is.iprAdjByAuto.projected2SigmaRight << "; 2.8s: "
                << is.iprAdjByAuto.projected2SigmaLeftAdj << "--" << is.iprAdjByAuto.projected2SigmaRightAdj << endl << setprecision(6)
                << "Adj. AE/turn: " << pfElo.scaledFalloffWtd.projectedFreq * is.autoRatio
                << " stdev. " << is.ownSigma << ", index "
                << is.ownSigma/sqrt(double(pfSigmas.accumWeight))
                << endl;

         (**it) << endl << "Line for paper: " << endl << setprecision(4)
           << ts.getName() << " & & " << is.ipr.measuredValue << " & "
           << is.ipr.projected2SigmaLeft << "--" << is.ipr.projected2SigmaRight << " & "
           //<< is.ipr.projected2SigmaLeftAdj << "--" << is.ipr.projected2SigmaRightAdj << " & & "
           << is.iprAdj.projected2SigmaLeft << "--" << is.iprAdj.projected2SigmaRight << " & & "
           << focusTrial->numDecisions() << "\\\\  % IPRauto: "
           << is.iprAuto.measuredValue << " +- " << is.iprAuto.projectedSigma << "  / "
           << is.iprAdjByAuto.measuredValue << endl;
/*
                << ts.getName() << " & & " << is.ir << " & "
                << is.irdpr2sd << "--" << is.irdpr2su << " & "
                << is.irdpr28sd << "--" << is.irdpr28su << " & & "
                << focusTrial->numDecisions() << "\\\\  % "
                << is.irpr << " +- " << (is.ira2su - is.ira2sd)/4 << "  / "
                << is.irj << endl;
*/
         if (bootNum > 0) {
            (**it) << setprecision(5) << "Bootstrap IPR: " << setprecision(4) << bootIPR
                   << ", stdev " << bootIPRsigma << endl
                   << "Bootstrap s: " << bootS << ", stdev " << bootSsigma << endl
                   << "Bootstrap c: " << bootC << ", stdev " << bootCsigma << endl;
         }

      } 
      delete(mm);
   } 
} 

void Ensemble::runPerfTest() const {   //!!!
   IRutil::nullstream nullstrm;
   ostream& ccout = (usingCin()) ? cout : nullstrm;
   string ans;
   int intItem;
   int choice = -1;
   bool uf, uw, tn, mr, suw, sun, showMoves;
   string zmmFile, zevFile, zadFile, movesFile;
   size_t numBootstrapTrials = 0;
   size_t numResampleTrials = 0;
   size_t numResampleGames = 0;
   size_t numResampleTurns = 0;
   size_t movesLimit = 1000;
   bool oneSidePerGame = true;
   size_t numIndices = 15; //should agree with defaults
   size_t equalTopIndexLimit = atoi(testMenu->getStatus(EQUAL_TOP_INDEX_LIMIT).c_str());
   size_t numSelectors = focusTrial->numSelectors();
   testMenu->resetDefaults();
   while (choice != GO_TEST) {
      choice = testMenu->readChoice();  
      switch(choice) {
       case USE_FOCUS_SPEC:
       case MISS_IS_MOVE_NPLUSONE:
       case FORCE_UNIT_WEIGHTS:
       case SHOW_UNWEIGHTED:
       case SHOW_UNSCALED:
       case SHOW_INDIVIDUAL_MOVES:
         ccout << "Yes or No? (y/n) ";
         loggedRead(ans);
         ans = IRutil::trim(ans);
         testMenu->setStatus(choice, IRutil::isYes(ans) ? "yes" : "no");
         break;
       case NUM_INDICES:
         ccout << "Enter K to display top K moves: ";
         loggedRead(numIndices,false);
         testMenu->setStatus(choice, IRutil::itoa(numIndices));
         break;
       case EQUAL_TOP_INDEX_LIMIT:
         ccout << "Enter 0-based limit on equal-top value moves: ";
         loggedRead(equalTopIndexLimit,false);
         testMenu->setStatus(choice, IRutil::itoa(equalTopIndexLimit));
         break;
       case NUM_BOOTSTRAP_TRIALS: 
         ccout << "Enter number of bootstrap trials: ";
         loggedRead(numBootstrapTrials,false);
         testMenu->setStatus(choice, IRutil::itoa(numBootstrapTrials));
         break;
       case NUM_RESAMPLE_TRIALS:
         ccout << "Enter number of non-bootstrap resample trials: ";
         loggedRead(numResampleTrials,false);
         testMenu->setStatus(choice, IRutil::itoa(numResampleTrials));
         break;
       case NUM_RESAMPLE_GAMES:
         ccout << "Enter number of games to resample: ";
         loggedRead(numResampleGames,false);
         testMenu->setStatus(choice, IRutil::itoa(numResampleGames));
         break;
       case NUM_RESAMPLE_TURNS:
         ccout << "Enter number of turns to resample: ";
         loggedRead(numResampleTurns,false);
         testMenu->setStatus(choice, IRutil::itoa(numResampleTurns));
         break;
       case ONE_PLAYER_PER_GAME:
         ccout << "Randomly select one side in each game? (y/n) ";
         loggedRead(ans,false);
         ans = IRutil::trim(ans);
         testMenu->setStatus(choice, IRutil::isYes(ans) ? "yes" : "no");
         break;
       case ZMM_FILE:
         ccout << "File for move-match z-scores? "; 
         loggedRead(ans,false);
         ans = IRutil::trim(ans);
         testMenu->setStatus(choice, ans);
         break;
       case ZEV_FILE:
         ccout << "File for equal-value-match z-scores? ";
         loggedRead(ans,false);
         ans = IRutil::trim(ans);
         testMenu->setStatus(choice, ans);
         break;
       case ZAD_FILE:
         ccout << "File for average-(scaled-)difference z-scores? ";
         loggedRead(ans,false);
         ans = IRutil::trim(ans);
         testMenu->setStatus(choice, ans);
         break;
       case MOVES_FILE:
         ccout << "File for dumping probability data on each move? ";
         loggedRead(ans,false);
         ans = IRutil::trim(ans);
         testMenu->setStatus(choice, ans);
         break;
       case MOVES_LIMIT:
         ccout << "Enter limit on number of positions written: ";
         loggedRead(intItem,false);
         testMenu->setStatus(choice, IRutil::itoa(intItem));
         break;

       case GO_TEST:
         numBootstrapTrials = atoi(testMenu->getStatus(NUM_BOOTSTRAP_TRIALS).c_str());
         numResampleTrials = atoi(testMenu->getStatus(NUM_RESAMPLE_TRIALS).c_str());
         numResampleGames = atoi(testMenu->getStatus(NUM_RESAMPLE_GAMES).c_str());
         numResampleTurns = atoi(testMenu->getStatus(NUM_RESAMPLE_TURNS).c_str());
         oneSidePerGame = IRutil::isYes(testMenu->getStatus(ONE_PLAYER_PER_GAME));
         zmmFile = testMenu->getStatus(ZMM_FILE);
         zevFile = testMenu->getStatus(ZEV_FILE);
         zadFile = testMenu->getStatus(ZAD_FILE);
         movesFile = testMenu->getStatus(MOVES_FILE);
         movesLimit = atoi(testMenu->getStatus(MOVES_LIMIT).c_str());

         numIndices = atoi(testMenu->getStatus(NUM_INDICES).c_str());
         equalTopIndexLimit = atoi(testMenu->getStatus(EQUAL_TOP_INDEX_LIMIT).c_str());
         uf = IRutil::isYes(testMenu->getStatus(USE_FOCUS_SPEC));
         tn = IRutil::isYes(testMenu->getStatus(MISS_IS_MOVE_NPLUSONE));
         uw = IRutil::isYes(testMenu->getStatus(FORCE_UNIT_WEIGHTS));
         suw = IRutil::isYes(testMenu->getStatus(SHOW_UNWEIGHTED));
         sun = IRutil::isYes(testMenu->getStatus(SHOW_UNSCALED));
         showMoves = IRutil::isYes(testMenu->getStatus(SHOW_INDIVIDUAL_MOVES));
         break;  //exits menu into main body
       default:
         ccout << "Could not understand answer, please try again: ";
      }
   } //end of while(choice...); alternative to uf not implemented 

   bool silent = false;

   PerfData pf = focusTrial->perfTest(uw,tn,suw,sun,numIndices,equalTopIndexLimit,silent,movesFile,movesLimit);

//cerr << "Completed perf test." << endl;

   string rept = pf.fullReport(numIndices,tn);
   if (showMoves) {
      //rept += string("\n\nMoves:\n") + pf.movesReport();
      ofstream movesDump(movesFile.c_str(), ios::app);
      movesDump << pf.movesReport() << endl;
      movesDump.close();
   }

   for (vector<ostream*>::iterator it = outs->begin();
        it != outs->end(); it++) {
      (**it) << endl << IRutil::DASHES << endl
             << "Test of aggregate " << loadedGlobs << " giving files" << endl;
      for (size_t f = 0; f < loadedFiles.size(); f++) {
         (**it) << loadedFiles.at(f) << endl;
      }
      (**it) << "using " << string(*focusTrial) << endl
             << IRutil::DASHES << endl << endl;
      (**it) << rept << endl;
      //if (interval > 0.0) {
         //(**it) << "Curve points:" << endl;
         //(**it) << theSpec->showCurvePoints(interval, curveLimit);
      //}
      (**it) << IRutil::DASHES << endl << endl;
   }

   string bootrept = "";
   if (numBootstrapTrials > 0) {
      int t;
      silent = true;
      vector<SimpleStats> ssv;
      cout << "Doing " << numBootstrapTrials << " bootstrap trials..." << endl;
      for (t = 0; t < numBootstrapTrials; t++) {
         focusTrial->resample(focusTrial->numDecisions(), true);  //with replacement
         SimpleStats ss = focusTrial->perfTestSimple(numIndices,numSelectors,
                                         focusTrial->exportSelectors(),uw,tn,false); //don't aggregate
         ssv.push_back(ss);
         //cout << "." << (t+1);
         if ((t+1) % 100 == 0) { cout << "Finished " << (t+1) << " trials." << endl; }
      }
      cerr << endl;
      focusTrial->resetBootWeights();  //does *not* re-filter
      SimpleStats bootSums(numIndices,numSelectors);
      SimpleStats bootVarSums(numIndices,numSelectors);
      SimpleStats bootSigmas(numIndices,numSelectors);
      for (t = 0; t < numBootstrapTrials; t++) {
         bootSums.accumWeight += ssv.at(t).accumWeight;  //meaningless?
         bootSums.equalValueMatchWtd += ssv.at(t).equalValueMatchWtd; //sum of averages--beware
         bootSums.equalValueMatchProjWtd += ssv.at(t).equalValueMatchProjWtd;
         bootSums.scaledFalloffWtd += ssv.at(t).scaledFalloffWtd;
         bootSums.scaledFalloffProjWtd += ssv.at(t).scaledFalloffProjWtd;
         bootSums.indexScoreWtd += ssv.at(t).indexScoreWtd;
         bootSums.indexMassWtd += ssv.at(t).indexMassWtd;
         bootSums.indexScoreInvVarWtd += ssv.at(t).indexScoreInvVarWtd;
         bootSums.indexScorePropWtd += ssv.at(t).indexScorePropWtd;
         bootSums.indexFitWtd += ssv.at(t).indexFitWtd;
         for (int i = 0; i < numIndices; i++) {
            bootSums.indexMatchesWtd.at(i) += ssv.at(t).indexMatchesWtd.at(i);
            bootSums.indexMatchesProjWtd.at(i) += ssv.at(t).indexMatchesProjWtd.at(i);
         }
         for (int k = 0; k < numSelectors; k++) {
            bootSums.selectorMatchesPlayerWtd.at(k) += ssv.at(t).selectorMatchesPlayerWtd.at(k);
            bootSums.selectorMatchesPlayerProjWtd.at(k) += ssv.at(t).selectorMatchesPlayerProjWtd.at(k);
            bootSums.selectorMatchesEngineWtd.at(k) += ssv.at(t).selectorMatchesEngineWtd.at(k);
         }
      }
      double nbt = numBootstrapTrials;
      for (t = 0; t < numBootstrapTrials; t++) {
         bootVarSums.accumWeight += IRutil::sqr(ssv.at(t).accumWeight - bootSums.accumWeight/nbt);
         bootVarSums.equalValueMatchWtd += IRutil::sqr(ssv.at(t).equalValueMatchWtd 
                                                       - bootSums.equalValueMatchWtd/nbt);
         bootVarSums.equalValueMatchProjWtd += IRutil::sqr(ssv.at(t).equalValueMatchProjWtd
                                                       - bootSums.equalValueMatchProjWtd/nbt);
         bootVarSums.scaledFalloffWtd += IRutil::sqr(ssv.at(t).scaledFalloffWtd
                                                       - bootSums.scaledFalloffWtd/nbt);
         bootVarSums.scaledFalloffProjWtd += IRutil::sqr(ssv.at(t).scaledFalloffProjWtd
                                                       - bootSums.scaledFalloffProjWtd/nbt);
         bootVarSums.indexScoreWtd += IRutil::sqr(ssv.at(t).indexScoreWtd
                                                       - bootSums.indexScoreWtd/nbt);
         bootVarSums.indexMassWtd += IRutil::sqr(ssv.at(t).indexMassWtd
                                                       - bootSums.indexMassWtd/nbt);
         bootVarSums.indexScoreInvVarWtd += IRutil::sqr(ssv.at(t).indexScoreInvVarWtd
                                                       - bootSums.indexScoreInvVarWtd/nbt);
         bootVarSums.indexScorePropWtd += IRutil::sqr(ssv.at(t).indexScorePropWtd
                                                       - bootSums.indexScorePropWtd/nbt);
         bootVarSums.indexFitWtd += IRutil::sqr(ssv.at(t).indexFitWtd
                                                       - bootSums.indexFitWtd/nbt);
         for (int i = 0; i < numIndices; i++) {
            bootVarSums.indexMatchesWtd.at(i) += IRutil::sqr(ssv.at(t).indexMatchesWtd.at(i)
                                                       - bootSums.indexMatchesWtd.at(i)/nbt);
            bootVarSums.indexMatchesProjWtd.at(i) += IRutil::sqr(ssv.at(t).indexMatchesProjWtd.at(i)
                                                       - bootSums.indexMatchesProjWtd.at(i)/nbt);
         }
         for (int k = 0; k < numSelectors; k++) {
            bootVarSums.selectorMatchesPlayerWtd.at(k) += IRutil::sqr(ssv.at(t).selectorMatchesPlayerWtd.at(k)
                                                       - bootSums.selectorMatchesPlayerWtd.at(k)/nbt);
            bootVarSums.selectorMatchesPlayerProjWtd.at(k) += IRutil::sqr(ssv.at(t).selectorMatchesPlayerProjWtd.at(k)
                                                       - bootSums.selectorMatchesPlayerProjWtd.at(k)/nbt);
            bootVarSums.selectorMatchesEngineWtd.at(k) += IRutil::sqr(ssv.at(t).selectorMatchesEngineWtd.at(k)
                                                       - bootSums.selectorMatchesEngineWtd.at(k)/nbt);
         }
      }
      bootSigmas.accumWeight = sqrt(bootVarSums.accumWeight/nbt);
      bootSigmas.equalValueMatchWtd = sqrt(bootVarSums.equalValueMatchWtd/nbt);
      bootSigmas.equalValueMatchProjWtd = sqrt(bootVarSums.equalValueMatchProjWtd/nbt);
      bootSigmas.scaledFalloffWtd = sqrt(bootVarSums.scaledFalloffWtd/nbt);
      bootSigmas.scaledFalloffProjWtd = sqrt(bootVarSums.scaledFalloffProjWtd/nbt);
      bootSigmas.indexScoreWtd = sqrt(bootVarSums.indexScoreWtd/nbt);
      bootSigmas.indexMassWtd = sqrt(bootVarSums.indexMassWtd/nbt);
      bootSigmas.indexScoreInvVarWtd = sqrt(bootVarSums.indexScoreInvVarWtd/nbt);
      bootSigmas.indexScorePropWtd = sqrt(bootVarSums.indexScorePropWtd/nbt);
      bootSigmas.indexFitWtd = sqrt(bootVarSums.indexFitWtd/nbt);
      for (int i = 0; i < numIndices; i++) {
         bootSigmas.indexMatchesWtd.at(i) = sqrt(bootVarSums.indexMatchesWtd.at(i)/nbt);
         bootSigmas.indexMatchesProjWtd.at(i) = sqrt(bootVarSums.indexMatchesProjWtd.at(i)/nbt);
      }
      for (int k = 0; k < numSelectors; k++) {
         bootSigmas.selectorMatchesPlayerWtd.at(k) = sqrt(bootVarSums.selectorMatchesPlayerWtd.at(k)/nbt);
         bootSigmas.selectorMatchesPlayerProjWtd.at(k) = sqrt(bootVarSums.selectorMatchesPlayerProjWtd.at(k)/nbt);
         bootSigmas.selectorMatchesEngineWtd.at(k) = sqrt(bootVarSums.selectorMatchesEngineWtd.at(k)/nbt);
      }

      focusTrial->resetBootWeights();
      PerfData pfc = focusTrial->perfTest(uw,tn,suw,sun,numIndices,equalTopIndexLimit,silent);
      pfc.moveMatchWtd.setProjectedValue(bootSums.indexMatchesProjWtd.at(0)/nbt);
      pfc.moveMatchWtd.setMeasuredValue(bootSums.indexMatchesWtd.at(0)/nbt);
      pfc.moveMatchWtd.setProjectedVariance(IRutil::sqr(bootSigmas.indexMatchesProjWtd.at(0)));
      pfc.moveMatchWtd.setMeasuredVariance(IRutil::sqr(bootSigmas.indexMatchesWtd.at(0)));
      pfc.moveMatchWtd.update();
      pfc.moveMatchWtd.bootName();
      pfc.equalValueMatchWtd.setProjectedValue(bootSums.equalValueMatchProjWtd/nbt);
      pfc.equalValueMatchWtd.setMeasuredValue(bootSums.equalValueMatchWtd/nbt);
      pfc.equalValueMatchWtd.setProjectedVariance(IRutil::sqr(bootSigmas.equalValueMatchProjWtd));
      pfc.equalValueMatchWtd.setMeasuredVariance(IRutil::sqr(bootSigmas.equalValueMatchWtd));
      pfc.equalValueMatchWtd.update();
      pfc.equalValueMatchWtd.bootName();
      pfc.scaledFalloffWtd.setProjectedValue(bootSums.scaledFalloffProjWtd/nbt);
      pfc.scaledFalloffWtd.setMeasuredValue(bootSums.scaledFalloffWtd/nbt);
      pfc.scaledFalloffWtd.setProjectedVariance(IRutil::sqr(bootSigmas.scaledFalloffProjWtd));
      pfc.scaledFalloffWtd.setMeasuredVariance(IRutil::sqr(bootSigmas.scaledFalloffWtd));
      pfc.scaledFalloffWtd.update();
      pfc.scaledFalloffWtd.bootName();

      bootrept += string("Original tests and tests with bootstrapped sigmas:\n");
      bootrept += string("\n") + AggregateTest::header() + string("\n");
      bootrept += string(pf.scaledFalloffWtd) + string("\n") + string(pfc.scaledFalloffWtd) + string("\n");
      bootrept += string(pf.moveMatchWtd) + string("\n") + string(pfc.moveMatchWtd) + string("\n");
      bootrept += string(pf.equalValueMatchWtd) + string("\n") + string(pfc.equalValueMatchWtd) + string("\n");

      bootrept += string("Bootstrapped selector matches:\n");
      for (int k = 0; k < numSelectors; k++) {
         pfc.selectionTestsWtd.at(k).setProjectedValue(bootSums.selectorMatchesPlayerProjWtd.at(k));
         pfc.selectionTestsWtd.at(k).setMeasuredValue(bootSums.selectorMatchesPlayerWtd.at(k));
         pfc.selectionTestsWtd.at(k).setProjectedVariance(IRutil::sqr(bootSigmas.selectorMatchesPlayerProjWtd.at(k)));
         pfc.selectionTestsWtd.at(k).setMeasuredVariance(IRutil::sqr(bootSigmas.selectorMatchesPlayerWtd.at(k)));
         pfc.selectionTestsWtd.at(k).update();
         pfc.selectionTestsWtd.at(k).bootName();
         bootrept += string(pf.selectionTestsWtd.at(k)) + "\n" + string(pfc.selectionTestsWtd.at(k)) + "\n";
      }
      bootrept += string("\n");



/*---------------Not the best way to show bootstrapped items?----------------------------------
  
      StatItem* pscaledFalloffWtd = new StatItem(pf.scaledFalloffWtd.name,
            pf.scaledFalloffWtd.maxOrderOfMagnitude, 
            pf.scaledFalloffWtd.numDecimals,
            pf.scaledFalloffWtd.measuredFreq,
            IRutil::sqr(pf.scaledFalloffWtd.measuredSigmaFreq));  //not sure of this !!!
      BootstrappedItem bscaledFalloffWtd(pscaledFalloffWtd,
                                            bootSums.scaledFalloffWtd/nbt, 
                                            bootVarSums.scaledFalloffWtd/nbt,
                                            numBootstrapTrials);
      StatItem* pscaledFalloffProjWtd = new StatItem("scaledFalloffProj",
            pf.scaledFalloffWtd.maxOrderOfMagnitude,
            pf.scaledFalloffWtd.numDecimals,
            pf.scaledFalloffWtd.projectedFreq,
            IRutil::sqr(pf.scaledFalloffWtd.projectedSigmaFreq));  //not sure of this !!!
      BootstrappedItem bscaledFalloffProjWtd(pscaledFalloffProjWtd,
                                            bootSums.scaledFalloffProjWtd/nbt,
                                            bootVarSums.scaledFalloffProjWtd/nbt,
                                            numBootstrapTrials);
      StatItem* pequalValueMatchWtd = new StatItem(pf.equalValueMatchWtd.name,
            pf.equalValueMatchWtd.maxOrderOfMagnitude,
            pf.equalValueMatchWtd.numDecimals,
            pf.equalValueMatchWtd.measuredFreq,
            IRutil::sqr(pf.equalValueMatchWtd.measuredSigmaFreq));  //not sure of this !!!
      BootstrappedItem bequalValueMatchWtd(pequalValueMatchWtd,
                                            bootSums.equalValueMatchWtd/nbt,
                                            bootVarSums.equalValueMatchWtd/nbt,
                                            numBootstrapTrials);
      StatItem* pequalValueMatchProjWtd = new StatItem("equalValueMatchProj",
            pf.equalValueMatchWtd.maxOrderOfMagnitude,
            pf.equalValueMatchWtd.numDecimals,
            pf.equalValueMatchWtd.projectedFreq,
            IRutil::sqr(pf.equalValueMatchWtd.projectedSigmaFreq));  //not sure of this !!!
      BootstrappedItem bequalValueMatchProjWtd(pequalValueMatchProjWtd,
                                            bootSums.equalValueMatchProjWtd/nbt,
                                            bootVarSums.equalValueMatchProjWtd/nbt,
                                            numBootstrapTrials);
      StatItem* pindexMassWtd = new StatItem("indexMassWtd",1,4,pf.indexFitMassWtd,0.0);
      BootstrappedItem bindexMassWtd(pindexMassWtd,
                                            bootSums.indexMassWtd/nbt,
                                            bootVarSums.indexMassWtd/nbt,
                                            numBootstrapTrials);
      StatItem* pindexInvVarWtd = new StatItem("indexInvVarWtd",1,4,pf.indexFitInvVarWtd,0.0);
      BootstrappedItem bindexInvVarWtd(pindexInvVarWtd,
                                            bootSums.indexScoreInvVarWtd/nbt,
                                            bootVarSums.indexScoreInvVarWtd/nbt,
                                            numBootstrapTrials);
      StatItem* pindexPropWtd = new StatItem("indexPropWtd",1,4,pf.indexFitPropWtd,0.0);
      BootstrappedItem bindexPropWtd(pindexPropWtd,
                                            bootSums.indexScorePropWtd/nbt,
                                            bootVarSums.indexScorePropWtd/nbt,
                                            numBootstrapTrials);
      StatItem* pindexFitWtd = new StatItem("indexFitWtd",1,4,pf.indexFitWtd,0.0);
      BootstrappedItem bindexFitWtd(pindexFitWtd,
                                            bootSums.indexFitWtd/nbt,
                                            bootVarSums.indexFitWtd/nbt,
                                            numBootstrapTrials);

      for (int i = 0; i < numIndices; i++) {
         StatItem* pindexMatchesWtd = new StatItem(pf.moveIndexTests.at(i).name,
               pf.moveIndexTests.at(i).maxOrderOfMagnitude,
               pf.moveIndexTests.at(i).numDecimals,
               pf.moveIndexTests.at(i).measuredFreq,
               IRutil::sqr(pf.moveIndexTests.at(i).measuredSigmaFreq));
         BootstrappedItem bindexMatchesWtd(pindexMatchesWtd,
                                            bootSums.indexMatchesWtd.at(i)/nbt,
                                            bootVarSums.indexMatchesWtd.at(i)/nbt,
                                            numBootstrapTrials);
         StatItem* pindexMatchesProjWtd = new StatItem(pf.moveIndexTests.at(i).name,
               pf.moveIndexTests.at(i).maxOrderOfMagnitude,
               pf.moveIndexTests.at(i).numDecimals,
               pf.moveIndexTests.at(i).projectedFreq,
               IRutil::sqr(pf.moveIndexTests.at(i).projectedSigmaFreq));
         BootstrappedItem bindexMatchesProjWtd(pindexMatchesProjWtd,
                                            bootSums.indexMatchesProjWtd.at(i)/nbt,
                                            bootVarSums.indexMatchesProjWtd.at(i)/nbt,
                                            numBootstrapTrials);
         bootrept += string(bindexMatchesProjWtd) + string("\n");
         bootrept += string(bindexMatchesWtd) + string("\n");
         delete(pindexMatchesWtd);
         delete(pindexMatchesProjWtd);
      }

      bootrept += string("\n") + string(bscaledFalloffProjWtd) + string("\n")
                            + string(bscaledFalloffWtd) + string("\n");
      bootrept += string("\n") + string(bequalValueMatchProjWtd) + string("\n")
                            + string(bequalValueMatchWtd) + string("\n");

      bootrept += string("\n") + string(bindexFitWtd) + string("\n")
                            + string(bindexMassWtd) + string("\n")
                            + string(bindexInvVarWtd) + string("\n")
                            + string(bindexPropWtd) + string("\n");
      delete(pindexMassWtd);
      delete(pindexInvVarWtd);
      delete(pindexPropWtd);
      delete(pindexFitWtd);

      for (int k = 0; k < numSelectors; k++) {
         StatItem* pselectorMatchWtd  = new StatItem(pf.selectionTests.at(k).name,
               pf.selectionTests.at(k).maxOrderOfMagnitude,
               pf.selectionTests.at(k).numDecimals,
               pf.selectionTests.at(k).measuredFreq,
               IRutil::sqr(pf.selectionTests.at(k).measuredSigmaFreq));
         BootstrappedItem bselectorMatchWtd(pselectorMatchWtd,
                                            bootSums.selectorMatchesPlayerWtd.at(k)/nbt,
                                            bootVarSums.selectorMatchesPlayerWtd.at(k)/nbt,
                                            numBootstrapTrials);
         StatItem* pselectorMatchProjWtd = new StatItem(pf.selectionTests.at(k).name,
               pf.selectionTests.at(k).maxOrderOfMagnitude,
               pf.selectionTests.at(k).numDecimals,
               pf.selectionTests.at(k).projectedFreq,
               IRutil::sqr(pf.selectionTests.at(k).projectedSigmaFreq));
         BootstrappedItem bselectorMatchProjWtd(pselectorMatchProjWtd,
                                            bootSums.selectorMatchesPlayerProjWtd.at(k)/nbt,
                                            bootVarSums.selectorMatchesPlayerProjWtd.at(k)/nbt,
                                            numBootstrapTrials);
         StatItem* pengineMatchWtd  = new StatItem(pf.selectionTests.at(k).name,
               pf.selectionTests.at(k).maxOrderOfMagnitude,
               pf.selectionTests.at(k).numDecimals,
               pf.selectionTests.at(k).engineMatchFreq,
               0.0);
         BootstrappedItem bengineMatchWtd(pengineMatchWtd,
                                            bootSums.selectorMatchesEngineWtd.at(k)/nbt,
                                            bootVarSums.selectorMatchesEngineWtd.at(k)/nbt,
                                            numBootstrapTrials);

         bootrept += string("\n") + string(bselectorMatchProjWtd) + string("\n")
                               + string(bselectorMatchWtd) + string("\n")
                               + string(bengineMatchWtd) + string("\n");
         delete(pselectorMatchWtd);
         delete(pselectorMatchProjWtd);
         delete(pengineMatchWtd);
      }
*///-----------------------------------------------------------------------------------

         

   } //end of if (numBootstrapTrials > 0)


   if (bootrept != "") {
      for (vector<ostream*>::iterator it = outs->begin();
           it != outs->end(); it++) {
         (**it) << bootrept << endl;
         (**it) << IRutil::DASHES << endl << endl;
      }
   }

   vector<PerfData> perfTests;
   if (numResampleTrials > 0) {
      cout << "Doing " << numResampleTrials << " resample trials." << endl;
      if (numResampleGames > 0) {
         for (int t = 0; t < numResampleTrials; t++) {
            focusTrial->resampleGames(numResampleGames, false, oneSidePerGame);
            PerfData pft = focusTrial->perfTest(uw,tn,suw,sun,numIndices,equalTopIndexLimit,true); //always silent
            perfTests.push_back(pft);
            if ((t+1) % 100 == 0) { cout << "Finished " << (t+1) << " trials." << endl; }
         }
      } else if (numResampleTurns > 0) {
         for (int t = 0; t < numResampleTrials; t++) {
            focusTrial->resample(numResampleTurns, false);  //gives a set
            PerfData pft = focusTrial->perfTest(uw,tn,suw,sun,numIndices,equalTopIndexLimit,true); //always silent
            perfTests.push_back(pft);
            if ((t+1) % 100 == 0) { cout << "Finished " << t << " trials." << endl; }
         }
      } 
      focusTrial->resetBootWeights();
      ofstream zscoreMM(zmmFile.c_str(), ios::app);
      ofstream zscoreEV(zevFile.c_str(), ios::app);
      ofstream zscoreAD(zadFile.c_str(), ios::app);
      int nt = perfTests.size();
      zscoreMM << "Next test of " << nt << " trials:" << endl;
      zscoreEV << "Next test of " << nt << " trials:" << endl;
      zscoreAD << "Next test of " << nt << " trials:" << endl;
      
      for (int t = 0; t < nt; t++) {
         zscoreMM << perfTests.at(t).moveMatchWtd.zScore
                  << "   from " << perfTests.at(t).moveMatchWtd.getSampleVolume() << endl;
         zscoreEV << perfTests.at(t).equalValueMatchWtd.zScore 
                  << "   from " << perfTests.at(t).equalValueMatchWtd.getSampleVolume() << endl;
         zscoreAD << perfTests.at(t).scaledFalloffWtd.zScore
                  << "   from " << perfTests.at(t).scaledFalloffWtd.getSampleVolume() << endl;
      }
      zscoreMM.close();
      zscoreEV.close();
      zscoreAD.close();
   }

}



 
 
TurnFilter* Ensemble::chooseCreatedFilter() { 
   int i = filters->readChoice(); 
   while (!(filters->success(i) || i == EnumMenu::CANCEL_CHOICE 
            || i == EnumMenu::MORE_CHOICE)) { 
      cerr << "Need valid filter choice, or " << EnumMenu::MORE_CHOICE 
           << "/" << filters->info->MORE_NAME << " to define new, " 
           << EnumMenu::CANCEL_CHOICE 
           << "/" << filters->info->CANCEL_NAME << " to cancel." << endl; 
      i = filters->readChoice(); 
   } 
   if (filters->success(i)){ 
      string name = filters->nameOf(i); 
      //filters->setStarred(name,true); 
      return (*filters)[name]; 
   } else if (i == EnumMenu::MORE_CHOICE) { 
      return makeFilter(filtersMenu->readChoice()); 
   } else { 
      cout << "Cancel---returning trivial-true filter..." << endl; 
      FnFilter* outf = new FnFilter(&allowAll,"triv"); 
      return outf; 
   } 
} 
 
TurnFilter* Ensemble::makeFilter(int choice) { 
   IRutil::nullstream nullstr; 
   ostream& ccout = usingCin() ? cout : nullstr; 
   COMPARE comp; 
   string name; 
   string item,ans; 
   int intItem, intItem2, enumItem; 
   double floatItem; 
   bool entering; 
   TurnFilter* outf; 
   AndFilter* andf; 
   OrFilter* orf; 
   PlayerOrFilter* porf; 
   MoveSelector* ms;
   map<string,double> nf;
 
   if (choice >= 2) { 
      ccout << "Name the new filter itself: "; 
      loggedRead(name,false); 
      name = IRutil::trim(name); 
   } 
 
   switch(choice) { 
    case NO_FILTER: 
      outf = new FnFilter(&allowAll,name); 
      break; 
    case EXISTING_FILTER: 
      outf = chooseCreatedFilter(); 
      break; 
    case FN_FILTER: 
      cout << "Only one implemented so far is trivial-true, sorry." << endl; 
      outf = new FnFilter(&allowAll,name); 
      break; 
   case NOT_FILTER: 
      ccout << "Choose another filter, or " << EnumMenu::MORE_CHOICE 
            << " to define new:" << endl; 
      //outf = new NotFilter(makeFilter(filtersMenu->readChoice()),name); 
      outf = new NotFilter(chooseCreatedFilter(), name); 
      break; 
   case AND_FILTER: 
      andf = new AndFilter(name); 
      ans = "yes"; 
      ccout << "Define or load filter conjuncts, or " << EnumMenu::MORE_CHOICE 
            << " to define new:" << endl; 
      while (IRutil::isYes(ans)) { 
         andf->addConjunct(chooseCreatedFilter()); 
         ccout << "Add another conjunct? (y/n) "; 
         loggedRead(ans); 
         ans = IRutil::trim(ans); 
      } 
      outf = andf; 
      break; 
    case OR_FILTER: 
      orf = new OrFilter(name); 
      ans = "yes"; 
      ccout << "Define or load filter disjuncts, " << EnumMenu::MORE_CHOICE 
            << " to define new:" << endl; 
      while (IRutil::isYes(ans)) { 
         orf->addDisjunct(chooseCreatedFilter()); 
         ccout << "Add another disjunct? (y/n) "; 
         loggedRead(ans); 
         ans = IRutil::trim(ans); 
      } 
      outf = orf; 
      break; 
    case PLAYER_IS: 
      ccout << "Enter player surname (build AndFilter to match separate " 
            << "parts):\n"; 
      loggedRead(item,false); 
      item = IRutil::trim(item); 
      outf = new PlayerFilter(item,name); 
      break; 
    case PLAYER_IS_ONE_OF: 
      porf = new PlayerOrFilter(name); 
      ccout << "Enter players, followed by . :" << endl; 
      loggedRead(item,false); 
      item = IRutil::trim(item); 
      while (item.size() > 0 && item[0] != '.') { 
         porf->addPlayer(item); 
         loggedRead(item,false); 
         item = IRutil::trim(item); 
      } 
      outf = porf; 
      break; 
    case PLAYER_IS_ON_MOVE: 
      ccout << "Enter player surname (build AndFilter to match separate " 
            << "parts):\n"; 
      loggedRead(item,false); 
      item = IRutil::trim(item); 
      outf = new PlayerToMoveFilter(item,name); 
      break; 
    case PLAYER_ON_MOVE_IS_ONE_OF: 
      porf = new PlayerOrToMoveFilter(name); 
      ccout << "Enter players, followed by . :" << endl; 
      loggedRead(item,false); 
      item = IRutil::trim(item); 
      while (item.size() > 0 && item[0] != '.') { 
         porf->addPlayer(item); 
         loggedRead(item,false); 
         item = IRutil::trim(item); 
      } 
      outf = porf; 
      break; 
    case ON_MOVE_FACING: 
      ccout << "Enter player surname (build AndFilter to match separate " 
            << "parts):\n"; 
      loggedRead(item,false); 
      item = IRutil::trim(item); 
      outf = new OpponentToMoveFilter(item,name); 
      break; 
    case ON_MOVE_FACING_ONE_OF: 
      porf = new OpponentOrToMoveFilter(name); 
      ccout << "Enter players, followed by . :" << endl; 
      loggedRead(item,false); 
      item = IRutil::trim(item); 
      while (item.size() > 0 && item[0] != '.') { 
         porf->addPlayer(item); 
         loggedRead(item,false); 
         item = IRutil::trim(item); 
      } 
      outf = porf; 
      break; 
    case WHITE_IS: 
      ccout << "Enter player surname (build AndFilter to match separate " 
            << "parts):\n"; 
      loggedRead(item,false); 
      item = IRutil::trim(item); 
      outf = new PlayerWhiteFilter(item,name); 
      break; 
    case BLACK_IS: 
      ccout << "Enter player surname (build AndFilter to match separate " 
            << "parts):\n"; 
      loggedRead(item,false); 
      item = IRutil::trim(item); 
      outf = new PlayerBlackFilter(item,name); 
      break; 
    case EVENT_IS: 
      ccout << "Enter word in event name (build AndFilter to match separate " 
            << "parts):\n"; 
      loggedRead(item,false); 
      item = IRutil::trim(item); 
      outf = new EventFilter(item,name); 
      break; 
    case DATE_IS: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter date in exact Arena (Euro) format yyyy.mm.dd: "; 
         loggedRead(item,false); 
         item = IRutil::trim(item); 
         entering = !compareMenu->success(enumItem); 
         if (entering) { 
            cout << "Invalid DateFilter entry, please try again.\n"; 
         } 
      } 
      outf = new DateFilter(COMPARE(enumItem), 
                            IRutil::SimpleDate(item, IRutil::ARENA_FORMAT), 
                            name); 
      break; 
    case EVENT_DATE_IS:
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter date in exact Arena (Euro) format yyyy.mm.dd: ";
         loggedRead(item,false);
         item = IRutil::trim(item);
         entering = !compareMenu->success(enumItem);
         if (entering) {
            cout << "Invalid EventDateFilter entry, please try again.\n";
         }
      }
      outf = new EventDateFilter(COMPARE(enumItem),
                                 IRutil::SimpleDate(item, IRutil::ARENA_FORMAT),
                                 name);
      break;
    case YEAR_IS: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter year: "; 
         loggedRead(item,false); 
         item = IRutil::trim(item); 
         entering = !compareMenu->success(enumItem); 
         if (entering) { 
            cout << "Invalid YearFilter entry, please try again.\n"; 
         } 
      } 
      outf = new YearFilter(COMPARE(enumItem), atoi(item.c_str()), name); 
      break; 
    case WHITE_ELO:
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter pivotal Elo for White: ";
         loggedRead(intItem,false);
         entering = !compareMenu->success(enumItem);
         if (entering) {
            cout << "Invalid EloWhite entry, please try again.\n";
         }
      }
      outf = new WhiteEloFilter(COMPARE(enumItem),intItem,name);
      break;
    case BLACK_ELO:
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter pivotal Elo for Black: ";
         loggedRead(intItem,false);
         entering = !compareMenu->success(enumItem);
         if (entering) {
            cout << "Invalid EloBlack entry, please try again.\n";
         }
      }
      outf = new BlackEloFilter(COMPARE(enumItem),intItem,name);
      break;
    case PLAYER_ELO:
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter pivotal Elo for player to move: ";
         loggedRead(intItem,false);
         entering = !compareMenu->success(enumItem);
         if (entering) {
            cout << "Invalid PlayerElo entry, please try again.\n";
         }
      }
      outf = new PlayerEloFilter(COMPARE(enumItem),intItem,name);
      break;
    case ELO_DIFF:
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter pivotal value of Elo minus opponent's Elo: ";
         loggedRead(intItem,false);
         entering = !compareMenu->success(enumItem);
         if (entering) {
            cout << "Invalid EloDiff entry, please try again.\n";
         }
      }
      outf = new EloDiffFilter(COMPARE(enumItem),intItem,name);
      break;
    case ELO_DIFF_WITHIN:
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter pivotal absolute value of Elo difference: ";
         loggedRead(intItem,false);
         entering = !compareMenu->success(enumItem);
         if (entering) {
            cout << "Invalid EloDiffWithin entry, please try again.\n";
         }
      }
      outf = new EloDiffWithinFilter(COMPARE(enumItem),intItem,name);
      break;
    case EVAL_WHITE: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter pivotal eval to White: "; 
         loggedRead(floatItem,false); 
         entering = !compareMenu->success(enumItem); 
         if (entering) { 
            cout << "Invalid EvalWhite entry, please try again.\n"; 
         } 
      } 
      outf = new EvalWhiteFilter(COMPARE(enumItem),floatItem,name); 
      break; 
    case PREV_EVAL_WHITE: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter pivotal eval to White: "; 
         loggedRead(floatItem,false); 
         entering = !compareMenu->success(enumItem); 
         if (entering) { 
            cout << "Invalid PrevEvalWhite entry, please try again.\n"; 
         } 
      } 
      outf = new PrevEvalWhiteFilter(COMPARE(enumItem),floatItem,name); 
      break; 
    case EVAL_WITHIN: 
      ccout << "Enter nonnegative bound for absolute eval: "; 
      loggedRead(floatItem,false); 
      ccout << "Enter applicable depth, 0 for turn max: ";
      loggedRead(intItem,false);
      ccout << "Import norm factors from focus trial'sscale? ";
      loggedRead(ans);
      ans = IRutil::trim(ans);
      if (IRutil::isYes(ans)) {
         nf = focusTrial->getScale()->getNormFactors();
      }
      outf = new EvalWithinFilter(floatItem,name,intItem,nf); 
      break; 
    case PREV_EVAL_WITHIN: 
      ccout << "Enter nonnegative bound for absolute eval: "; 
      loggedRead(floatItem,false); 
      ccout << "Enter applicable depth, 0 for turn max: ";
      loggedRead(intItem,false);
      ccout << "Import norm factors from focus trial'sscale? ";
      loggedRead(ans);
      ans = IRutil::trim(ans);
      if (IRutil::isYes(ans)) {
         nf = focusTrial->getScale()->getNormFactors();
      }
      outf = new PrevEvalWithinFilter(floatItem,name,intItem,nf); 
      break; 
    case NEXT_EVAL_WITHIN:
      ccout << "Enter nonnegative bound for absolute eval: ";
      loggedRead(floatItem,false);
      ccout << "Enter applicable depth, 0 for turn max: ";
      loggedRead(intItem,false);
      ccout << "Import norm factors from focus trial'sscale? ";
      loggedRead(ans);
      ans = IRutil::trim(ans);
      if (IRutil::isYes(ans)) {
         nf = focusTrial->getScale()->getNormFactors();
      }
      outf = new NextEvalWithinFilter(floatItem,name,intItem,nf);
      break;
    case TURN_NO: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter move number: "; 
         loggedRead(intItem,false); 
         entering = !(compareMenu->success(enumItem) && intItem >= 1); 
         if (entering) { 
            cout << "Invalid MoveNo entry, please try again.\n"; 
         } 
      } 
      outf = new TurnNoFilter(COMPARE(enumItem),intItem,name); 
      break; 
    case NUM_LEGAL_MOVES: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter number of legal moves: "; 
         loggedRead(intItem,false); 
         entering = !(compareMenu->success(enumItem) && intItem >= 1); 
         if (entering) { 
            cout << "Invalid NumLegalMoves entry, please try again.\n"; 
         } 
      } 
      outf = new NumLegalMovesFilter(COMPARE(enumItem),intItem,name); 
      break; 
    case DELTA_I: 
      entering = true; 
      while (entering) { 
         ccout << "Enter index in " << 0 << ".." << IRutil::NCUTOFF - 1 << ": "; 
         loggedRead(intItem,false); 
         enumItem = compareMenu->readChoice(); 
         entering = !(compareMenu->success(enumItem) && intItem >= 0 
                      && intItem <= IRutil::NCUTOFF - 1); 
         if (entering) { 
            cout << "Invalid DeltaIs entry, please try again.\n"; 
         } 
      } 
      ccout << "Enter minimum desired magnitude of delta["<<intItem<<"]: "; 
      loggedRead(floatItem,false); 
      outf = new DeltaIFilter(COMPARE(enumItem),floatItem,intItem,name); 
      break; 
    case DELTA_DIFF: 
      entering = true; 
      while (entering) { 
         ccout << "Enter index1 in " << 0 << ".." << IRutil::NCUTOFF-1 << ": "; 
         loggedRead(intItem,false); 
         ccout << "Enter index2 in " << 0 << ".." << IRutil::NCUTOFF-1 
               << ": "; 
         loggedRead(intItem2,false); 
         enumItem = compareMenu->readChoice(); 
         entering = !(compareMenu->success(enumItem) && intItem >= 0 
                      && intItem2 >= 0 && intItem <= IRutil::NCUTOFF-1 
                      && intItem2 <= IRutil::NCUTOFF-1); 
         if (entering) { 
            cout << "Invalid DeltaDiff entry, please try again.\n"; 
         } 
      } 
      ccout << "Enter minimum desired magnitude of delta(" << intItem 
               << ") - delta(" << intItem2 << "): "; 
      loggedRead(floatItem,false); 
      outf = new DeltaDiffFilter(COMPARE(enumItem),floatItem,intItem,intItem2, 
                                 name); 
      break; 
    case SECOND_DELTA: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter pivotal magnitude of delta[1]: "; 
         loggedRead(floatItem,false); 
         entering = !(compareMenu->success(enumItem) && floatItem >= 0.0); 
         if (entering) { 
            cout << "Invalid SecondDelta entry, please try again.\n"; 
         } 
      } 
      outf = new SecondDeltaFilter(COMPARE(enumItem),floatItem,name); 
      break; 
    case DELTA_N: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter pivotal magnitude of delta[" << IRutil::NCUTOFF  
               << "]: "; 
         loggedRead(floatItem,false); 
         entering = !(compareMenu->success(enumItem) && floatItem >= 0); 
         if (entering) { 
            cout << "Invalid LastDeltaIs entry, please try again.\n"; 
         } 
      } 
      outf = new DeltaNFilter(COMPARE(enumItem),floatItem,name); 
      break; 
    case REP_COUNT:
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter count to keep: ";
         loggedRead(intItem,false);
         ccout << "Use RepLines? (y/n) ";
         ans = "0";
         loggedRead(ans);
         ans = IRutil::trim(ans);
         entering = (!(compareMenu->success(enumItem) && ans != "0"));
         if (entering) {
            cout << "Invalid RepCount entry, please try again.\n";
         }
      }
      outf = new RepCountFilter(COMPARE(enumItem), intItem, IRutil::isYes(ans), name);
      break;
    case PLAYED_MOVE_INDEX: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter 0-based pivotal index: "; 
         loggedRead(intItem, false); 
         entering = !(compareMenu->success(enumItem) && intItem >= 0.0 
                      && intItem <= IRutil::NCUTOFF); 
         if (entering) { 
            cout << "Invalid PlayedMoveIndex entry, please try again.\n"; 
         } 
      } 
      outf = new PlayedMoveIndexFilter(COMPARE(enumItem),intItem,name); 
      break; 
    case PLAYED_MOVE_IS_SELECTED:
      ms = chooseCreatedSelector(); //handles all I/O
      outf = new PlayedMoveSelectedFilter(ms);
      break;
    case ENGINE_MOVE_IS_SELECTED:
      ms = chooseCreatedSelector(); //handles all I/O
      outf = new EngineMoveSelectedFilter(ms);
      break;
    case EQUAL_TOP_MOVE_IS_SELECTED:
      ms = chooseCreatedSelector(); //handles all I/O
      outf = new EqualTopMoveSelectedFilter(ms);
      break;
    case SOME_MOVE_IS_SELECTED:
      ms = chooseCreatedSelector(); //handles all I/O
      outf = new SelectionNonemptyFilter(ms);
      break;
    case FALLOFF: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter threshold delta d.dd: "; 
         loggedRead(floatItem, false); 
         entering = !(compareMenu->success(enumItem) && floatItem >= 0.0); 
         if (entering) { 
            cout << "Invalid Falloff delta, please try again.\n"; 
         } 
      } 
      outf = new FalloffFilter(COMPARE(enumItem),floatItem,name); 
      break; 
    case WEIGHT: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter pivotal weight under current spec: "; 
         loggedRead(floatItem,false); 
         entering = !(compareMenu->success(enumItem) && floatItem >= 0); 
         if (entering) { 
            cout << "Invalid WeightFilter entry, please try again.\n"; 
         } 
      } 
      outf = new WeightFilter(focusTrial,true, 
                              focusTrial->getModel(),COMPARE(enumItem), 
                              floatItem,name); 
      break; 
    case PROB_I: 
      entering = true; 
      while (entering) { 
         enumItem = compareMenu->readChoice(); 
         ccout << "Enter index in " << 0 << ".." << IRutil::NCUTOFF << ": "; 
         loggedRead(intItem,false); 
         entering = !(compareMenu->success(enumItem) && intItem >= 0.0 
                      && intItem <= IRutil::NCUTOFF); 
         if (entering) { 
            cout << "Invalid ProbIs entry, please try again.\n"; 
         } 
      } 
      ccout << "Enter pivotal probability of selected move: "; 
      loggedRead(floatItem,false); 
      outf = new ProbIFilter(focusTrial,true, 
                             focusTrial->getModel(),COMPARE(enumItem), 
                             floatItem,intItem,name); 
      break; 
    default: 
      ccout << "Choice out of bounds or undecodable, clearing input" << endl; 
      outf = new FnFilter(&allowAll,name); 
      (*INP).clear(); 
      (*INP).ignore(numeric_limits<streamsize>::max(),'\n'); 
      break; 
   } 
   return outf; 
} 
 
void Ensemble::newFilters() { 
   bool entering = true; 
   int choice = filtersMenu->readChoice(); 
   while (entering) { 
      if (filtersMenu->success(choice) && choice != NO_FILTER) { 
         TurnFilter* tf = makeFilter(choice); 
         string name = tf->getName(); 
         if (filters->hasEntry(name)) { 
            if (filters->isStarred(name)) { 
               cout << "Filter already attached, skipping..." << endl; 
            } else { 
               cout << "Filter already exists, attaching it..." << endl; 
               filters->setStarred(name, true); 
               focusTrial->attachFilter((*filters)[name]); 
            } 
         } else { 
            addNewFilter(tf); 
            cout << "Added " + string(*tf) << endl; 
         } 
         if (usingCin()) { 
            cout << "Make another, or " << NO_FILTER << "/" 
                 << filtersMenu->nameOf(NO_FILTER) << " to stop and filter: "; 
         } 
         //loggedRead(choice,true);  //begin line for next choice/action 
         choice = filtersMenu->readChoice(false);  //does not re-display menu 
      } else if (choice == NO_FILTER) { 
         entering = false; 
//cerr << "Abt2reset...";
         reset(); 
//cerr << "didit." << endl;
      } else { 
         cout << "Invalid entry in newFilters, please try again..." << endl; 
         choice = filtersMenu->readChoice();   //re-displays menu 
      } 
   } 
   loggedWrite("",true);  //ends the line. 
} 
 
 
void Ensemble::addNewFilter(TurnFilter* tf) { 
   filters->addItem(tf,"",false,true); //CLASS INV: all loaded filters starred 
   focusTrial->attachFilter(tf); 
} 
 
void Ensemble::addTrialSpec(TrialSpec ts) { 
   //does not overwrite focus trial's spec.  NOT on main menu, not logged 
   specs->addItem(ts,"",false,false);    //hence not starred 
} 

void Ensemble::attachFilters() { 
   bool entering = true; 
   bool showMenu = true; 
   string ans, name; 
   while (entering) { 
      int choice = filters->readChoice(showMenu); 
      if (filters->success(choice)) { 
         name = filters->nameOf(choice); 
         if (!filters->isStarred(choice)) { 
            filters->setStarred(name,true); 
            focusTrial->attachFilter((*filters)[name]); 
         } else { 
            cout << "Filter already attached." << endl; 
         } 
         showMenu = false; 
      } else if (choice == EnumMenu::MORE_CHOICE) { 
         if (hiddenFilters->empty()) { 
            cout << "No hidden filters to choose from." << endl; 
         } 
         int choice2 = hiddenFilters->readChoice(); 
         if (hiddenFilters->success(choice2)) { 
            name = hiddenFilters->nameOf(choice2); 
            TurnFilter* tf = (*hiddenFilters)[name]; 
            hiddenFilters->removeItem(name); 
            addNewFilter(tf); 
         } else if (choice2 == EnumMenu::CANCEL_CHOICE) { 
            cout << "Canceling load of hidden filter..." << endl; 
         } else if (choice2 == EnumMenu::MORE_CHOICE) { 
            newFilters(); 
         } else { 
            cout << "Invalid choice or hidden filter not found." << endl; 
            //pop back to loading active filters, not total cancel 
            //this is consistent with the case of no hidden filters. 
         } 
         showMenu = true;  //need to show active filters again 
      } else if (choice == EnumMenu::CANCEL_CHOICE) { 
         entering = false; 
      } else {  
         cout << "Invalid choice in attachFilters, please try again." << endl; 
         showMenu = false; 
      } 
      if (entering) { 
         if (usingCin()) { 
            cout << "Attach another? (y/n) "; 
            if (choice == EnumMenu::MORE_CHOICE) { 
               cout << "(will show active filters first again) "; 
            } 
         } 
         loggedRead(ans); 
         entering = IRutil::isYes(ans); 
      } 
   } 
   reset(); 
   loggedWrite("",true);  //logs a newline 
} 
 
 
void Ensemble::detachFilters() { 
   int choice = filters->readChoice(); 
   string ans = "yes"; 
   bool entering = true; 
   while (entering) { 
      if (filters->success(choice)) { 
         if (filters->isStarred(choice)) { 
            string name = filters->nameOf(choice); 
            filters->setStarred(name,false); 
            focusTrial->detachFilter((*filters)[name]); 
         } else { 
            cout << "Filter already detached." << endl; 
         } 
      } else if (choice == EnumMenu::CANCEL_CHOICE) { 
         break;  //jumps while-loop 
      } else { 
         cout << "Invalid choice." << endl; 
      } 
      if (usingCin()) { 
         cout << "Detach another? (y/n) "; 
      } 
      loggedRead(ans); 
      entering = IRutil::isYes(ans); 
      if (entering) { choice = filters->readChoice(false); } //suppress menu 
   } 
   reset(); 
   loggedWrite("",true); 
} 

void Ensemble::hideFilter(TurnFilter* tf) {
   hiddenFilters->addItem(tf, "", false, false);
}
 
void Ensemble::hideFilters() { 
   string ans = "yes"; 
   bool cancel = false; 
   int choice; 
   while (IRutil::isYes(ans) && filters->size() > 0) { 
      choice = filters->readChoice(); 
      if (filters->success(choice)) { 
         if (filters->isStarred(choice)) {     // (specs->nameOf(choice))) { 
            cout << "Can't hide active filter---please detach it first." 
                 << endl; 
         } else { 
            string name = filters->nameOf(choice); 
            hiddenFilters->addItem((*filters)[name], "", false, false); 
            filters->removeItem(name); 
         } 
      } else if (choice == 0) { 
         choice = 1; 
         while (filters->success(choice)) { 
            string name = filters->nameOf(choice); 
            hideFilter((*filters)[name]); 
            filters->removeItem(name); 
         } 
      } else { 
         cout << "Invalid choice, returning..."; 
         cancel = true; 
      }   
      if (usingCin() && !cancel) {  
         cout << "Hide another? (y/n) ";  
      } 
      loggedRead(ans); 
   }                         
   if ((cancel || filters->size() == 0) && usingCin()) { 
      cout << "No more filters to hide!" << endl; 
   }    
} 

/*-------------
   enumSelectorsMenu {
       NEW_SELECTOR,
       TOGGLE_SELECTOR,
       NO_SELECTOR,
       EXISTING_SELECTOR,
       FN_SELECTOR,
       NOT_SELECTOR,
       AND_SELECTOR,
       OR_SELECTOR,
       MAP_SELECTOR,
       NUM_SELECTOR_CHOICES
   }
   void newSelectors();

   void addSelector(const MoveSelector* ms);
   void setSelector(MoveSelector* ms);

   void toggleOneSelector() const;
   
   MoveSelector* chooseCreatedSelector() const;

   MoveSelector* makeSelector(int choice) const;

   MoveSelector* mapSelectorInFile(const MoveSelector* ms) const;
*/
void Ensemble::newSelectors() {
   bool entering = true; 
   int choice = selectorsMenu->readChoice();  //since reading from enumMenu
   while (entering) { 
      if (selectorsMenu->success(choice) && choice != NO_SELECTOR) { 
         //TurnFilter* tf = makeFilter(choice);
         MoveSelector* ms = makeSelector(choice); 
         string name = ms->getName(); 
         if (selectors->hasEntry(name)) { 
            if (selectors->isStarred(name)) { 
               cout << "Selector already active, skipping..." << endl; 
            } else { 
               cout << "Selector already exists, activating it..." << endl; 
               selectors->setStarred(name, true);  //!!!fix to toggle for now, add later
               focusTrial->setSelector((*selectors)[name]); 
            } 
         } else { 
            justAddSelector(ms); //Does not star it
            selectors->setStarred(ms->getName(), true);
            focusTrial->addSelector(ms);
            cout << "Added " + string(*ms) << endl; 
         } 
         if (usingCin()) { 
            cout << "Make another, or " << NO_SELECTOR << "/" 
                 << selectorsMenu->nameOf(NO_SELECTOR) << " to stop: "; 
         } 
         //loggedRead(choice,true);  //begin line for next choice/action 
         choice = selectorsMenu->readChoice(false);  //does not re-display menu 
      } else if (choice == NO_SELECTOR) { 
         entering = false; 
      } else { 
         cout << "Invalid entry " << choice << " in newSelectors, please try again..." << endl; 
         choice = selectorsMenu->readChoice();   //re-displays menu 
      } 
   } 
   loggedWrite("",true);  //ends the line. 
} 

void Ensemble::addSelector(MoveSelector* ms) {
   selectors->addItem(ms, "", false, true);  //stars it
   focusTrial->addSelector(ms);
}

void Ensemble::justAddSelector(MoveSelector* ms) {
   selectors->addItem(ms, "", false, false);  //not starred or even set
}

void Ensemble::setSelector(MoveSelector* ms) {
   //focusTrial->setSelector(ms);
   focusTrial->addSelector(ms);
   string name = ms->getName();
   //selectors->clearStars();
   selectors->setStarred(name, true);
}

void Ensemble::toggleOneSelector() { 
   bool entering = true; 
   bool showMenu = true; 
   string ans, name; 
   while (entering) { 
      int choice = selectors->readChoice(showMenu); 
      if (selectors->success(choice)) { 
         name = selectors->nameOf(choice); 
         if (!selectors->isStarred(choice)) { 
            selectors->clearStars();
            selectors->setStarred(name,true); 
            //focusTrial->setSelector((*selectors)[name]); 
            focusTrial->clearSelectors();
            focusTrial->addSelector((*selectors)[name]);
         } else { 
            cout << "Selector already active." << endl; 
         } 
         showMenu = false; 
         entering = false;
      } else if (choice == EnumMenu::MORE_CHOICE) { 
         newSelectors();   //does set the selector made
         showMenu = true;  //need to show active selectors again 
      } else if (choice == EnumMenu::CANCEL_CHOICE) { 
         entering = false; 
      } else {  
         cout << "Invalid choice in toggleOneSelector, please try again." << endl; 
         showMenu = false; 
      } 
   } 
   //reset(); 
   loggedWrite("",true);  //logs a newline 
} 

void Ensemble::toggleSelectors() {
   bool entering = true;
   bool showMenu = true;
   string ans, name;
   while (entering) {
      int choice = selectors->readChoice(showMenu, true);
      if (choice == GoMenu::GO_CHOICE) {
         focusTrial->clearSelectors();
         for (int i = 0; i < selectors->size(); i++) {
            if (selectors->isStarred(i)) {
               focusTrial->addSelector((*selectors)[selectors->nameOf(i)]);
            }
         }
         entering = false;
      } else if (selectors->success(choice)) {
         name = selectors->nameOf(choice);
         if (selectors->isStarred(choice)) {
            selectors->setStarred(name,false);
         } else {
            selectors->setStarred(name,true);
         }
      } else if (choice == EnumMenu::MORE_CHOICE) {
         newSelectors();   //does star the selector made
         showMenu = true;  //need to show active selectors again
      } else if (choice == EnumMenu::CANCEL_CHOICE) {
         entering = false;
      } else {
         cout << "Invalid choice in toggleSelectors, please try again." << endl;
         showMenu = false;
      }
   }
   loggedWrite("",true);  //logs a newline
}

MoveSelector* Ensemble::chooseCreatedSelector() const {
   int i = selectors->readChoice();
   while (!(selectors->success(i) || i == EnumMenu::CANCEL_CHOICE
            || i == EnumMenu::MORE_CHOICE)) {
      cerr << "Need valid selector choice, or " << EnumMenu::MORE_CHOICE
           << "/" << selectors->info->MORE_NAME << " to define new, "
           << EnumMenu::CANCEL_CHOICE
           << "/" << selectors->info->CANCEL_NAME << " to cancel." << endl;
      i = selectors->readChoice();
   }
   if (selectors->success(i)){
      string name = selectors->nameOf(i); //selectors->setStarred(name,true);
      return (*selectors)[name];
   } else if (i == EnumMenu::MORE_CHOICE) {
      return makeSelector(selectorsMenu->readChoice());
   } else {
      cout << "Cancel---returning trivial-true selector..." << endl;
      MoveSelector* outf = new OmniSelector();
      return outf;
   }
}

MoveSelector* Ensemble::makeSelector(int choice) const {
   IRutil::nullstream nullstr;
   ostream& ccout = usingCin() ? cout : nullstr;
   COMPARE comp;
   string name;
   string item,ans;
   int intItem, intItem2, enumItem;
   double floatItem;
   bool entering;
   MoveSelector* outs;
   MoveSelector* ms;
   AndSelector* ands;
   OrSelector* ors;
   bool exc,playerView,normalize;

   if (choice >= 2) {
      ccout << "Name the new selector itself: ";
      loggedRead(name,false);
      name = IRutil::trim(name);
      ccout << "Exclude from sample in case of null move-set? (y/n): ";
      loggedRead(ans,false);
      ans = IRutil::trim(ans);
      exc = IRutil::isYes(ans);
   }

   switch(choice) {
    case NO_SELECTOR:
      outs = new OmniSelector();
      break;
    case EXISTING_SELECTOR:
      outs = chooseCreatedSelector();
      break;
    case FN_SELECTOR:
      cout << "Only one implemented so far is trivial-true, sorry." << endl;
      outs = new OmniSelector();
      break;
   case NOT_SELECTOR:
      ccout << "Choose another selector, or " << EnumMenu::MORE_CHOICE
            << " to define new:" << endl;
      outs = new NotSelector(chooseCreatedSelector(), name, exc);
      break;
   case AND_SELECTOR:
      ands = new AndSelector(name, exc);
      ans = "yes";
      ccout << "Define or load selector conjuncts, or " << EnumMenu::MORE_CHOICE
            << " to define new:" << endl;
      while (IRutil::isYes(ans)) {
         ands->addConjunct(chooseCreatedSelector());
         ccout << "Add another conjunct? (y/n) ";
         loggedRead(ans);
         ans = IRutil::trim(ans);
      }
      outs = ands;
      break;
    case OR_SELECTOR:
      ors = new OrSelector(name, exc);
      ans = "yes";
      ccout << "Define or load selector disjuncts, " << EnumMenu::MORE_CHOICE
            << " to define new:" << endl;
      while (IRutil::isYes(ans)) {
         ors->addDisjunct(chooseCreatedSelector());
         ccout << "Add another disjunct? (y/n) ";
         loggedRead(ans);
         ans = IRutil::trim(ans);
      }
      outs = ors;
      break;
    case MAP_SELECTOR:
      ccout << "Choose selector to apply, or " << EnumMenu::MORE_CHOICE
            << " to define new:" << endl;
      ms = chooseCreatedSelector();
      outs = mapSelectorInFile(name, ms);
      break;
    case MOVE_EVAL_SELECTOR:
      ccout << "Define eval from Player's not White's view? (y/n): ";
      loggedRead(ans,false);
      playerView = IRutil::isYes(ans);
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter pivotal eval of selected move: ";
         loggedRead(floatItem, false);
         ccout << "Enter depth, 0 for turn max: ";
         loggedRead(intItem,false);
         entering = !(compareMenu->success(enumItem) && intItem >= 0);
         if (entering) {
            cout << "Invalid depth entry, please try again.\n";
         }
      }
      outs = new MoveEvalSelector(COMPARE(enumItem), floatItem, intItem, playerView, exc, name);
      break;

    case MOVE_RAW_DELTA_SELECTOR:
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter pivotal delta of selected move in p.nn units: ";
         loggedRead(floatItem, false);
         ccout << "Enter depth, 0 for turn max: ";
         loggedRead(intItem,false);
         entering = !(compareMenu->success(enumItem) && intItem >= 0);
         if (entering) {
            cout << "Invalid depth entry, please try again.\n";
         }
      }
      outs = new MoveRawDeltaSelector(COMPARE(enumItem), floatItem, intItem, exc, name);
      break;
    case MOVE_RAW_SWING_SELECTOR:
      ccout << "Normalize swing by number of depths? (y/n): ";
      loggedRead(ans,false);
      normalize = IRutil::isYes(ans);
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter pivotal swing of selected move: ";
         loggedRead(floatItem, false);
         ccout << "Enter depth, 0 for turn max: ";
         loggedRead(intItem,false);
         entering = !(compareMenu->success(enumItem) && intItem >= 0);
         if (entering) {
            cout << "Invalid depth entry, please try again.\n";
         }
      }
      outs = new MoveRawSwingSelector(COMPARE(enumItem), floatItem, intItem, normalize, exc, name);
      break;
    case MOVE_SCALED_SWING_SELECTOR:
      ccout << "Normalize swing by number of depths? (y/n): ";
      loggedRead(ans,false);
      ans = IRutil::trim(ans);
      normalize = IRutil::isYes(ans);
      entering = true;
      while (entering) {
         enumItem = compareMenu->readChoice();
         ccout << "Enter pivotal swing of selected move: ";
         loggedRead(floatItem, false);
         ccout << "Enter depth, 0 for turn max: ";
         loggedRead(intItem,false);
         entering = !(compareMenu->success(enumItem) && intItem >= 0);
         if (entering) {
            cout << "Invalid depth entry, please try again.\n";
         }
      }
      outs = new MoveScaledSwingSelector(focusTrial, COMPARE(enumItem), floatItem, intItem, 
                                         normalize, exc, name);
      break;

    default:
      ccout << "Choice out of bounds or undecodable, clearing input" << endl;
      outs = new OmniSelector();
      (*INP).clear();
      (*INP).ignore(numeric_limits<streamsize>::max(),'\n');
      break;
   }
   return outs;
}


MoveSelector* Ensemble::mapSelectorInFile(const string& name, const MoveSelector* ms) const {
   MappedMoveSelector* outs;
   IRutil::nullstream nullstr;
   ostream& ccout = usingCin() ? cout : nullstr;
   bool entering = true;
   int count = 0;
   string fileName;
   ccout << "Enter file name: ";
   while (entering) {
      loggedRead(fileName, true); //ends line
      fileName = IRutil::trim(fileName);
      ifstream file(fileName.c_str());
      if (!file.is_open()) {
         ccout << "Cannot read the input file, please try again: ";
      } else {
         list<TurnInfo*>* myTurns = readInputFile(file, false, true);
         outs = new MappedMoveSelector(name+":"+fileName, ms->excludesTurnIfEmpty());
         list<TurnInfo*>::const_iterator citr = myTurns->begin();
         list<TurnInfo*>::const_iterator citre = myTurns->end();
         while (citr != citre) {
            TurnInfo* turn = *citr++;
            vector<Move> moves;
            vector<Move>::const_iterator cmit = turn->legalMoves->begin();
            while (cmit != turn->legalMoves->end()) {
               Move mv = *cmit++;
               if (ms->apply(turn, mv)) {
                  moves.push_back(mv);
               }
            }
            outs->addTurn(turn, moves);
            count++;
            if (count % 1000 == 0) {
               ccout << "Mapped " << count << " turns." << endl;
            }
         }
	 entering = false;
         citr = myTurns->begin();
         citre = myTurns->end();
         while (citr != citre) {
            TurnInfo* t = *citr++;
            delete(t);
         }
         delete(myTurns);
      }
   }
   ccout << "Created map of size " << outs->mapSize() << endl;
   return outs;
}


 
 
void Ensemble::runDemo(int choice) { 
   cout << "If you *re-run* a demo, you may ignore \"duplicate entry\" " 
        << "messages." << endl << endl; 
   switch(choice) { 
    case Demos::ELISTA_DEMO: 
      Demos::elistaDemo(*this); 
      break; 
    case Demos::SAN_LUIS_MEXICO_DEMO: 
      Demos::sanLuisMexicoDemo(*this); 
      break; 
    case Demos::SWING_DEMO: 
      Demos::swingDemo(*this); 
      break; 
    case Demos::DEMORALIZATION_DEMO: 
      Demos::demoralizationDemo(*this); 
      break; 
    default: 
      Demos::elistaDemo(*this); 
      break; 
   } 
} 
 
 
void Ensemble::doMainMenuItem(int choice) { //INV: focusTrial is never null 
   IRutil::nullstream nullstr; 
   ostream& ccout = usingCin() ? cout : nullstr; 
   bool entering = true; 
   string ans = "";
   string fileName = "";
   string matchString = ""; 
   ifstream myfile; 
   int subChoice = 0; 
   //list<TurnInfo*>::const_iterator tit;
   //list<TurnInfo*>::const_iterator tite;
   //list<GameInfo*>::const_iterator git;
   //list<GameInfo*>::const_iterator gite;

 
   ofstream zscoref("zscores.txt", ios::app); 
   ofstream zscoread("zASD.txt", ios::app);
   ofstream zscoreEV("zscoreEV.txt", ios::app);
   ofstream zscoreSel("zscoreSel.txt", ios::app);   
 
   switch(choice) { 
    case NEW_TRIAL: 
      //newTrial(); 
      //changeTrial();
      //ccout << "Added and loaded " << string(*focusTrial) << endl; 
      ccout << "Feature disabled: please use 2 Change Trial instead." << endl;
      break; 
    case CHANGE_TRIAL: 
      //loadNamedTrial(); 
      changeTrial();
      ccout << "Trial now " << string(*focusTrial) << endl;
      break; 
    case SHOW_TRIAL: 
      for (vector<ostream*>::const_iterator it = outs->begin(); 
           it != outs->end(); it++) { 
         showActiveTrial(**it); 
      } 
      ccout << "Show filtered tuples? (screen only if <= 1000) (y/n) "; 
      loggedRead(ans,false); 
      if (IRutil::isYes(ans)) { 
         for (vector<ostream*>::const_iterator it = outs->begin(); 
              it != outs->end(); it++) { 
            if ((*it) != &cout || focusTrial->numDecisions() <= 1000) { 
               //(**it) << "Tuples:" << endl << focusTrial->tuplesToString()  
               (**it) << "Turns:" << endl << focusTrial->decisionsToString()
                      << endl; 
            } 
         } 
      } else {
         ccout << endl;
      } 
      break; 
    case LOAD_DELTA_SCALE: 
      ccout << "Apply to Reference Trial too? (y/n) ";
      loggedRead(ans,false);
      loadDeltaScale(IRutil::isYes(ans)); 
      break; 
    case ADD_TURNS: 
      addTurns(); 
      ccout << "Current trial now---" << string(*focusTrial) << endl; 
      break; 
    case CLEAR_TURNS: 
      clearTurns();
      break; 
    case NEW_FILTER: 
      newFilters();  //includes a reset 
      break; 
    case ATTACH_FILTERS: 
      attachFilters(); 
      break; 
    case DETACH_FILTERS: 
      detachFilters(); 
      break; 
    case CLEAR_FILTERS: 
      clearFilters();  //includes a reset of filtered tuples 
      break; 
    case HIDE_FILTERS: //allows hiding attached ones and so does reset too 
      hideFilters(); 
      break; 
    case NEW_SELECTOR:
      newSelectors();
      break;
    case TOGGLE_SELECTORS:
      toggleSelectors();
      break;
    case NEW_TRIAL_SPEC: 
      { 
         TrialSpec ts = makeTrialSpec(); 
         IRfun::WEIGHTS wmc = ts.weightMethodChoice; 
         specs->clearStars(); 
         specs->addItem(ts,"",false,true);  //*s it 
         focusTrial->setSpec(ts); 
         referenceTrial->setSpec(ts); 
cerr << "Doing perftest on reference trial...";
         PerfData rpf = referenceTrial->perfTest(false,false); 
         double asd = rpf.scaledFalloffWtd.projectedFreq;
         double ird = IRfun::ipr(asd,wmc); 
cerr << "done." << endl;
         int ir = (int)(ird + 0.5); 
         ccout << "Created " << string(focusTrial->getSpec()) << endl 
               << "with Intrinsic Rating " << ir << " from ASD = " << asd << endl; 
      } 
      break; 
    case LOAD_TRIAL_SPEC: 
      { 
         loadNamedTrialSpec(); 
         TrialSpec ts = focusTrial->getSpec(); 
         IRfun::WEIGHTS wmc = ts.weightMethodChoice; 
         referenceTrial->setSpec(ts); 
cerr << "Doing perftest on reference trial...";
	 PerfData rpf = referenceTrial->perfTest(false,false); 
	 double asd = rpf.scaledFalloffWtd.projectedFreq;
         double ird = IRfun::ipr(asd,wmc);
cerr << "done." << endl;
         int ir = (int)(ird + 0.5); 
         ccout << "Loaded " << string(focusTrial->getSpec()) << endl 
               << "with Intrinsic Rating " << ir << " from ASD = " << asd << endl; 
      } 
      break; 
    case HIDE_SPECS: 
      hideSpecs(); 
      break; 
/*
    case PERCFIT_TRIAL: 
      if (pTurns->empty()) { 
         cout << "Empty data: please add game turns." << endl; 
      } else { 
         focusTrial->percFit(outs); 
      } 
      break; 
*/
    case RUN_FIT: 
      runFit(); 
      break; 
    case PERF_TEST: 
      if (pTurns->empty()) { 
         cout << "Empty data: please add game turns." << endl;  //not ccout 
      } else { 
         runPerfTest();
      }
      break;

/*
    case PERF_TEST_ALL: 
      if (pTurns->empty()) { 
         cout << "Empty data: please add game turns." << endl;   //not ccout 
      } else { 
         bool uw = false; 
         bool tn = true; 
         ccout << "Use focus spec and treat miss as Move " 
               << IRutil::NCUTOFF + 1 << "? (y/n) "; 
         loggedRead(ans,false); 
         ans = IRutil::trim(ans); 
         if (!IRutil::isYes(ans)) { 
            ccout<<"Override weighting function to use unit weights? (y/n) "; 
            loggedRead(ans,false); 
            ans = IRutil::trim(ans); 
            uw = IRutil::isYes(ans); 
            ccout << "Treat played move not in top " << IRutil::NCUTOFF  
                  << " as Move " << (IRutil::NCUTOFF+1) << "? (y/n) "; 
            loggedRead(ans,true); 
            ans = IRutil::trim(ans); 
            tn = IRutil::isYes(ans); 
         } 
         TrialSpec currentSpec = focusTrial->getSpec(); 
         for (int i = 0; i < specs->size(); i++) { 
            TrialSpec ts = (*specs)[specs->nameOf(i)]; 
            focusTrial->setSpec(ts); 
            referenceTrial->setSpec(ts); 
            PerfData pf = focusTrial->perfTest(uw,tn); 
            string rept = pf.fullReport(); 
            for (vector<ostream*>::iterator it = outs->begin(); 
                 it != outs->end(); it++) { 
               (**it) << endl << IRutil::DASHES << endl 
                      << "Test using " << string(*focusTrial) << endl 
                      << IRutil::DASHES << endl << endl; 
               (**it) << rept; 
               (**it) << "Curve points:" << endl; 
               (**it) << focusTrial->showCurvePoints(0.25, 1.00); 
               (**it) << IRutil::DASHES << endl << endl; 
            } 
         } 
         focusTrial->setSpec(currentSpec); 
         referenceTrial->setSpec(currentSpec); 
         resetParamsMenu();
      } 
      break; 
*/
    case ADD_OUTPUT_FILE: 
      entering = true; 
      while (entering) { 
         if (usingCin()) { 
            outsMenu->showMenu(); 
            cout << "Name of new output file to append onto: "; 
         } 
         loggedRead(fileName,true);  //ends line 
         entering = !addOutputFile(fileName); 
      } 
      break; 
    case CLOSE_OUTPUT_FILE: 
      entering = true; 
      while (entering) { 
         subChoice = outsMenu->readChoice(); 
         if (outsMenu->success(subChoice)) { 
            entering = false; 
         } else if (subChoice == EnumMenu::CANCEL_CHOICE) { 
            break; 
         } else { 
            cout << "Invalid entry, please try again." << endl; 
         } 
      } 
      fileName = outsMenu->nameOf(choice); 
      closeOutputFile(fileName); 
      break; 
    case READ_COMMANDS: 
      matchString = ""; 
      cout << "Name of input file with commands: ";    //NOT ccout 
      loggedRead(fileName,false);  //does not end line, writes 
      fileName = IRutil::trim(fileName); 
      myfile.open((const char*)fileName.c_str(),ios::in); 
      if (!myfile.is_open()) { 
         cout << "File not found, can re-select and try again." << endl; 
         return; 
      } //else 
      if (!usingCin()) { 
         cout << "Start from top of file? (y/n) "; 
         loggedReadString(ans,false,false); 
         if (!IRutil::isYes(ans)) { 
            cout << "Enter string to match in COMMENT line, no whitespace.\n"; 
            loggedReadString(matchString,true,true); 
         } 
      } 
      loggedWrite("",true);   //inserts endline 
      zscoref << "Next Test: " << endl; 
      zscoread << "Next AD Test: " << endl; 
      zscoreEV << "Next EV Test: " << endl;
      zscoreSel << "Next Selection Test: " << endl;
      zscoref.close(); 
      zscoread.close(); 
      zscoreEV.close();
      zscoreSel.close();
 
cerr << "Running commands now..." << endl;
      interactFromStream(&myfile,matchString); 
      break; 
/*
    case RUN_DEMO: 
      cout << "Demos splash output on your screen, and draw summaries from " 
           << "this output *only*." << endl << endl; 
      subChoice = demosMenu->readChoice(); 
      while (!(demosMenu->success(subChoice) 
               || subChoice == EnumMenu::CANCEL_CHOICE)) { 
         cout << "Please try again. " << endl; 
         subChoice = demosMenu->readChoice(); 
      } 
      if (demosMenu->success(subChoice)) { 
         runDemo(subChoice); 
      } 
      break; 
*/
    case QUIT: 
      keepGoing = false; 
      break; 
/*---------------------------------------------- 
    case EnumMenu::INVALID_CHOICE: 
      if (usingCin()) { 
         cout << "Invalid choice, please try again." << endl; 
      } else { 
         cerr << "Bad top-level menu choice, trying to recover..." << endl; 
      } 
      break; 
    case EnumMenu::CANCEL_CHOICE: 
      if (usingCin()) { 
         cout << "Cancel propagated to top level, did you meant to quit?\n"; 
      } else { 
         cerr << "Bad top-level menu choice, trying to recover..." << endl; 
      } 
      break; 
    case EnumMenu::STREAM_END_CHOICE: 
*///-------------------------------------------- 
    default: //shouldn't happen either---handled by caller interactFromStream() 
      if (choice != EnumMenu::STREAM_END_CHOICE) { 
         cout << "Could not execute your choice; please try again." << endl; 
      } 
      INP->clear(); 
      INP->ignore(numeric_limits<streamsize>::max(),'\n'); 
      break; 
   } 
} //end of implementation of class Ensemble 
 
 
#endif    //end of #ifndef __IR_ENSEMBLE_CPP__ 
 
 
 
//File-----------------------Demos.cpp--------------------------------------- 
 
#ifndef __IR_DEMOS_CPP__ 
#define __IR_DEMOS_CPP__ 

#ifndef __IR_DEMOS_H__
#include "Demos.h"
#endif    //end of #ifndef __IR_DEMOS_H__

#ifndef __IR_UTIL_H__ 
#include "IRutil.h" 
#endif                      //end of #ifndef __IR_UTIL_H__ 
 
#ifndef __IR_FUNCTIONS_H__ 
#include "IRfunctions.h" 
#endif                      //end of #ifndef __IR_FUNCTIONS_H__ 
 
#ifndef __IR_MISC_GLOBAL_H__ 
#include "IRmiscGlobal.h" 
#endif	 //end of #ifndef __IR_MISC_GLOBAL_H__ 
 
#ifndef __IR_POSITION_H__
#include "Position.h"
#endif

#ifndef __IR_GAME_INFO_H__
#include "GameInfo.h"
#endif

#ifndef __IR_TRIAL_SPEC_H__ 
#include "TrialSpec.h" 
#endif	  //end of #ifndef __IR_TRIAL_SPEC_H__ 
 
#ifndef __IR_TURN_INFO_H__ 
#include "TurnInfo.h" 
#endif	  //end of #ifndef __IR_TURN_INFO_H__ 
 
#ifndef __IR_TUPLE_INFO_H__
#include "TupleInfo.h"
#endif 

#ifndef __IR_TURN_CONTEXT_H__
#include "TurnContext.h"
#endif

#ifndef __IR_FILTERS_H__ 
#include "Filters.h" 
#endif	  //end of #ifndef __IR_FILTERS_H__ 

#ifndef __IR_DELTA_SCALES_H__
#include "DeltaScales.h"
#endif    //end of #ifndef __IR_DELTA_SCALES_H__

 
#ifndef __IR_PERFDATA_H__ 
#include "PerfData.h" 
#endif	 //end of #ifndef __IR_PERFDATA_H__ 
 
#ifndef __IR_SHUFFLE_H__
#include "Shuffle.h"
#endif

#ifndef __IR_DECISION_INFO_H__
#include "DecisionInfo.h"
#endif
 
#ifndef __IR_MODELS_H__
#include "IRmodels.h"
#endif

#ifndef __IR_MOVESELECTION_H__
#include "MoveSelector.h"
#endif

#ifndef __IR_TRIAL_H__ 
#include "Trial.h" 
#endif	  //end of #ifndef __IR_TRIAL_H__ 
 
#ifndef __IR_TRIAL_FILTERS_H__ 
#include "TrialFilters.h" 
#endif 

#ifndef __IR_MULTIMIN_H__
#include "multimin.h"
#endif

#ifndef __IR_MPFIT_H__
#include "mpfit.h"
#endif

 
#ifndef __IR_MINIMIZER_H__ 
#include "Minimizer.h" 
#endif	  //end of #ifndef __IR_MINIMIZER_H__ 
 
#ifndef __IR_MENUS_H__ 
#include "Menus.h" 
#endif	  //end of #ifndef __IR_MENUS_H__ 
 
#ifndef __IR_ENSEMBLE_H__ 
#include "Ensemble.h" 
#endif	  //end of #ifndef __IR_ENSEMBLE_H__ 
 
 
//-------------------------USER-PROGRAMMABLE DEMOS---------------------------- 
 
namespace Demos { 
 
   ofstream* agreeDemoFile(Ensemble& ens, string& fileName) { 
      ofstream* filep; 
      fileName = IRutil::DEMOFILENAME; 
      string ans = ""; 
      cout << "Use " << fileName << " as results file? (y/n) "; 
      ens.loggedRead(ans); 
      if (IRutil::isYes(ans)) { 
         filep = new ofstream(fileName.c_str(), ios::app); 
         if (!filep->is_open()) { 
            cerr << "Something is amiss with the demo file, please " 
                 << "select an alternate." << endl; 
            ans = "no"; 
         } 
      } 
      if (!IRutil::isYes(ans)) {     
            //might have fall-thru from IRutil::isYes(ans) case. 
         bool noFile = true; 
         while(noFile) { 
            cout << "Enter filename---avoid already-attached output files: "; 
            ens.loggedRead(fileName); 
            filep = new ofstream(fileName.c_str(), ios::app); 
            if(!filep->is_open()) { 
               cerr << "Cannot stat results file, please try again..." 
                    << endl; 
            } else { 
               noFile = false; 
            } 
         } 
      } //control here means fileName is name of valid ofstream *filep. 
      return filep; 
   } 
 
   istream& findLineWith(istream& IN, const string& pat, string& line) { 
      while ((!IRutil::delimitedMatch(pat,line)) && (!IN.eof())) { 
         getline(IN,line); 
      } 
      if (IN.eof()) { 
         cerr << "End-of-file reached without finding " << pat << endl; 
      } 
      return IN; 
   } 
 
   /** Extract PerfData information back from a PerfData.fullReport(). 
       Moves the IN pointer as a side-effect.  Per stream conventions, 
       extracts to ref variable and returns reference to modified stream. 
       !! As of 8/16/08, does *not* fill the arrays in the PerfData returned. 
    */ 
   ifstream& parsePerfData(ifstream& IN, const string& fromPat, PerfData& perf) { 
      string line; 
      findLineWith(IN, fromPat, line); 
      findLineWith(IN, "total turns", line); 
      vector<double> ed = IRutil::extractDoubles(line); 
 
      perf.numTurns = int(ed[0]); 
      perf.totalBootItems = int(ed[0]);
      perf.accumWeight = ed[1]; 
 
      findLineWith(IN, "first-move", line); 
      perf.weighted = (line[0] == 'W'); 
 
      ed = IRutil::extractDoubles(line); 
      perf.moveMatchWtd.projectedValue = ed[0]; 
      perf.moveMatchWtd.projectedSigma = ed[1]; 
      perf.moveMatchWtd.projectedFreq = ed[2]; 
 
      findLineWith(IN, "range", line); 
      ed = IRutil::extractDoubles(line); 
      perf.moveMatchWtd.projected2SigmaLeft = ed[0]; 
      perf.moveMatchWtd.projected2SigmaRight = ed[1]; 
      perf.moveMatchWtd.projected2SigmaLeftFreq = ed[2]; 
      perf.moveMatchWtd.projected2SigmaRightFreq = ed[3]; 
 
      findLineWith(IN, "top-move", line); 
      ed = IRutil::extractDoubles(line); 
      perf.equalValueMatchWtd.projectedValue = ed[0]; 
      perf.equalValueMatchWtd.projectedSigma = ed[1]; 
      perf.equalValueMatchWtd.projectedFreq = ed[2]; 
 
      findLineWith(IN, "range", line); 
      ed = IRutil::extractDoubles(line); 
      perf.equalValueMatchWtd.projected2SigmaLeft = ed[0];
      perf.equalValueMatchWtd.projected2SigmaRight = ed[1];
      perf.equalValueMatchWtd.projected2SigmaLeftFreq = ed[2];
      perf.equalValueMatchWtd.projected2SigmaRightFreq = ed[3];
 
      findLineWith(IN, "played-move", line); 
      ed = IRutil::extractDoubles(line); 
      perf.playedMoveMatchWtd.projectedValue = ed[0];  //predPlayedMatchesWtd = ed[0]; 
      perf.playedMoveMatchWtd.projectedSigma = ed[1]; 
      perf.playedMoveMatchWtd.projectedFreq = ed[2]; 
 
      findLineWith(IN, "range", line); 
      ed = IRutil::extractDoubles(line); 
      perf.playedMoveMatchWtd.projected2SigmaLeft = ed[0]; 
      perf.playedMoveMatchWtd.projected2SigmaRight = ed[1]; 
      perf.playedMoveMatchWtd.projected2SigmaLeftFreq = ed[2]; 
      perf.playedMoveMatchWtd.projected2SigmaRightFreq = ed[3]; 
 
 if (perf.weighted) { 
      findLineWith(IN, "Unwtd.", line); 
      ed = IRutil::extractDoubles(line); 
      perf.moveMatch.projectedValue = ed[0]; 
      perf.moveMatch.projectedSigma = ed[1]; 
      perf.moveMatch.projectedFreq = ed[2]; 
 
      findLineWith(IN, "range", line); 
      ed = IRutil::extractDoubles(line); 
      perf.moveMatch.projected2SigmaLeft = ed[0]; 
      perf.moveMatch.projected2SigmaRight = ed[1]; 
      perf.moveMatch.projected2SigmaLeftFreq = ed[2]; 
      perf.moveMatch.projected2SigmaRightFreq = ed[3]; 
 
      findLineWith(IN, "top-move", line); 
      ed = IRutil::extractDoubles(line); 
      perf.equalValueMatch.projectedValue = ed[0]; 
      perf.equalValueMatch.projectedSigma = ed[1]; 
      perf.equalValueMatch.projectedFreq = ed[2]; 
 
      findLineWith(IN, "range", line); 
      ed = IRutil::extractDoubles(line); 
      perf.equalValueMatch.projected2SigmaLeft = ed[0]; 
      perf.equalValueMatch.projected2SigmaRight = ed[1]; 
      perf.equalValueMatch.projected2SigmaLeftFreq = ed[2]; 
      perf.equalValueMatch.projected2SigmaRightFreq = ed[3]; 
 
      findLineWith(IN, "played-move", line); 
      ed = IRutil::extractDoubles(line); 
      perf.playedMoveMatch.projectedValue = ed[0];  //predPlayedMatchesWtd = ed[0];
      perf.playedMoveMatch.projectedSigma = ed[1];
      perf.playedMoveMatch.projectedFreq = ed[2];

      findLineWith(IN, "range", line); 
      ed = IRutil::extractDoubles(line); 
      perf.playedMoveMatch.projected2SigmaLeft = ed[0];
      perf.playedMoveMatch.projected2SigmaRight = ed[1];
      perf.playedMoveMatch.projected2SigmaLeftFreq = ed[2];
      perf.playedMoveMatch.projected2SigmaRightFreq = ed[3];
 } 
      findLineWith(IN, "first-line", line); 
      ed = IRutil::extractDoubles(line); 
      perf.moveMatch.measuredValue = int(ed[0]); 
      perf.moveMatch.measuredFreq = ed[1]; 
      perf.moveMatchWtd.measuredValue = ed[2]; 
      perf.moveMatchWtd.measuredFreq = ed[3]; 
 
      findLineWith(IN, "equal-top", line); 
      ed = IRutil::extractDoubles(line); 
      perf.equalValueMatch.measuredValue = int(ed[0]); 
      perf.equalValueMatch.measuredFreq = ed[1]; 
      perf.equalValueMatchWtd.measuredValue = ed[2]; 
      perf.equalValueMatchWtd.measuredFreq = ed[3]; 
 
      findLineWith(IN, "falloff", line); 
      getline(IN, line); 
      ed = IRutil::extractDoubles(line); 
      perf.scaledFalloffWtd.projectedValue = ed[0]; 
      perf.scaledFalloffWtd.projected2SigmaLeft = ed[1]; 
      perf.scaledFalloffWtd.projected2SigmaRight = ed[2]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.scaledFalloffWtd.measuredValue = ed[0]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.unscaledFalloffWtd.projectedValue = ed[0]; 
      perf.unscaledFalloffWtd.projected2SigmaLeft = ed[1]; 
      perf.unscaledFalloffWtd.projected2SigmaRight = ed[2]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.unscaledFalloffWtd.measuredValue = ed[0]; 
 
      findLineWith(IN, "figures", line); 
      getline(IN, line); 
      ed = IRutil::extractDoubles(line); 
      perf.scaledFalloffWtd.projectedFreq = ed[0]; 
      perf.scaledFalloffWtd.projected2SigmaLeftFreq = ed[1]; 
      perf.scaledFalloffWtd.projected2SigmaRightFreq = ed[2]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.scaledFalloffWtd.measuredFreq = ed[0]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.unscaledFalloffWtd.projectedFreq = ed[0]; 
      perf.unscaledFalloffWtd.projected2SigmaLeftFreq = ed[1]; 
      perf.unscaledFalloffWtd.projected2SigmaRightFreq = ed[2]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.unscaledFalloffWtd.measuredFreq = ed[0]; 
 
 
      findLineWith(IN, "Unweighted", line); 
      getline(IN, line); 
      ed = IRutil::extractDoubles(line); 
      perf.scaledFalloff.projectedValue = ed[0]; 
      perf.scaledFalloff.projected2SigmaLeft = ed[1]; 
      perf.scaledFalloff.projected2SigmaRight = ed[2]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.scaledFalloff.measuredValue = ed[0]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.unscaledFalloff.projectedValue = ed[0]; 
      perf.unscaledFalloff.projected2SigmaLeft = ed[1]; 
      perf.unscaledFalloff.projected2SigmaRight = ed[2]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.unscaledFalloff.measuredValue = ed[0]; 
 
      findLineWith(IN, "figures", line); 
      getline(IN, line); 
      ed = IRutil::extractDoubles(line); 
      perf.scaledFalloff.projectedFreq = ed[0]; 
      perf.scaledFalloff.projected2SigmaLeftFreq = ed[1]; 
      perf.scaledFalloff.projected2SigmaRightFreq = ed[2]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.scaledFalloff.measuredFreq = ed[0]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.unscaledFalloff.projectedFreq = ed[0]; 
      perf.unscaledFalloff.projected2SigmaLeftFreq = ed[1]; 
      perf.unscaledFalloff.projected2SigmaRightFreq = ed[2]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.unscaledFalloff.measuredFreq = ed[0]; 
 
 
 
       
      findLineWith(IN, "capped", line); 
      ed = IRutil::extractDoubles(line); 
      perf.unscaledFalloff.measuredValue = ed[0]; 
      perf.unscaledFalloff.measuredFreq = ed[1]; 
      getline(IN,line); 
      ed = IRutil::extractDoubles(line); 
      perf.unscaledFalloffNextTurnCapped.measuredValue = ed[0]; 
      perf.unscaledFalloffNextTurnCapped.measuredFreq = ed[1]; 
 
      return IN; 
   } 
 
 
   /** Initial dialog that can be shared by several demos.  
    */ 
   struct DemoChoices { 
      string groundFilters;  //filters that stay loaded throughout demo run 
      bool   fitThenGo;      //do best-fit on current spec before running demo 
      string matchStat;      //choice of first-line or equal-top matches  
      //double newCap;         //quick-change cap on delta values, max. 10.00 
      bool wtd; 
      bool cancel; 
 
      DemoChoices(const string& gf, bool ftg, const string& ms, bool gwtd = false, 
                  bool ca = false) 
//double nc = IRutil::DELTACAP, 
         : groundFilters(gf), fitThenGo(ftg), matchStat(ms), // newCap(nc), 
           wtd(gwtd), cancel(ca) { } 
   }; 
 
   DemoChoices demoOptions (Ensemble& ens) { 
 
      enum MAIN_DEMO_OPTIONS { 
         MATCH_STAT, 
         WEIGHTED, 
         CLEAR_FILTERS_FIRST, 
         CAP_EVAL, 
         EVAL_CAP, 
         OR_PREV_EVAL, 
//       CHANGE_DELTA_CAP,   //Allow to be part of Scales menu only?  Neither? 
         EXCLUDE_CLEAR_MOVES, 
         CLEAR_MOVE_CAP, 
         FIT_THEN_GO, 
         GO_DEMO, 
         NUM_MAIN_DEMO_OPTIONS 
      }; 
 
      EnumMenu* optionsMenu = new EnumMenu 
            (&ens, NUM_MAIN_DEMO_OPTIONS, 1, false , true,  
             "\nEnter " + IRutil::itoa(1+GO_DEMO) + "/go" 
                  + " to run, " + IRutil::itoa(1+FIT_THEN_GO) + "/fitThenGo" 
                  + " to fit and run, or select to change settings.\n"  
                  + IRutil::DASHES,  
             IRutil::DASHES, true, false, false);  
                               //cancelable, no other options 
      optionsMenu->addEntry(MATCH_STAT, "firstLines", 
         "Match first-line or equal-top moves? ", "first", true, false, false); 
      optionsMenu->addEntry(WEIGHTED, "weighted", 
         "Use weighted stats? ", "no", true, false, false); 
      optionsMenu->addEntry(CLEAR_FILTERS_FIRST, "clearFiltersFirst", 
         "Clear all other filters first?", "no", true, false, false); 
      optionsMenu->addEntry(CAP_EVAL, "capEval", "Skip extreme-eval turns? ", 
         (ens.getFocusTrial()->scalesDeltas() ? "no" : "yes"), 
         true, false, false); 
      optionsMenu->addEntry(EVAL_CAP, "evalCap", "If yes, skip when |eval| >", 
         "3.00", true, false, false); 
      optionsMenu->addEntry(OR_PREV_EVAL, "orPrevEval", 
         "...but include if prev turn OK? ", "yes", true, false, false); 
//    optionsMenu->addEntry(CHANGE_DELTA_CAP, "changeDeltaCap",  
//       "Cap on `Blunder Delta' =", 
//       IRutil::ftoa(ens.getFocusTrial()->getDeltaCap(),2),  
//       true, false, false); 
      optionsMenu->addEntry(EXCLUDE_CLEAR_MOVES, "excludeClearMoves", 
         "Exclude clear-choice moves? ", "no", true, false, false); 
      optionsMenu->addEntry(CLEAR_MOVE_CAP, "clearMoveCap", 
         "If yes, cap on second delta = ", "3.00", true, false, false); 
      optionsMenu->addEntry(FIT_THEN_GO, "fitThenGo", "Run Fit, Then Go.", 
         "", true, false, true); 
      optionsMenu->addEntry(GO_DEMO, "go", "Run With These Settings!", 
         "", true, false, false); 
 
      DemoChoices dc("", false, "first"); 
      bool entering = true; 
      string ans; 
      double doubleItem; 
 
      cout << endl << "Spec " << string(ens.getFocusTrial()->getSpec()) 
           << endl << IRutil::DASHES; 
 
      while (entering) { 
         int choice = optionsMenu->readChoice(); 
         if (optionsMenu->success(choice)) { 
            switch(choice) { 
             case MATCH_STAT: 
               cout << "Match first-line moves only? (y/n) (n -> equal-top) "; 
               ens.loggedRead(ans); 
               optionsMenu->setStatus(choice,  
                                      IRutil::isYes(ans) ? "first" : "top"); 
               break; 
             case WEIGHTED: 
               cout << "Use weighted stats? (y/n) "; 
               ens.loggedRead(ans); 
               optionsMenu->setStatus(choice, 
                                      IRutil::isYes(ans) ? "yes" : "no"); 
               break; 
             case CLEAR_FILTERS_FIRST: 
               cout << "Call clearFilters before attaching these? (y/n) "; 
               ens.loggedRead(ans); 
               optionsMenu->setStatus(choice,  
                                      IRutil::isYes(ans) ? "yes" : "no"); 
               break; 
             case CAP_EVAL: 
               cout << "Skip turns with extreme evals? (y/n) " << endl; 
               ens.loggedRead(ans); 
               optionsMenu->setStatus(choice,  
                                      IRutil::isYes(ans) ? "yes" : "no"); 
               break; 
             case EVAL_CAP: 
               cout << "Enter nonnegative bound for absolute eval value: "; 
               ens.loggedRead(doubleItem); 
               optionsMenu->setStatus(choice, IRutil::ftoa(doubleItem,2)); 
               break; 
             case OR_PREV_EVAL: 
               cout << "Include turns whose previous turn had absolute eval " 
                 << "within " << optionsMenu->getStatus(EVAL_CAP) << "? (y/n) "; 
               ens.loggedRead(ans); 
               optionsMenu->setStatus(choice,  
                                      IRutil::isYes(ans) ? "yes" : "no"); 
               break; 
//           case CHANGE_DELTA_CAP: 
//             cout << "Change delta cap for blunders? (minimum "  
//                  << IRutil::DELTACAP << ") (y/n): "; 
//             ens.loggedRead(doubleItem); 
//             optionsMenu->setStatus(choice, IRutil::ftoa(doubleItem,2)); 
//             break; 
             case EXCLUDE_CLEAR_MOVES: 
               cout << "Exclude moves with a clear choice? (y/n) "; 
               ens.loggedRead(ans); 
               optionsMenu->setStatus(choice,  
                                      IRutil::isYes(ans) ? "yes" : "no"); 
               break; 
             case CLEAR_MOVE_CAP: 
               cout << "Enter cap on delta of next best move: "; 
               ens.loggedRead(doubleItem); 
               optionsMenu->setStatus(choice, IRutil::ftoa(doubleItem,2)); 
               break; 
             case FIT_THEN_GO: 
               dc.fitThenGo = true; 
               entering = false; 
               break; 
             case GO_DEMO: 
             default: 
               entering = false; 
               break; 
            } 
         } else if (choice == EnumMenu::CANCEL_CHOICE) { 
            dc.cancel = true;  //INV: other options valid, so no crash occurs. 
            return dc; 
         } else { 
            cout << "Invalid menu entry, please try again." << endl; 
         } 
      } //control past here means successfully done entering. 
 
      ens.loggedWrite("",true); 
      dc.matchStat = optionsMenu->getStatus(MATCH_STAT); 
      //dc.newCap = atof(optionsMenu->getStatus(DELTA_CAP).c_str()); 
      dc.wtd = IRutil::isYes(optionsMenu->getStatus(WEIGHTED)); 
 
      if (IRutil::isYes(optionsMenu->getStatus(CLEAR_FILTERS_FIRST))) { 
         dc.groundFilters += " clearFilters "; 
      } 
 
      if (IRutil::isYes(optionsMenu->getStatus(CAP_EVAL))) { 
         string cap = optionsMenu->getStatus(EVAL_CAP); 
         dc.groundFilters += " newFilters EvalWithin ew " + cap + " 0 n done "; 
         if (IRutil::isYes(optionsMenu->getStatus(OR_PREV_EVAL))) { 
            dc.groundFilters += " newFilters PrevEvalWithin pw " + cap 
               + " 0 n OrFilter porew ew y pw n done " 
               + " detach ew y pw n "; 
         } 
      } 
 
      if (IRutil::isYes(optionsMenu->getStatus(EXCLUDE_CLEAR_MOVES))) { 
         string cap2 = optionsMenu->getStatus(CLEAR_MOVE_CAP); 
         dc.groundFilters += " newFilters SecondDelta sd leq " + cap2  
                           + " done "; 
      } 
 
      return dc; 
   } 
 
//-------------------------------Elista Demo--------------------------------- 
 
   void elistaDemo(Ensemble& ens) { 
 
      string fileName;   //*vital* to keep this updated! 
      ofstream* filep = agreeDemoFile(ens, fileName);  //fileName mutable 
      string timestamp = IRutil::getRawTime();  //already trimmed 
      string cal = IRutil::getTime(); 
      (*filep) << IRutil::IRCOMMENT << "Elista Test done on " << cal 
               << " (" << timestamp << ")" << endl << endl; 
      filep->close();  //now we give writing control over to "ens" 
      ens.addOutputFile(fileName, false);  //false -> no extra comment 
 
      const DemoChoices dc = demoOptions(ens);  
      if (dc.cancel) { 
         cout << "Canceled---returning." << endl; 
         return; 
      } 
      //else 
 
      double origCap = ens.getFocusTrial()->getDeltaCap(); 
      double newCap = origCap;  //dc.newCap; 
      //ens.getFocusTrial()->setDeltaCap(newCap); 
 
      string SLMpart = " newFilters EventIs SanLuis05 Luis done "; 
      SLMpart += " newFilters EventIs Mexico07 Mexico done "; 
      SLMpart += " newFilters OrFilter SL05+Mex07 SanLuis05 y Mexico07 n done "; 
      SLMpart += " detach Mexico07 y SanLuis05 y SL05+Mex07 n "; 
      SLMpart += " attach SL05+Mex07 n "; 
 
      istringstream* isp = new istringstream(dc.groundFilters + SLMpart); 
      ens.interactFromStream(isp, ""); 
      //leaves control back at main menu and restores input from cin 
 
      if (dc.fitThenGo) { 
         ens.runFit(); 
      } 
 
      string slmPart = " perfTest y n detach SL05+Mex07 n ";  
 
      string elistaFilters = string(" ") 
       + "newFilters PlayerToMove Kr2m Kramnik PlayerToMove To2m Topalov done " 
       + "newFilters DateIs TKg1 eq 2006.09.23 DateIs TKg2 eq 2006.09.24 " 
       + " DateIs TKg3 eq 2006.09.26 DateIs TKg4 eq 2006.09.27 " 
       + " DateIs TKg6 eq 2006.10.02 done " 
       + "newFilters OrFilter TKg1-6 TKg1 y TKg2 y TKg3 y TKg4 y TKg6 n done " 
       + "newFilters MoveNo from11 geq 11 MoveNo from13 geq 13  " 
       + "MoveNo from14 geq 14 MoveNo from15 geq 15 MoveNo from18 geq 18 done " 
       + "newFilters AndFilter Kramnikg1 Kr2m y TKg1 y from13 n done " 
       + "newFilters AndFilter Kramnikg2 Kr2m y TKg2 y from18 n done " 
       + "newFilters AndFilter Kramnikg3 Kr2m y TKg3 y from11 n done " 
       + "newFilters AndFilter Kramnikg4 Kr2m y TKg4 y from15 n done " 
       + "newFilters AndFilter Kramnikg6 Kr2m y TKg6 y from14 n done " 
       + "newFilters OrFilter Kramnikg1-6 Kramnikg1 y Kramnikg2 y Kramnikg3 y " 
       + "Kramnikg4 y Kramnikg6 n done " 
       + "newFilters AndFilter Topalovg1 To2m y TKg1 y from13 n done " 
       + "newFilters AndFilter Topalovg2 To2m y TKg2 y from18 n done " 
       + "newFilters AndFilter Topalovg3 To2m y TKg3 y from11 n done " 
       + "newFilters AndFilter Topalovg4 To2m y TKg4 y from15 n done " 
       + "newFilters AndFilter Topalovg6 To2m y TKg6 y from14 n done " 
       + "newFilters OrFilter Topalovg1-6 Topalovg1 y Topalovg2 y Topalovg3 y " 
       + "Topalovg4 y Topalovg6 n done " 
       + "detach Kr2m y To2m y TKg1 y TKg2 y TKg3 y TKg4 y TKg6 y TKg1-6 n " 
       + "detach from11 y from13 y from14 y from15 y from18 n " 
       + "detach Kramnikg1 y Kramnikg2 y Kramnikg3 y Kramnikg4 y Kramnikg6 n " 
       + "detach Topalovg1 y Topalovg2 y Topalovg3 y Topalovg4 y Topalovg6 n " 
       + "detach Kramnikg1-6 y Topalovg1-6 n "; 
 
      string doElista = ""; 
      doElista += " attach Kramnikg1 n perfTest y n detach Kramnikg1 n "; 
      doElista += " attach Kramnikg2 n perfTest y n detach Kramnikg2 n "; 
      doElista += " attach Kramnikg3 n perfTest y n detach Kramnikg3 n "; 
      doElista += " attach Kramnikg4 n perfTest y n detach Kramnikg4 n "; 
      doElista += " attach Kramnikg6 n perfTest y n detach Kramnikg6 n "; 
      doElista += " attach Kramnikg1-6 n perfTest y n detach Kramnikg1-6 n "; 
      doElista += " attach Topalovg1 n perfTest y n detach Topalovg1 n "; 
      doElista += " attach Topalovg2 n perfTest y n detach Topalovg2 n "; 
      doElista += " attach Topalovg3 n perfTest y n detach Topalovg3 n "; 
      doElista += " attach Topalovg4 n perfTest y n detach Topalovg4 n "; 
      doElista += " attach Topalovg6 n perfTest y n detach Topalovg6 n "; 
      doElista += " attach Topalovg1-6 n perfTest y n detach Topalovg1-6 n "; 
 
      string cleanup = ""; 
      cleanup += " hideFilters Kr2m y To2m y TKg1 y TKg2 y TKg3 y TKg4 y TKg6 "; 
      cleanup += " y TKg1-6 y from11 y from13 y from14 y from15 y from18 "; 
      cleanup += " y Kramnikg1 y Kramnikg2 y Kramnikg3 y Kramnikg4 "; 
      cleanup += " y Kramnikg6 y Kramnikg1-6 y Topalovg1 y Topalovg2 "; 
      cleanup += " y Topalovg3 y Topalovg4 y Topalovg6 y Topalovg1-6 n "; 
      //we leave the San Luis and Mexico filters un-hidden. 
 
      isp = new istringstream(slmPart + elistaFilters + doElista + cleanup); 
 
      ens.interactFromStream(isp, ""); 
 
      ens.closeOutputFile(fileName);  //no more output, removed from "outs" 
 
      ifstream resultsFile(fileName.c_str()); 
 
      PerfData slmPerf(newCap);  
      PerfData kg1(newCap), kg2(newCap), kg3(newCap), kg4(newCap), 
               kg6(newCap), kg1to6(newCap); 
      PerfData tg1(newCap), tg2(newCap), tg3(newCap), tg4(newCap), 
               tg6(newCap), tg1to6(newCap); 
 
      string timeLine;  //used only as placeholder 
      findLineWith(resultsFile,timestamp,timeLine); 
 
      parsePerfData(resultsFile, "SL05+Mex07", slmPerf); 
      parsePerfData(resultsFile, "Kramnikg1", kg1); 
      parsePerfData(resultsFile, "Kramnikg2", kg2); 
      parsePerfData(resultsFile, "Kramnikg3", kg3); 
      parsePerfData(resultsFile, "Kramnikg4", kg4); 
      parsePerfData(resultsFile, "Kramnikg6", kg6); 
      parsePerfData(resultsFile, "Kramnikg1-6", kg1to6); 
      parsePerfData(resultsFile, "Topalovg1", tg1); 
      parsePerfData(resultsFile, "Topalovg2", tg2); 
      parsePerfData(resultsFile, "Topalovg3", tg3); 
      parsePerfData(resultsFile, "Topalovg4", tg4); 
      parsePerfData(resultsFile, "Topalovg6", tg6); 
      parsePerfData(resultsFile, "Topalovg1-6", tg1to6); 
 
      string source = dc.fitThenGo ? "San Luis '05 and Mexico '07"  
                                   : "Your source for the trial-spec"; 
      string weightedAdj = slmPerf.weighted ? "weighted" : "unweighted"; 
      string weightedAdjCap = slmPerf.weighted ? "Weighted" : "Unweighted"; 
 
      cout << endl; 
      cout << "Highlights of the results: " << source << " set the standard " 
           << "used" << endl << "to predict Elista for " << weightedAdj << " " 
           << dc.matchStat << "-move matches, to TogaII 1.2.1a depth 15.\n\n"; 
 
      cout << (slmPerf.matchStats("SL+Mex", dc.matchStat == "first", 7)); 
      cout << endl << endl; 
 
      cout << weightedAdjCap << " " << dc.matchStat << "-move matches for " 
           << "Kramnik's games 1-6, over the moves" << endl 
           << "listed by Danailov " 
           << "(filtered further by options you chose)" << endl; 
      cout << endl; 
 
      cout << kg1.matchStats("Game 1", dc.matchStat == "first", 6, dc.wtd) << endl; 
      cout << kg2.matchStats("Game 2", dc.matchStat == "first", 6, dc.wtd) << endl; 
      cout << kg3.matchStats("Game 3", dc.matchStat == "first", 6, dc.wtd) << endl; 
      cout << kg4.matchStats("Game 4", dc.matchStat == "first", 6, dc.wtd) << endl; 
      cout << kg6.matchStats("Game 6", dc.matchStat == "first", 6, dc.wtd) << endl; 
      cout << kg1to6.matchStats("Gms 1-6", dc.matchStat == "first", 6, dc.wtd) << endl; 
 
      string tw = (dc.matchStat == "top") ? "in Game 1 and " : ""; 
      cout << endl << "Thus we see Kramnik matched more " << tw << "especially" 
         << " in Game 2," << endl << "but he was PREDICTED to match more, " 
         << "BECAUSE Topalov faced him with such " << endl 
         << "forcing situations that *anyone* at San Luis + Mexico would do " 
         << "the same!" << endl 
         << "(Stats agree with KWR's posted Fritz results, below " 
         << "Danailov's bare claims.)" << endl; 
      cout << endl << "Hit return to show Topalov's stats."; 
 
      if (ens.usingCin()) { 
         IRutil::finishLine(cin); 
      } 
       
      cout << tg1.matchStats("Game 1", dc.matchStat == "first", 6, dc.wtd) << endl; 
      cout << tg2.matchStats("Game 2", dc.matchStat == "first", 6, dc.wtd) << endl; 
      cout << tg3.matchStats("Game 3", dc.matchStat == "first", 6, dc.wtd) << endl; 
      cout << tg4.matchStats("Game 4", dc.matchStat == "first", 6, dc.wtd) << endl; 
      cout << tg6.matchStats("Game 6", dc.matchStat == "first", 6, dc.wtd) << endl; 
      cout << tg1to6.matchStats("Gms 1-6", dc.matchStat == "first", 6, dc.wtd) << endl; 
 
      bool sc = ens.getFocusTrial()->scalesDeltas(); 
 
      cout << endl << "Falloff comparisons, expected and actual: " << endl; 
      cout << slmPerf.falloffStats("San Luis '05 and Mexico '07", sc, 8, dc.wtd) 
           << endl; 
      cout << kg1to6.falloffStats("Kramnik, games 1--6", sc, 8, dc.wtd) << endl; 
      cout << tg1to6.falloffStats("Topalov, games 1--6", sc, 8, dc.wtd) << endl; 
 
      cout << endl; 
      cout << "Thus we see Topalov was simply outplayed in games 1-6, " 
           << "with nothing else amiss." << endl; 
      cout << "Hit return to continue exploring (with option to quit)." << endl; 
 
      if (ens.usingCin()) {  
         IRutil::finishLine(cin);  
      } 
 
      //ens.getFocusTrial()->setDeltaCap(origCap); 
      resultsFile.close(); 
   } 
 
 
//--------------------San Luis '05 and Mexico '07 Demo----------------------- 
 
   void sanLuisMexicoDemo(Ensemble& ens) { 
 
      string fileName;   //*vital* to keep this updated! 
      ofstream* filep = agreeDemoFile(ens, fileName);  //fileName mutable 
      string timestamp = IRutil::getRawTime();  //already trimmed 
      string cal = IRutil::getTime(); 
      (*filep) << IRutil::IRCOMMENT  
               << "San Luis '05 + Mexico '07 Demo done on " << cal 
               << " (" << timestamp << ")" << endl << endl; 
      filep->close();  //now we give writing control over to "ens" 
      ens.addOutputFile(fileName, false);  //false -> no extra comment 
 
      cout << endl << "Do fitThenGo to fit San Luis + Mexico with Topalov's " 
           << "San Luis moves excluded." << endl; 
 
      const DemoChoices dc = demoOptions(ens); 
      if (dc.cancel) { 
         cout << "Canceled---returning." << endl; 
         return; 
      } 
      //else 
 
      double origCap = ens.getFocusTrial()->getDeltaCap(); 
      double newCap = origCap;  //dc.newCap; 
      //ens.getFocusTrial()->setDeltaCap(newCap); 
 
      string buildFilters = dc.groundFilters 
         + " newFilters PlayerToMove To2m Topalov PlayerToMove An2m Anand " 
         + " EventIs SanLuis05 Luis EventIs Mexico07 Mexico " 
         + " OrFilter SL05+Mex07 SanLuis05 y Mexico07 n " 
         + " AndFilter To2mSL To2m y SanLuis05 n " 
         + " AndFilter An2mMex An2m y Mexico07 n " 
         + " NotFilter NotTo2mSL To2mSL " 
         + " AndFilter fitBezTo2mSL SL05+Mex07 y NotTo2mSL n " 
         + " OnMoveFacing TopOpp2m Topalov " 
         + " OnMoveFacing AnOpp2m Anand " 
         + " AndFilter TopOpp2mSL TopOpp2m y SanLuis05 n " 
         + " AndFilter AnOpp2mMex AnOpp2m y Mexico07 n done "; 
      string leaveActiveList = " SanLuis05 y Mexico07 y SL05+Mex07 y "; 
      string hideList = string(" To2m y An2m y To2mSL y An2mMex y NotTo2mSL ") 
         + " y fitBezTo2mSL y TopOpp2m y AnOpp2m y TopOpp2mSL y AnOpp2mMex n "; 
      buildFilters += " detach " + leaveActiveList + hideList; 
       
      //now attach filter for-fit *in case* user desired it: 
      buildFilters += " attach fitBezTo2mSL n "; 
 
      istringstream* isp = new istringstream(buildFilters); 
      ens.interactFromStream(isp, ""); 
      // 
      //Leaves control back at main menu with only ground-filters and 
      //"fitBezTo2mSL" attached, and restores input from cin. 
      //This enables user to change other fit settings interactively.  If user 
      //didn't choose to fit, we still do performance test with it attached. 
 
      if (dc.fitThenGo) { 
         ens.runFit(); 
      } 
 
      // Performance tests in order:  
      // (1) SL+Mex without Topalov San Luis, (2) SL+Mex overall, 
      // (3) Topalov San Luis, (4) Topalov's opponents at San Luis, 
      // (5) Anand Mexico, (6) Anand's opponents in Mexico. 
      // For transparency we script user screen action and cull data from the 
      // actual output, rather than call routines directly as with  
      // "ens.runFit" above.  The downside is that (currently) we don't get 
      // named PerfData objects from the performance tests themselves, 
      // but only from the messy after-the-fact parsing of output. 
 
      string perfPart = string(" perfTest y n detach fitBezTo2mSL n ") 
         + " attach SL05+Mex07 n perfTest y n detach SL05+Mex07 n " 
         + " attach To2mSL n perfTest y n detach To2mSL n " 
         + " attach TopOpp2mSL n perfTest y n detach TopOpp2mSL n " 
         + " attach An2mMex n perfTest y n detach An2mMex n " 
         + " attach AnOpp2mMex n perfTest y n detach AnOpp2mMex n "; 
      string cleanup = " hideFilters " + hideList; 
 
      isp = new istringstream(perfPart + cleanup); 
      ens.interactFromStream(isp, ""); 
 
      ens.closeOutputFile(fileName);  //no more output, removed from "outs" 
 
      ifstream resultsFile(fileName.c_str()); 
 
      string timeLine; //used only as placeholder 
      findLineWith(resultsFile,timestamp,timeLine); 
 
      PerfData slmPerfBez(newCap), slmPerf(newCap), topSLPerf(newCap); 
      PerfData topOppSLPerf(newCap), anMexPerf(newCap), anOppMexPerf(newCap); 
 
      parsePerfData(resultsFile, "fitBezTo2mSL", slmPerfBez); 
      parsePerfData(resultsFile, "SL05+Mex07", slmPerf); 
      parsePerfData(resultsFile, "To2mSL", topSLPerf); 
      parsePerfData(resultsFile, "TopOpp2mSL", topOppSLPerf); 
      parsePerfData(resultsFile, "An2mMex", anMexPerf); 
      parsePerfData(resultsFile, "AnOpp2mMex", anOppMexPerf); 
 
      bool sc = ens.getFocusTrial()->scalesDeltas(); 
      string source = dc.fitThenGo ?  
           "San Luis '05 plus Mexico '07 minus Topalov at San Luis" 
         : "Your source for the trial-spec"; 
 
      string matchKind = (dc.matchStat=="first") ? "first-line" : "equal-top"; 
      string weightedAdj = slmPerf.weighted ? "weighted" : "unweighted"; 
      string weightedAdjCap = slmPerf.weighted ? "Weighted" : "Unweighted"; 
 
      cout << endl; 
      cout << "Highlights of results: " << source << endl 
           << "set the standard used to assess performance at San Luis '05 " 
           << "and Mexico '07." << endl 
           << "First we evaluate Topalov at San Luis:" << endl << endl; 
 
      cout << "Overall " + matchKind + " move-matches:" << endl; 
      cout << slmPerf.matchStats("SL+Mex", dc.matchStat == "first", 6, dc.wtd) << endl 
           << slmPerfBez.matchStats("- Top@SL", dc.matchStat == "first", 6, dc.wtd); 
      cout << endl << endl; 
      cout << "Topalov's and Opponents' move-matches at San Luis '05:" << endl; 
      cout << topSLPerf.matchStats("Topalov", dc.matchStat == "first", 6, dc.wtd) 
           << endl 
           << topOppSLPerf.matchStats("Top Opp", dc.matchStat == "first", 6, dc.wtd) 
           << endl << endl; 
 
      cout << "Falloff comparisons, expected and actual: " << endl; 
      cout << slmPerf.falloffStats("San Luis '05 and Mexico '07", sc, 8, dc.wtd) 
           << endl; 
      cout << slmPerfBez.falloffStats("Minus Topalov at San Luis", sc, 8, dc.wtd) 
           << endl; 
      cout << topSLPerf.falloffStats("Topalov at San Luis", sc, 8, dc.wtd)  
           << "  ** !" << endl; 
      cout << topOppSLPerf.falloffStats("Topalov's Opponents at San Luis",sc,8, dc.wtd) 
           << endl; 
 
      cout << endl; 
      cout << "Thus we see Topalov's opponents played pretty much up to par, "  
           << endl 
           << "while Topalov himself played superbly.  This is exactly what " 
           << "one might expect" << endl 
           << "if Topalov were receiving assistance during the games, even " 
           << "only on key moves." << endl 
           << "But before you reach for the phone to have Interpol make an " 
           << "arrest in Bulgaria," << endl 
           << "hit return to see Anand's performance at Mexico '07:" << endl; 
 
      if (ens.usingCin()) { 
         IRutil::finishLine(cin); 
      } 
 
      cout << "Anand's and Opponents' move-matches at Mexico '07:" << endl; 
      cout << anMexPerf.matchStats("Anand", dc.matchStat == "first", 6, dc.wtd) 
           << endl 
           << anOppMexPerf.matchStats("AnandOpp", dc.matchStat == "first", 6, dc.wtd) 
           << endl << endl; 
 
      cout << "Falloff comparisons, expected and actual: " << endl; 
      cout << slmPerf.falloffStats("San Luis '05 and Mexico '07", sc, 8, dc.wtd) 
           << endl; 
      cout << slmPerfBez.falloffStats("Minus Topalov at San Luis", sc, 8, dc.wtd) 
           << endl; 
      cout << anMexPerf.falloffStats("Anand at Mexico '07", sc, 8, dc.wtd)  
           << "  ** !!" << endl; 
      cout << anOppMexPerf.falloffStats("Anand's Opponents at Mexico '07",sc,8, dc.wtd) 
           << endl; 
 
      cout << endl; 
      cout << "Do you see any real difference from Topalov's stats at San Luis?" 
           << endl 
           << "Perhaps in move-matching, but (a) Topalov was predicted " 
           << "to match more" << endl 
           << "(owing to the more-forcing nature of his games, we infer), " 
           << "and (b) Topalov" << endl  
           << "is well within the 2-sigma range.  We see *falloff* rather " 
           << "than move-matches as" << endl 
           << "most important and engine-neutral---note that Anand had " 
	   << "nearly the same ratio!" << endl; 
      cout << "Since Anand's win is uncontroversial, maybe they share a " 
           << "general conclusion:" << endl 
           << endl 
           << "      WINNERS OF TOP EVENTS TEND TO HAVE PLAYED REALLY WELL." 
           << endl << endl; 
      cout << "Hit return to continue exploring (with option to quit)." 
           << endl; 
 
      if (ens.usingCin()) { 
          IRutil::finishLine(cin);  
      } 
 
      //ens.getFocusTrial()->setDeltaCap(origCap); 
      resultsFile.close(); 
   } 
 
 
//------------------------------Swing Demo----------------------------------- 
 
   void swingDemo(Ensemble& ens) { 
 
      string fileName;   //*vital* to keep this updated! 
      ofstream* filep = agreeDemoFile(ens, fileName);  //fileName mutable 
      string timestamp = IRutil::getRawTime();  //already trimmed 
      string cal = IRutil::getTime(); 
      (*filep) << IRutil::IRCOMMENT << " Swing Demo run on " << cal 
               << " (" << timestamp << ")" << endl << endl; 
      filep->close();   //turn control over to "ens" now. 
      ens.addOutputFile(fileName,false);  //false -> no extra comment 
 
      cout << "Include turns with more than 2 or 3 equal-top moves? (y/n) "; 
      string ans; 
      ens.loggedRead(ans); 
 
      if (ens.usingCin()) { 
         IRutil::finishLine(cin);   //finishes line that answered last question. 
      } 
 
      string st = ""; 
      st += " newFilters SecondDelta sdeq0 eq 0 DeltaIs tdeq0 2 eq 0 "; 
      st += " DeltaIs fdeq0 3 eq 0 DeltaIs vdeq0 4 eq 0 FirstLineMatch flm "; 
      st += " PlayedMoveIndex pmieq1 eq 1 PlayedMoveIndex pmieq2 eq 2 "; 
      st += " PlayedMoveIndex pmieq3 eq 3 PlayedMoveIndex pmileq1 leq 1 "; 
      st += " PlayedMoveIndex pmileq2 leq 2 PlayedMoveIndex pmileq3 leq 3 "; 
      st += " PlayedMoveIndex pmieq4 eq 4 PlayedMoveIndex pmileq4 leq 4 "; 
      st += " DeltaIs sdeq01 1 eq 0.01 done "; 
      st += " detach sdeq0 y tdeq0 y fdeq0 y vdeq0 y flm y pmieq1 y pmieq2 y pmieq3 "; 
      st += " y pmieq4 y pmileq1 y pmileq2 y pmileq3 y pmileq4 y sdeq01 n "; 
 
      if (!IRutil::isYes(ans)) { 
         st += " newFilters DeltaIs tdgt0 2 geq 0.005 DeltaIs fdgt0 3 geq "; 
         st += "0.005 DeltaIs vdgt0 4 geq 0.005 DeltaIs xdgt0 5 geq 0.005 done"; 
         st += " detach tdgt0 y fdgt0 y vdgt0 y xdgt0 n "; 
      } 
 
      string td = IRutil::isYes(ans) ? "" : " y tdgt0 "; 
      string fd = IRutil::isYes(ans) ? "" : " y fdgt0 "; 
      string vd = IRutil::isYes(ans) ? "" : " y vdgt0 "; 
      string xd = IRutil::isYes(ans) ? "" : " y xdgt0 "; 
 
      st += " attach pmileq1 y sdeq0 " + td + " n showTrial n "; 
      st += " attach flm n showTrial n "; 
      st += " detach pmileq1 y sdeq0 " + td + " y flm n "; 
 
      st += " attach pmileq2 y tdeq0 " + fd + " n showTrial n "; 
      st += " attach flm n showTrial n detach flm n "; 
      st += " attach pmieq1 n showTrial n detach pmieq1 n "; 
      st += " attach pmieq2 n showTrial n detach pmieq2 n "; 
      st += " detach pmileq2 y tdeq0 " + fd + " n "; 
 
      st += " attach pmileq3 y fdeq0 " + vd + " n showTrial n "; 
      st += " attach flm n showTrial n detach flm n "; 
      st += " attach pmieq1 n showTrial n detach pmieq1 n "; 
      st += " attach pmieq2 n showTrial n detach pmieq2 n "; 
      st += " attach pmieq3 n showTrial n detach pmieq3 n "; 
      st += " detach pmileq3 y fdeq0 " + vd + " n "; 
 
      st += " attach pmileq4 y vdeq0 " + xd + " n showTrial n "; 
      st += " attach flm n showTrial n detach flm n "; 
      st += " attach pmieq1 n showTrial n detach pmieq1 n "; 
      st += " attach pmieq2 n showTrial n detach pmieq2 n "; 
      st += " attach pmieq3 n showTrial n detach pmieq3 n "; 
      st += " attach pmieq4 n showTrial n detach pmieq4 n "; 
      st += " detach pmileq4 y vdeq0 " + xd + " n "; 
 
 
      st += " attach sdeq01 y pmileq1 n showTrial n "; 
      st += " attach flm n showTrial n detach flm y sdeq01 y pmileq1 n "; 
 
      string cleanup = ""; 
      cleanup += " hideFilters sdeq0 y tdeq0 y fdeq0 y flm y pmieq1 y pmieq2 "; 
      cleanup += " y pmieq3 y pmileq1 y pmileq2 y pmileq3 y sdeq01 n "; 
      if (!IRutil::isYes(ans)) { 
         cleanup += " hideFilters tdgt0 y fdgt0 y vdgt0 n "; 
      } 
 
      istringstream* isp = new istringstream(st + cleanup); 
      ens.interactFromStream(isp, ""); 
      ens.closeOutputFile(fileName);  //now file is back in our control 
 
      ifstream resultsFile(fileName.c_str()); 
      string line; 
      findLineWith(resultsFile,timestamp,line); 
 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int twoZeroTurns = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int twoZeroMatches = int(IRutil::extractDoubles(line)[1]); 
 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int threeZeroTurns = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int threeZeroMatches = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int threeZeroSeconds = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int threeZeroThirds = int(IRutil::extractDoubles(line)[1]); 
 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fourZeroTurns = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fourZeroMatches = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fourZeroSeconds = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fourZeroThirds = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fourZeroFourths = int(IRutil::extractDoubles(line)[1]); 
 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fiveZeroTurns = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fiveZeroMatches = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fiveZeroSeconds = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fiveZeroThirds = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fiveZeroFourths = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int fiveZeroFifths = int(IRutil::extractDoubles(line)[1]); 
 
 
 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int sdeq01Turns = int(IRutil::extractDoubles(line)[1]); 
      findLineWith(resultsFile,"trial",line); 
      line = line.substr(line.find_last_of(":")); 
      int sdeq01Matches = int(IRutil::extractDoubles(line)[1]); 
 
 
 
      double sigmaTwo = sqrt(0.5*0.5*twoZeroTurns); 
      double sigmaThree = sqrt(2.0*threeZeroTurns/9.0); 
      double sigmaFour = sqrt(3.0*fourZeroTurns/16.0); 
      double devTwo = (twoZeroMatches - twoZeroTurns/2.0)/sigmaTwo; 
      double devThree = (threeZeroMatches - threeZeroTurns/3.0)/sigmaThree; 
      double devFour = (fourZeroMatches - fourZeroTurns/4.0)/sigmaFour; 
 
      string qualif = IRutil::isYes(ans) ? "" : "exactly "; 
 
      cout << "SUMMARY" << endl << IRutil::DASHES << endl << endl; 
      cout << "Among turns with " << qualif << "two top-eval moves " 
           << "and one of them chosen: " << endl; 
      cout << "# of 2-zero turns: " << setw(5) << right << twoZeroTurns << endl 
           << "Expected #matches: " << setw(5) << int(twoZeroTurns/2.0 + 0.5) 
           << ",  two-sigma range " << setw(8) << setprecision(2) << fixed 
           << twoZeroTurns/2.0 - 2*sigmaTwo << "--" << left 
           << twoZeroTurns/2.0 + 2*sigmaTwo << endl 
           << "First move chosen: " << setw(5) << right << twoZeroMatches 
           << ", " << 100.0*twoZeroMatches/twoZeroTurns << "%" 
           << ",  deviation " << devTwo << " sigmas" << endl << endl; 
 
      if (devTwo > 2.0) { 
         cout << "Of two moves judged equal, the first is chosen " 
              << "significantly more often.  Why?" << endl 
              << "No H-R-S statistical mumbo-jumbo is involved here---we have " 
              << "just the engine" << endl 
              << "(Toga II 1.2.1a) and moves it \"randomly\" judges equal-top " 
              << "at ply-depth 15." << endl 
              << "Why should the first-listed of such an equal pair be played " 
              << "so much more often?" << endl << endl; 
         cout << "A *definite factor* is that the engine's ordering is *not* " 
              << "random." << endl 
              << "Except in (rare?) cases where both moves were equal from " 
              << "the lowest ply-depth," << endl 
              << "the first-listed move was judged *better* at some " 
              << "previous ply-depth." << endl 
              << "Our *swing hypothesis* is that players are sensitive to " 
              << "earlier-ply judgments" << endl 
              << "to degrees not subsumed by the depth-15 results.  Thus our " 
              << "full model intends" << endl 
              << "to apply weights to results from various ply-depths.  " 
              << "However explained, " << endl 
              << "this accounts for all best-fits " 
              << "*over-predicting* the " 
              << "% of equal-top matches." << endl; 
         cout << "Hit return to see more results and ideas:" << endl; 
 
         if (ens.usingCin()) { 
            IRutil::finishLine(cin);  
         } 
      } 
 
      cout << endl; 
      cout << "Among turns with " << qualif << "three top-eval moves " 
           << "and one of them chosen: " << endl; 
      cout << "# of 3-zero turns: " << setw(5) << right << threeZeroTurns<<endl 
           << "Expected #matches: " << setw(5) << int(threeZeroTurns/3.0 + 0.5) 
           << ",  two-sigma range " << setw(8) << setprecision(2) << fixed 
           << threeZeroTurns/3.0 - 2*sigmaThree << "--" << left 
           << threeZeroTurns/3.0 + 2*sigmaThree << endl 
           << "First move chosen: " << setw(5) << right << threeZeroMatches 
           << ", " << 100.0*threeZeroMatches/threeZeroTurns << "%" 
           << ",  deviation " << devThree << " sigmas" << endl 
           << "Second way chosen: " << setw(5) << right << threeZeroSeconds 
           << ", " << 100.0*threeZeroSeconds/threeZeroTurns << "%" 
           << endl 
           << "Third move chosen: " << setw(5) << right << threeZeroThirds 
           << ", " << 100.0*threeZeroThirds/threeZeroTurns << "%" 
           << endl << endl; 
 
      cout << "Among turns with " << qualif << "four top-eval moves " 
           << "and one of them chosen: " << endl; 
      cout << "# of 4-zero turns: " << setw(5) << right << fourZeroTurns << endl 
           << "Expected #matches: " << setw(5) << int(fourZeroTurns/4.0 + 0.5) 
           << ",  two-sigma range " << setw(8) << setprecision(2) << fixed 
           << fourZeroTurns/4.0 - 2*sigmaFour << "--" << left 
           << fourZeroTurns/4.0 + 2*sigmaFour << endl 
           << "First move chosen: " << setw(5) << right << fourZeroMatches 
           << ", " << 100.0*fourZeroMatches/fourZeroTurns << "%" 
           << ",  deviation " << devFour << " sigmas" << endl 
           << "Second way chosen: " << setw(5) << right << fourZeroSeconds 
           << ", " << 100.0*fourZeroSeconds/fourZeroTurns << "%" 
           << endl 
           << "Third move chosen: " << setw(5) << right << fourZeroThirds 
           << ", " << 100.0*fourZeroThirds/fourZeroTurns << "%" 
           << endl 
           << "Fourth way chosen: " << setw(5) << right << fourZeroFourths 
           << ", " << 100.0*fourZeroFourths/fourZeroTurns << "%" 
           << endl << endl; 
 
      cout << "Among turns with " << qualif << "five top-eval moves " 
           << "and one of them chosen: " << endl; 
      cout << "# of 5-zero turns: " << setw(5) << right << fiveZeroTurns << endl 
           << "Expected #matches: " << setw(5) << int(fiveZeroTurns/4.0 + 0.5) 
           << ",  two-sigma range " << setw(8) << setprecision(2) << fixed 
           << fiveZeroTurns/4.0 - 2*sigmaFour << "--" << left 
           << fiveZeroTurns/4.0 + 2*sigmaFour << endl 
           << "First move chosen: " << setw(5) << right << fiveZeroMatches 
           << ", " << 100.0*fiveZeroMatches/fiveZeroTurns << "%" 
           << ",  deviation " << devFour << " sigmas" << endl 
           << "Second way chosen: " << setw(5) << right << fiveZeroSeconds 
           << ", " << 100.0*fiveZeroSeconds/fiveZeroTurns << "%" 
           << endl 
           << "Third move chosen: " << setw(5) << right << fiveZeroThirds 
           << ", " << 100.0*fiveZeroThirds/fiveZeroTurns << "%" 
           << endl 
           << "Fourth way chosen: " << setw(5) << right << fiveZeroFourths 
           << ", " << 100.0*fiveZeroFourths/fiveZeroTurns << "%" 
           << endl 
           << "Fifth move chosen: " << setw(5) << right << fiveZeroFifths 
           << ", " << 100.0*fiveZeroFifths/fiveZeroTurns << "%" 
           << endl << endl; 
 
 
      cout << "Does the engine maintain order rigidly for moves after the " 
           << "first, or vary more?" << endl 
           << "Is a \"swing effect\" prominent only between the top two " 
           << "moves players consider?" << endl 
           << "Our first testable prediction is that among turns where the " 
           << "ply-15 first move " << endl 
           << "was judged inferior at previous ply-depths, first-line " 
           << "matches should run below" << endl 
           << "what ply-15 stats indicate.  I.e. \"swing moves\" are " 
           << "harder for players to find." << endl << endl 
           << "Second, our %-tile best-fits that get the first-move and tail " 
           << "frequencies and " << endl 
           << "falloff correct all over-predict the frequency of the " 
           << "second move.  Unless" << endl 
           << "the equal-top move cases account " 
           << "for all of this deviation, we must predict" << endl 
           << "that the second-best move usually swings toward or catches " 
           << "up with the first," << endl 
           << "rather than the first move breaking away.  " 
           << "Finally, our full model will probe" << endl 
           << "whether players of different strengths are sensitive " 
           << "to evals at different" << endl 
           << "ply-depths.  "; 
      cout << "Hit return to see the final surprising fact." << endl; 
 
      if (ens.usingCin()) {  
         IRutil::finishLine(cin);  
      } 
       
      cout << "Among turns with second move rated exactly 0.01 worse, " << endl 
           << "and one of the first two moves played: " << endl << endl; 
      cout << "# of 0,0.01 turns: " << setw(5) << right << sdeq01Turns << endl 
           << "# 1st move played: " << setw(5) << right << sdeq01Matches 
           << ", " << 100.0*sdeq01Matches / sdeq01Turns << "%" << endl 
           << "# 2nd move played: " << setw(5) << right  
           << sdeq01Turns - sdeq01Matches << endl << endl; 
      cout << "That's right, 0.01 makes almost no difference in frequency! " 
           << endl << "So, a 2nd move rated 0.01 worse is played more often " 
           << "than one rated equal!" << endl 
           << "In particular, this seems to rule out any explanation that " 
           << "the 2nd of two equal" << endl 
           << "moves is expected to be 0.005 worse before any 2-digit " 
           << "rounding of evals." << endl << endl 
           << "Hence the phenomenon may be specific to cases of two or more " 
           << "moves that reach" << endl 
           << "the same end at high depth, but one " 
           << "more quickly or overtly." << endl 
           << "Whether this is part of a larger \"swing\" effect or explains " 
           << "the discrepancy" << endl 
           << "by itself needs closer inspection, and independent data sets "  
           << "would help." << endl; 
 
      cout << "Hit return to continue exploring (with option to quit)." << endl; 
 
      cout.flags(IRutil::URFORMAT); 
      cout << setprecision(6); 
      resultsFile.close(); 
      if (ens.usingCin()) { 
//cerr << endl << "Yes, using cin here." << endl; 
         IRutil::finishLine(cin);  
      } 
   } 
 
//-------------------------Demoralization Demo----------------------------- 
 
   void demoralizationDemo(Ensemble& ens) { 
 
      string fileName;   //*vital* to keep this updated! 
      ofstream* filep = agreeDemoFile(ens, fileName);  //fileName mutable 
      string timestamp = IRutil::getRawTime();  //already trimmed 
      string cal = IRutil::getTime(); 
      (*filep) << IRutil::IRCOMMENT << "Demoralization Demo done on " << cal 
               << " (" << timestamp << ")" << endl << endl; 
      filep->close();  //now we give writing control over to "ens" 
      ens.addOutputFile(fileName, false);  //false -> no extra comment 
 
      double defAdv, bigAdv; 
 
      cout << "Enter value for a definite advantage (+/-), e.g. 1.0 or 0.75: "; 
      ens.loggedRead(defAdv); 
 
      cout << "Enter value for a big advantage (+-), e.g. 2.0 or 1.5: "; 
      ens.loggedRead(bigAdv); 
 
      string da = IRutil::ftoa(defAdv,2); 
      string ba = IRutil::ftoa(bigAdv,2); 
 
      const DemoChoices dc = demoOptions(ens);  
      if (dc.cancel) { 
         cout << "Canceled---returning." << endl; 
         return; 
      } 
      //else 
 
      double origCap = ens.getFocusTrial()->getDeltaCap(); 
      double newCap = origCap;  //dc.newCap; 
//    ens.getFocusTrial()->setDeltaCap(newCap); 
 
      istringstream* isp = new istringstream(dc.groundFilters); 
      ens.interactFromStream(isp, ""); 
      //leaves control back at main menu and restores input from cin 
 
      if (dc.fitThenGo) { 
         ens.runFit(); 
      } 
 
      string st = " newFilters "; 
      st += " EvalWhite ewUpBig geq " + ba + " EvalWhite ewUpDef geq " + da; 
      st += " EvalWhite ewDownBig leq -"+ba + " EvalWhite ewDownDef leq -"+da; 
      st += " WhiteToMove wtm BlackToMove btm "; 
      st += " AndFilter wtmUpBig wtm y ewUpBig n "; 
      st += " AndFilter wtmUp wtm y ewUpDef n "; 
      st += " AndFilter btmUpBig btm y ewDownBig n "; 
      st += " AndFilter btmUp btm y ewDownDef n "; 
      st += " AndFilter wtmDownBig wtm y ewDownBig n "; 
      st += " AndFilter wtmDown wtm y ewDownDef n "; 
      st += " AndFilter btmDownBig btm y ewUpBig n "; 
      st += " AndFilter btmDown btm y ewUpDef n "; 
      st += " OrFilter ptmUpBig wtmUpBig y btmUpBig n "; 
      st += " OrFilter ptmUp wtmUp y btmUp n "; 
      st += " OrFilter ptmDownBig wtmDownBig y btmDownBig n "; 
      st += " OrFilter ptmDown wtmDown y btmDown n done "; 
 
      st += " newFilters NotFilter ptmNotDown ptmDown "; 
      st += " NotFilter ptmNotUp ptmUp "; 
      st += " NotFilter ptmNotDownBig ptmDownBig "; 
      st += " NotFilter ptmNotUpBig ptmUpBig "; 
      st += " AndFilter nearlyEven ptmNotDown y ptmNotUp n "; 
      st += " AndFilter ptmUpDef ptmUp y ptmNotUpBig n "; 
      st += " AndFilter ptmDownDef ptmDown y ptmNotDownBig n done "; 
 
      st += " detach ewUpBig y ewUpDef y ewDownBig y ewDownDef "; 
      st += " y wtm y btm y wtmUpBig y wtmUp y btmUpBig y btmUp "; 
      st += " y wtmDownBig y wtmDown y btmDown y btmDownBig "; 
      st += " y ptmUpBig y ptmUp y ptmDown y ptmDownBig "; 
      st += " y ptmNotDown y ptmNotUp y ptmNotUpBig y ptmNotDownBig "; 
      st += " y nearlyEven y ptmUpDef y ptmDownDef n "; 
 
      st += " perfTest y n ";       //does overall performance stats 
      st += " attach ptmUp n perfTest y n detach ptmUp n "; 
      st += " attach ptmDown n perfTest y n detach ptmDown n "; 
      st += " attach ptmUpBig n perfTest y n detach ptmUpBig n "; 
      st += " attach ptmUpDef n perfTest y n detach ptmUpDef n "; 
      st += " attach nearlyEven n perfTest y n detach nearlyEven n "; 
      st += " attach ptmDownDef n perfTest y n detach ptmDownDef n "; 
      st += " attach ptmDownBig n perfTest y n detach ptmDownBig n "; 
 
      st += " hideFilters ewUpBig y ewUpDef y ewDownBig y ewDownDef "; 
      st += " y wtm y btm y wtmUpBig y wtmUp y btmUpBig y btmUp "; 
      st += " y wtmDownBig y wtmDown y btmDown y btmDownBig "; 
      st += " y ptmUpBig y ptmUp y ptmDown y ptmDownBig "; 
      st += " y ptmNotDown y ptmNotUp y ptmNotUpBig y ptmNotDownBig "; 
      st += " y nearlyEven y ptmUpDef y ptmDownDef n "; 
 
      isp = new istringstream(st); 
      ens.interactFromStream(isp,"");  // "" starts from top of stream 
 
      cout << "(Hid a bunch of filters, so ignore any duplication warnings.)" 
           << endl; 
 
      ens.closeOutputFile(fileName);  //no more output, removed from "outs" 
 
      ifstream resultsFile(fileName.c_str()); 
      string line; 
      findLineWith(resultsFile, timestamp, line); 
      PerfData overallPerf(newCap),  upPerf(newCap),  downPerf(newCap),   
               upBigPerf(newCap),  upDefPerf(newCap); 
      PerfData nearlyEvenPerf(newCap),  downDefPerf(newCap),   
               downBigPerf(newCap); 
 
      parsePerfData(resultsFile, "Test using", overallPerf); 
      parsePerfData(resultsFile, "ptmUp", upPerf); 
      parsePerfData(resultsFile, "ptmDown", downPerf); 
      parsePerfData(resultsFile, "ptmUpBig", upBigPerf); 
      parsePerfData(resultsFile, "ptmUpDef", upDefPerf); 
      parsePerfData(resultsFile, "nearlyEven", nearlyEvenPerf); 
      parsePerfData(resultsFile, "ptmDownDef", downDefPerf); 
      parsePerfData(resultsFile, "ptmDownBig", downBigPerf); 
 
      bool flm = (dc.matchStat == "first"); 
      cout << endl << "SUMMARY of performance when \"Big\" (+-) is >=" << ba 
           << " and \"Def\" (+/-) is " << da << " to " << ba << endl; 
      cout << IRutil::DASHES << endl << PerfData::perfHeader(flm) << endl 
           << IRutil::DASHES << endl 
           << overallPerf.perfLine("Overall", flm) << endl 
           << upPerf.perfLine("Ahead", flm) << endl 
           << downPerf.perfLine("Behind", flm) << endl 
           << endl 
           << upBigPerf.perfLine("Up Big", flm) << endl 
           << upDefPerf.perfLine("Up Def", flm) << endl 
           << nearlyEvenPerf.perfLine("Evenish", flm) << endl 
           << downDefPerf.perfLine("Down Def", flm) << endl 
           << downBigPerf.perfLine("Down Big", flm) << endl 
           << IRutil::DASHES << endl << endl; 
  
      cout << "Either (1) we may infer humans \"play it safe\" or are " 
           << "careless when well ahead," << endl 
           << "and get demoralized when behind, or (2) the model needs to " 
           << "scale \"delta\" values" << endl 
           << "down when the overall evaluation is large.  However, the " 
           << "\"Up Def\" versus " << endl 
           << "\"Down Def\" results argue against (2), " 
           << "and (2) may imply (1) anyway!" << endl 
           << endl 
           << "Either way, this explains why computers are perceived as " 
           << "such tough defenders," << endl 
           << "especially when well behind!  (Caveat: data is small and " 
           << "\"heteroskedastic\".)" << endl; 
      cout << endl << "Hit return to return." << endl; 
 
      resultsFile.close(); 
      //ens.getFocusTrial()->setDeltaCap(origCap); 
      if (ens.usingCin()) { 
         IRutil::finishLine(cin); 
//cerr << endl << "Yes, using cin here." << endl; 
         IRutil::finishLine(cin);      //second call needed to get actual pause. 
      } 
      cout.flags(IRutil::URFORMAT); 
   } 
 
};  //end of Demos namespace 
 
 
#endif    //end of #ifndef __IR_DEMOS_CPP__ 
 
 
 
//File------------------------IRmain.cpp----------------------------------- 
 
/** File "IRmain.cpp", or the end of "IRall1file.cpp", by KWR. 
    See header comment in "IRincludes.h" (or at the top of "IRall1file.cpp") 
    for description and detailed use.  The following organization enables 
    this code to be compiled as one file or via inclusion of 20 files, 
    without using linking or a Makefile.  So just g++ or CC (etc.) this baby! 
    And do it -fast, man!---I mean with highest optimization! 
 */ 
 
#ifndef __IR_INCLUDES_H__ 
#include "IRincludes.h" 
#endif	  //end of #ifndef __IR_INCLUDES_H__ 
 
#ifndef __IR_UTIL_H__ 
#include "IRutil.h" 
#endif                      //end of #ifndef __IR_UTIL_H__ 
 
#ifndef __IR_FUNCTIONS_H__ 
#include "IRfunctions.h" 
#endif                      //end of #ifndef __IR_FUNCTIONS_H__ 
 
#ifndef __IR_MISC_GLOBAL_H__ 
#include "IRmiscGlobal.h" 
#endif	 //end of #ifndef __IR_MISC_GLOBAL_H__ 
 
#ifndef __IR_POSITION_H__
#include "Position.h"
#endif

#ifndef __IR_GAME_INFO_H__
#include "GameInfo.h"
#endif

#ifndef __IR_TRIAL_SPEC_H__ 
#include "TrialSpec.h" 
#endif	  //end of #ifndef __IR_TRIAL_SPEC_H__ 
 
#ifndef __IR_TURN_INFO_H__ 
#include "TurnInfo.h" 
#endif	  //end of #ifndef __IR_TURN_INFO_H__ 
 
#ifndef __IR_TUPLE_INFO_H__
#include "TupleInfo.h"
#endif 

#ifndef __IR_TURN_CONTEXT_H__
#include "TurnContext.h"
#endif

#ifndef __IR_FILTERS_H__ 
#include "Filters.h" 
#endif	  //end of #ifndef __IR_FILTERS_H__ 

#ifndef __IR_DELTA_SCALES_H__
#include "DeltaScales.h"
#endif    //end of #ifndef __IR_DELTA_SCALES_H__

 
#ifndef __IR_PERFDATA_H__ 
#include "PerfData.h" 
#endif	 //end of #ifndef __IR_PERFDATA_H__ 
 
#ifndef __IR_SHUFFLE_H__
#include "Shuffle.h"
#endif

#ifndef __IR_DECISION_INFO_H__
#include "DecisionInfo.h"
#endif
 
#ifndef __IR_MODELS_H__
#include "IRmodels.h"
#endif

#ifndef __IR_MOVESELECTION_H__
#include "MoveSelector.h"
#endif

#ifndef __IR_TRIAL_H__ 
#include "Trial.h" 
#endif	  //end of #ifndef __IR_TRIAL_H__ 
 
#ifndef __IR_TRIAL_FILTERS_H__ 
#include "TrialFilters.h" 
#endif 

#ifndef __IR_MULTIMIN_H__
#include "multimin.h"
#include "multimin.c"
#endif

#ifndef __IR_MPFIT_H__
#include "mpfit.h"
#include "mpfit.c"
#endif

 
#ifndef __IR_MINIMIZER_H__ 
#include "Minimizer.h" 
#endif	  //end of #ifndef __IR_MINIMIZER_H__ 
 
#ifndef __IR_MENUS_H__ 
#include "Menus.h" 
#endif	  //end of #ifndef __IR_MENUS_H__ 
 
#ifndef __IR_DEMOS_H__ 
#include "Demos.h" 
#endif	  //end of #ifndef __IR_DEMOS_H__ 
 
#ifndef __IR_ENSEMBLE_H__ 
#include "Ensemble.h" 
#endif	  //end of #ifndef __IR_ENSEMBLE_H__ 
 
 
void muteElistaSetup(Ensemble& ens) { 
   string strm = ""; 
   istringstream* istrp; 
   strm += " deltaScale y moreOptions FullFractalScale noPatch depthWindow 30 30 ";
   strm += " swingWindow 5 19 zeroDepth 1 judgmentDepth 0 normFactors omodo 1.01 finishScale ";
   strm += " newFilters EvalWithin ew3norm 3 0 y PrevEvalWithin pw3norm 3 0 y NextEvalWithin nw3norm 3 0 y ";
   strm += " EvalWithin ew4norm 4 0 y PrevEvalWithin pw4norm 4 0 y NextEvalWithin nw4norm 4 0 y ";
   strm += " EvalWithin ew5norm 5 0 y PrevEvalWithin pw5norm 5 0 y NextEvalWithin nw5norm 5 0 y ";
   strm += " OrFilter pew3norm ew3norm y pw3norm n OrFilter pnew3norm pw3norm y ew3norm y nw3norm n ";
   strm += " OrFilter pew4norm ew4norm y pw4norm n OrFilter pnew4norm pw4norm y ew4norm y nw4norm n ";
   strm += " OrFilter pew5norm ew5norm y pw5norm n OrFilter pnew5norm pw5norm y ew5norm y nw5norm n ";

   strm += " SecondDelta sdleq4 leq 4 ";
   strm += " EventIs SanLuis05 Luis EventIs Mexico07 Mexico ";
   strm += " OrFilter SL05+Mex07 SanLuis05 y Mexico07 n ";
   strm += " RepCount RC0 eq 0 n ";
   strm += " done ";

   
   strm += " newSelectors MoveEvalSelector EvalGoesToZero n y eq 0.00 0 ";
   strm += " MoveRawDeltaSelector Error050 n geq 0.50 0 ";
   strm += " MoveRawDeltaSelector Error100 n geq 1.00 0 ";
   strm += " MoveRawDeltaSelector Error200 n geq 2.00 0 ";
   strm += " MoveRawDeltaSelector Error400 n geq 4.00 0 ";
   strm += " MoveRawDeltaSelector delgeq01 n geq 0.01 0 ";
   strm += " MoveRawDeltaSelector delleq10 n leq 0.10 0 ";
   strm += " MoveRawDeltaSelector delgeq11 n geq 0.11 0 ";
   strm += " MoveRawDeltaSelector delleq30 n leq 0.30 0 ";
   strm += " MoveRawDeltaSelector delgeq31 n geq 0.31 0 ";
   strm += " MoveRawDeltaSelector delleq70 n leq 0.70 0 ";
   strm += " MoveRawDeltaSelector delgeq71 n geq 0.71 0 ";
   strm += " MoveRawDeltaSelector delleq150 n leq 1.50 0 ";
   strm += " done ";

   strm += " newSelectors AndSelector Delta01-10 no delgeq01 y delleq10 n ";
   strm += " AndSelector Delta11-30 no delgeq11 y delleq30 n ";
   strm += " AndSelector Delta31-70 no delgeq31 y delleq70 n ";
   strm += " AndSelector Delta71-150 no delgeq71 y delleq150 n done ";
   strm += " toggleSelectors delgeq01 delleq10 delgeq11 delleq30 delgeq31 delleq70 delgeq71 delleq150 go ";

   strm += " clearFilters attach RC0 y pnew4norm n ";
   strm += " showTrial n "; 
   strm += " addOutputFile " + IRutil::SESSIONFILENAME; 
   istrp = new istringstream(strm); 
   ens.interactFromStream(istrp, ""); 
} 

void basicSetup(Ensemble& ens) {
   //muteElistaSetup(ens);
   ens.hideFilter(new WhiteToMoveFilter());
   ens.hideFilter(new BlackToMoveFilter());
   ens.hideFilter(new DrawnGameFilter());
   ens.hideFilter(new BlackWinFilter());
   ens.hideFilter(new WhiteWinFilter());
   ens.hideFilter(new PlayerWinFilter());
   ens.hideFilter(new PlayerLossFilter());
   ens.hideFilter(new FirstLineMatchFilter());
   ens.hideFilter(new EqualTopMoveFilter());
   ens.hideFilter(new InCheckFilter());
   ens.hideFilter(new EventTypeFilter("swiss", "Swiss"));
   ens.hideFilter(new EventTypeFilter("tourn", "RR-tourn"));
   ens.hideFilter(new EventTypeFilter("rapid", "Rapid"));
   ens.hideFilter(new EventTypeFilter("blitz", "Blitz"));
   ens.hideFilter(new TeamEventFilter());
   ens.hideFilter(new EventTypeFilter("schev", "Schev"));
   ens.hideFilter(new EventTypeFilter("simul", "Simul"));
   ens.hideFilter(new EventTypeFilter("ko", "Knockout"));
   ens.hideFilter(new EngineFilter("omod", "10", "Komodo 10"));
   ens.hideFilter(new EngineFilter("omod", "", "Komodo-all-versions"));
   ens.hideFilter(new EngineFilter("omod", "9.42", "Komodo-9.42"));
   ens.hideFilter(new EngineFilter("omod", "9.3", "Komodo-9.3.x"));
   ens.hideFilter(new EngineFilter("omod", "9.2", "Komodo-9.2.x"));
   ens.hideFilter(new EngineFilter("ockf", "7", "Stockfish-7"));
   ens.hideFilter(new EngineFilter("ockf", "6", "Stockfish-6"));
   ens.hideFilter(new EngineFilter("ockf", "", "Stockfish-all-versions"));
   ens.hideFilter(new EngineFilter("ybka", "", "Rybka-all-versions"));
   ens.hideFilter(new EngineFilter("oudi", "", "Houdini-all-versions"));

   ens.addSelector(new PawnMoveSelector());
   ens.addSelector(new KnightMoveSelector());
   ens.addSelector(new BishopMoveSelector());
   ens.addSelector(new RookMoveSelector());
   ens.addSelector(new QueenMoveSelector());
   ens.addSelector(new KingMoveSelector());
   ens.addSelector(new CastlingSelector());
   ens.addSelector(new CaptureSelector());
   ens.addSelector(new NonCaptureSelector());
   ens.addSelector(new PromotionSelector());
   ens.addSelector(new AdvancingMoveSelector());
   ens.addSelector(new RetreatingMoveSelector());
   ens.addSelector(new SidewaysMoveSelector());
   ens.addSelector(new CheckingMoveSelector());
   ens.addSelector(new EngineMoveSelector());
   ens.addSelector(new PlayedMoveSelector());
   ens.addSelector(new SamePieceAsPrevMoveSelector());
   //ens.addSelector(new SwingNegativeSelector(ens.getFocusTrial(), false));
   //ens.addSelector(new SwingNonNegativeSelector(ens.getFocusTrial(), false));
   MoveSelector* etv = new EqualTopMoveSelector();
   ens.addSelector(etv);

/*
   ens.addSelector(new MoveRawDeltaSelector(GEQ, 0.01, 0, false, "delgeq01"));
   ens.addSelector(new MoveRawDeltaSelector(LEQ, 0.10, 0, false, "delleq10"));
   ens.addSelector(new MoveRawDeltaSelector(GEQ, 0.11, 0, false, "delgeq11"));
   ens.addSelector(new MoveRawDeltaSelector(LEQ, 0.30, 0, false, "delleq30"));   
   ens.addSelector(new MoveRawDeltaSelector(GEQ, 0.31, 0, false, "delgeq31"));
   ens.addSelector(new MoveRawDeltaSelector(LEQ, 0.70, 0, false, "delleq70"));
   ens.addSelector(new MoveRawDeltaSelector(GEQ, 0.71, 0, false, "delgeq71"));
   ens.addSelector(new MoveRawDeltaSelector(LEQ, 1.50, 0, false, "delleq150"));
*/
   

/*
MoveRawDeltaSelector(const COMPARE comp, const double gdelta, const size_t gdepth,
                     bool nullExcludes, const string& name)
   ens.justAddSelector(new PawnMoveSelector());
   ens.justAddSelector(new KnightMoveSelector());
   ens.justAddSelector(new BishopMoveSelector());
   ens.justAddSelector(new RookMoveSelector());
   ens.justAddSelector(new QueenMoveSelector());
   ens.justAddSelector(new KingMoveSelector());
   ens.justAddSelector(new CastlingSelector());
   ens.justAddSelector(new CaptureSelector());
   ens.justAddSelector(new NonCaptureSelector());
   ens.justAddSelector(new PromotionSelector());
   ens.justAddSelector(new AdvancingMoveSelector());
   ens.justAddSelector(new RetreatingMoveSelector());
   ens.justAddSelector(new SidewaysMoveSelector());
   ens.justAddSelector(new CheckingMoveSelector());
   ens.justAddSelector(new EngineMoveSelector());
   ens.justAddSelector(new PlayedMoveSelector());
   ens.justAddSelector(new SamePieceAsPrevMoveSelector());
   ens.justAddSelector(new SwingNegativeSelector(ens.getFocusTrial(), false));
   ens.justAddSelector(new SwingNonNegativeSelector(ens.getFocusTrial(), false));
   MoveSelector* etv = new EqualTopMoveSelector();
   ens.justAddSelector(etv);
   //ens.setSelector(etv);
*/ 
}

 
int main() { 
   string ans, elistaAns; 
   string dataPath = "/projects/regan/Chess/CSE712/AIF/";
   cout << "Use \"PowerShares\" trial with path " << dataPath 
        << " to file SF7Turns.aif? (y/n) " << endl;
   cin >> ans; 
   ans = IRutil::trim(ans); 
   /*
   cout << "Run Elista Demo? (y/n) " << endl; 
   cin >> elistaAns; 
   elistaAns = IRutil::trim(elistaAns); 
   */
   IRfun::initNames();   //sets up curve and weight-method menus
   initPolicyNames();
   LineScale* ls;
 
   if (IRutil::isYes(ans)) {   // || IRutil::isYes(elistaAns)) { 
      //TrialSpec ts(IRfun::INVEXP, 0.0824614, 0.519043, IRfun::UNITWTS, "SLMfit"); 
      map<IRfun::CURVES, double> curveBook;
      curveBook[IRfun::INVEXP] = 1.0;
      TrialSpec ts(IRfun::INVEXP, curveBook, IRfun::UNITWTS, "start",
                   //0.0214748, 0.532259, 15.4764, 0.0934588, 0.007780, 0.0, 0.0, 0.372179);
                   //0.02, 0.53, 14.5, 0.05, 1.00, 1.61, 1.0, 1.00);
                   0.05, 0.60, 12.5, 0.05, 1.00, 1.00, 1.00, 1.00,
                   false, IRfun::FOLDEDLOGISTIC, 0.00, 2.00, 5.00, 1.0, 1.0, 0.01, 0.00);

      map<string, double> engineInits;
      engineInits[string("omodo")] = 1.01;
      engineInits[string("tockfish")] = 1.0;
      map<APPLICATION_POLICIES, double> appp;
      appp[SEPARATE_REL2] = 1.0;
      //appp[LINK_REL2] = 1;
      SwingInfo* swi = new SwingInfo(appp, true, false, true, false, false, 0, false, false, 0.0);

      //ls = new TranslateByEval(new MulScale("MulScale", false, swi, NO_PATCH, 
                                 //IRutil::CENTRALPATCHPOWER, 0.00, engineInits, 
                                 //5, 30, 30, 5, 19, 0, 1.0, 1.600, 1.200, true));

      //ls = new TranslateByEval(new FullFractalScale("FullFractalScale", true, swi, NO_PATCH,
            //IRutil::CENTRALPATCHPOWER, 0.00, engineInits,
            //1, 30, 30, 5, 20, 0, 1.0, 1.6, 1.2));   //zero radius; 
      
      ls = new SimpleFullFractalScale("SimpleFullFractalScale", true, swi, NO_PATCH,
            IRutil::CENTRALPATCHPOWER, 0.00, engineInits,
            1, 30, 30, 5, 19, 0, 1.0, 1.6, 1.2);   //zero radius;
      ls->setDeltaCap(IRutil::DELTACAP);

      //noPatch, WEF, cap 10.00; (sepRel2:1),damped
      string prefix = ", noPatch, WEF, cap " + IRutil::ftoa(IRutil::DELTACAP,2) + "; " + string(*swi);
      string infix = "[30 .. 30, 5 .. 19; 0]";
      string suffix = "(0, 1.0, 1.6, 1.2, 1.0, 1.0)";
      ls->extendName(prefix + "\n" + infix + suffix);

      //ls will be superseded in muteElistaSetup but is added to the option list

      Trial* ft = new Trial("BasicPowerShares", new list<TurnInfo*>(), ts, 
                            Models::POWER_SHARES, false, true, ls); 
                            //Models::SHARES, false, true, ls);
 
      ofstream* filep = new ofstream(IRutil::LOGFILENAME.c_str(), ios::app); 
      bool check = filep->is_open(); 
      if (!check) { 
         cerr << "Cannot read the input file, using null log..." << endl; 
      }
      ostream* checkp = new IRutil::nullstream(); 
      if (check) { checkp = filep; } 
      cout << "Creating Ensemble now..." << endl;
      Ensemble ens(ft, dataPath, checkp);             //sets timestamp before reading 
      //ens.readInputFile("R3Turns.txt"); 

      cout << "Reading input now...";
      //ens.readInputFile("R3Turns.aif", false, false); 
      ens.readTurnsFromFileGlob("SF7Turns.aif");
      cout << "done." << endl;
 
      muteElistaSetup(ens);
      basicSetup(ens);
      ens.loggedWrite("",true);  //inserts blank line after log of initializations
 
      cout << "Interacting now." << endl;
      ens.interact(); 

   } else { 
      Ensemble ens; 
      cout << "Please enter full default data path: " << endl;
      getline(cin,dataPath);
      dataPath = IRutil::trim(dataPath);
      ens.setDataPath(dataPath);
      ens.interact(); 
   } 

   cerr << endl << "Games and positions with issues:" << endl;
   set<string>::const_iterator itg = IRutil::PROBLEM_GAMES.begin();
   while (itg != IRutil::PROBLEM_GAMES.end()) { cerr << *itg++ << endl; }

   cerr << endl << "Exiting...";
   delete(ls);
   cerr << "done." << endl;
} 
